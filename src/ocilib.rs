/* automatically generated by rust-bindgen */

pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201605;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 24;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const _STDLIB_H: ::std::os::raw::c_uint = 1;
pub const WNOHANG: ::std::os::raw::c_uint = 1;
pub const WUNTRACED: ::std::os::raw::c_uint = 2;
pub const WSTOPPED: ::std::os::raw::c_uint = 2;
pub const WEXITED: ::std::os::raw::c_uint = 4;
pub const WCONTINUED: ::std::os::raw::c_uint = 8;
pub const WNOWAIT: ::std::os::raw::c_uint = 16777216;
pub const __WNOTHREAD: ::std::os::raw::c_uint = 536870912;
pub const __WALL: ::std::os::raw::c_uint = 1073741824;
pub const __WCLONE: ::std::os::raw::c_uint = 2147483648;
pub const __ENUM_IDTYPE_T: ::std::os::raw::c_uint = 1;
pub const __W_CONTINUED: ::std::os::raw::c_uint = 65535;
pub const __WCOREFLAG: ::std::os::raw::c_uint = 128;
pub const __ldiv_t_defined: ::std::os::raw::c_uint = 1;
pub const RAND_MAX: ::std::os::raw::c_uint = 2147483647;
pub const EXIT_FAILURE: ::std::os::raw::c_uint = 1;
pub const EXIT_SUCCESS: ::std::os::raw::c_uint = 0;
pub const _SYS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const __clock_t_defined: ::std::os::raw::c_uint = 1;
pub const __time_t_defined: ::std::os::raw::c_uint = 1;
pub const __clockid_t_defined: ::std::os::raw::c_uint = 1;
pub const __timer_t_defined: ::std::os::raw::c_uint = 1;
pub const __BIT_TYPES_DEFINED__: ::std::os::raw::c_uint = 1;
pub const _ENDIAN_H: ::std::os::raw::c_uint = 1;
pub const __LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const __BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const __PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const __BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const __FLOAT_WORD_ORDER: ::std::os::raw::c_uint = 1234;
pub const LITTLE_ENDIAN: ::std::os::raw::c_uint = 1234;
pub const BIG_ENDIAN: ::std::os::raw::c_uint = 4321;
pub const PDP_ENDIAN: ::std::os::raw::c_uint = 3412;
pub const BYTE_ORDER: ::std::os::raw::c_uint = 1234;
pub const _BITS_BYTESWAP_H: ::std::os::raw::c_uint = 1;
pub const _SYS_SELECT_H: ::std::os::raw::c_uint = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\x00";
pub const _SIGSET_H_types: ::std::os::raw::c_uint = 1;
pub const __timespec_defined: ::std::os::raw::c_uint = 1;
pub const _STRUCT_TIMEVAL: ::std::os::raw::c_uint = 1;
pub const FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _SYS_SYSMACROS_H: ::std::os::raw::c_uint = 1;
pub const _BITS_PTHREADTYPES_H: ::std::os::raw::c_uint = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_MUTEX_T: ::std::os::raw::c_uint = 40;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_COND_T: ::std::os::raw::c_uint = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: ::std::os::raw::c_uint = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: ::std::os::raw::c_uint = 56;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: ::std::os::raw::c_uint = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: ::std::os::raw::c_uint = 32;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: ::std::os::raw::c_uint = 4;
pub const __have_pthread_attr_t: ::std::os::raw::c_uint = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: ::std::os::raw::c_uint = 1;
pub const _ALLOCA_H: ::std::os::raw::c_uint = 1;
pub const _STDIO_H: ::std::os::raw::c_uint = 1;
pub const __FILE_defined: ::std::os::raw::c_uint = 1;
pub const ____FILE_defined: ::std::os::raw::c_uint = 1;
pub const _G_config_h: ::std::os::raw::c_uint = 1;
pub const ____mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MMAP: ::std::os::raw::c_uint = 1;
pub const _G_HAVE_MREMAP: ::std::os::raw::c_uint = 1;
pub const _G_IO_IO_FILE_VERSION: ::std::os::raw::c_uint = 131073;
pub const _G_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const _IO_BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const __GNUC_VA_LIST: ::std::os::raw::c_uint = 1;
pub const _IO_UNIFIED_JUMPTABLES: ::std::os::raw::c_uint = 1;
pub const EOF: ::std::os::raw::c_int = -1;
pub const _IOS_INPUT: ::std::os::raw::c_uint = 1;
pub const _IOS_OUTPUT: ::std::os::raw::c_uint = 2;
pub const _IOS_ATEND: ::std::os::raw::c_uint = 4;
pub const _IOS_APPEND: ::std::os::raw::c_uint = 8;
pub const _IOS_TRUNC: ::std::os::raw::c_uint = 16;
pub const _IOS_NOCREATE: ::std::os::raw::c_uint = 32;
pub const _IOS_NOREPLACE: ::std::os::raw::c_uint = 64;
pub const _IOS_BIN: ::std::os::raw::c_uint = 128;
pub const _IO_MAGIC: ::std::os::raw::c_uint = 4222418944;
pub const _OLD_STDIO_MAGIC: ::std::os::raw::c_uint = 4206624768;
pub const _IO_MAGIC_MASK: ::std::os::raw::c_uint = 4294901760;
pub const _IO_USER_BUF: ::std::os::raw::c_uint = 1;
pub const _IO_UNBUFFERED: ::std::os::raw::c_uint = 2;
pub const _IO_NO_READS: ::std::os::raw::c_uint = 4;
pub const _IO_NO_WRITES: ::std::os::raw::c_uint = 8;
pub const _IO_EOF_SEEN: ::std::os::raw::c_uint = 16;
pub const _IO_ERR_SEEN: ::std::os::raw::c_uint = 32;
pub const _IO_DELETE_DONT_CLOSE: ::std::os::raw::c_uint = 64;
pub const _IO_LINKED: ::std::os::raw::c_uint = 128;
pub const _IO_IN_BACKUP: ::std::os::raw::c_uint = 256;
pub const _IO_LINE_BUF: ::std::os::raw::c_uint = 512;
pub const _IO_TIED_PUT_GET: ::std::os::raw::c_uint = 1024;
pub const _IO_CURRENTLY_PUTTING: ::std::os::raw::c_uint = 2048;
pub const _IO_IS_APPENDING: ::std::os::raw::c_uint = 4096;
pub const _IO_IS_FILEBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_BAD_SEEN: ::std::os::raw::c_uint = 16384;
pub const _IO_USER_LOCK: ::std::os::raw::c_uint = 32768;
pub const _IO_FLAGS2_MMAP: ::std::os::raw::c_uint = 1;
pub const _IO_FLAGS2_NOTCANCEL: ::std::os::raw::c_uint = 2;
pub const _IO_FLAGS2_USER_WBUF: ::std::os::raw::c_uint = 8;
pub const _IO_SKIPWS: ::std::os::raw::c_uint = 1;
pub const _IO_LEFT: ::std::os::raw::c_uint = 2;
pub const _IO_RIGHT: ::std::os::raw::c_uint = 4;
pub const _IO_INTERNAL: ::std::os::raw::c_uint = 8;
pub const _IO_DEC: ::std::os::raw::c_uint = 16;
pub const _IO_OCT: ::std::os::raw::c_uint = 32;
pub const _IO_HEX: ::std::os::raw::c_uint = 64;
pub const _IO_SHOWBASE: ::std::os::raw::c_uint = 128;
pub const _IO_SHOWPOINT: ::std::os::raw::c_uint = 256;
pub const _IO_UPPERCASE: ::std::os::raw::c_uint = 512;
pub const _IO_SHOWPOS: ::std::os::raw::c_uint = 1024;
pub const _IO_SCIENTIFIC: ::std::os::raw::c_uint = 2048;
pub const _IO_FIXED: ::std::os::raw::c_uint = 4096;
pub const _IO_UNITBUF: ::std::os::raw::c_uint = 8192;
pub const _IO_STDIO: ::std::os::raw::c_uint = 16384;
pub const _IO_DONT_CLOSE: ::std::os::raw::c_uint = 32768;
pub const _IO_BOOLALPHA: ::std::os::raw::c_uint = 65536;
pub const _IOFBF: ::std::os::raw::c_uint = 0;
pub const _IOLBF: ::std::os::raw::c_uint = 1;
pub const _IONBF: ::std::os::raw::c_uint = 2;
pub const BUFSIZ: ::std::os::raw::c_uint = 8192;
pub const SEEK_SET: ::std::os::raw::c_uint = 0;
pub const SEEK_CUR: ::std::os::raw::c_uint = 1;
pub const SEEK_END: ::std::os::raw::c_uint = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\x00";
pub const L_tmpnam: ::std::os::raw::c_uint = 20;
pub const TMP_MAX: ::std::os::raw::c_uint = 238328;
pub const FILENAME_MAX: ::std::os::raw::c_uint = 4096;
pub const L_ctermid: ::std::os::raw::c_uint = 9;
pub const FOPEN_MAX: ::std::os::raw::c_uint = 16;
pub const _CTYPE_H: ::std::os::raw::c_uint = 1;
pub const _XLOCALE_H: ::std::os::raw::c_uint = 1;
pub const _WCTYPE_H: ::std::os::raw::c_uint = 1;
pub const WEOF: ::std::os::raw::c_uint = 4294967295;
pub const _STRING_H: ::std::os::raw::c_uint = 1;
pub const _TIME_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TIME_H: ::std::os::raw::c_uint = 1;
pub const CLOCK_REALTIME: ::std::os::raw::c_uint = 0;
pub const CLOCK_MONOTONIC: ::std::os::raw::c_uint = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: ::std::os::raw::c_uint = 2;
pub const CLOCK_THREAD_CPUTIME_ID: ::std::os::raw::c_uint = 3;
pub const CLOCK_MONOTONIC_RAW: ::std::os::raw::c_uint = 4;
pub const CLOCK_REALTIME_COARSE: ::std::os::raw::c_uint = 5;
pub const CLOCK_MONOTONIC_COARSE: ::std::os::raw::c_uint = 6;
pub const CLOCK_BOOTTIME: ::std::os::raw::c_uint = 7;
pub const CLOCK_REALTIME_ALARM: ::std::os::raw::c_uint = 8;
pub const CLOCK_BOOTTIME_ALARM: ::std::os::raw::c_uint = 9;
pub const CLOCK_TAI: ::std::os::raw::c_uint = 11;
pub const TIMER_ABSTIME: ::std::os::raw::c_uint = 1;
pub const TIME_UTC: ::std::os::raw::c_uint = 1;
pub const _LIBC_LIMITS_H_: ::std::os::raw::c_uint = 1;
pub const MB_LEN_MAX: ::std::os::raw::c_uint = 16;
pub const _BITS_POSIX1_LIM_H: ::std::os::raw::c_uint = 1;
pub const _POSIX_AIO_LISTIO_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX_AIO_MAX: ::std::os::raw::c_uint = 1;
pub const _POSIX_ARG_MAX: ::std::os::raw::c_uint = 4096;
pub const _POSIX_CHILD_MAX: ::std::os::raw::c_uint = 25;
pub const _POSIX_DELAYTIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_HOST_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_LINK_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_LOGIN_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_MAX_CANON: ::std::os::raw::c_uint = 255;
pub const _POSIX_MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const _POSIX_MQ_OPEN_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_MQ_PRIO_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const _POSIX_NGROUPS_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_OPEN_MAX: ::std::os::raw::c_uint = 20;
pub const _POSIX_PATH_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_PIPE_BUF: ::std::os::raw::c_uint = 512;
pub const _POSIX_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_RTSIG_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SEM_NSEMS_MAX: ::std::os::raw::c_uint = 256;
pub const _POSIX_SEM_VALUE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_SIGQUEUE_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_SSIZE_MAX: ::std::os::raw::c_uint = 32767;
pub const _POSIX_STREAM_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_SYMLINK_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX_SYMLOOP_MAX: ::std::os::raw::c_uint = 8;
pub const _POSIX_TIMER_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_TTY_NAME_MAX: ::std::os::raw::c_uint = 9;
pub const _POSIX_TZNAME_MAX: ::std::os::raw::c_uint = 6;
pub const _POSIX_CLOCKRES_MIN: ::std::os::raw::c_uint = 20000000;
pub const NR_OPEN: ::std::os::raw::c_uint = 1024;
pub const NGROUPS_MAX: ::std::os::raw::c_uint = 65536;
pub const ARG_MAX: ::std::os::raw::c_uint = 131072;
pub const LINK_MAX: ::std::os::raw::c_uint = 127;
pub const MAX_CANON: ::std::os::raw::c_uint = 255;
pub const MAX_INPUT: ::std::os::raw::c_uint = 255;
pub const NAME_MAX: ::std::os::raw::c_uint = 255;
pub const PATH_MAX: ::std::os::raw::c_uint = 4096;
pub const PIPE_BUF: ::std::os::raw::c_uint = 4096;
pub const XATTR_NAME_MAX: ::std::os::raw::c_uint = 255;
pub const XATTR_SIZE_MAX: ::std::os::raw::c_uint = 65536;
pub const XATTR_LIST_MAX: ::std::os::raw::c_uint = 65536;
pub const RTSIG_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX_THREAD_KEYS_MAX: ::std::os::raw::c_uint = 128;
pub const PTHREAD_KEYS_MAX: ::std::os::raw::c_uint = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: ::std::os::raw::c_uint = 4;
pub const _POSIX_THREAD_THREADS_MAX: ::std::os::raw::c_uint = 64;
pub const AIO_PRIO_DELTA_MAX: ::std::os::raw::c_uint = 20;
pub const PTHREAD_STACK_MIN: ::std::os::raw::c_uint = 16384;
pub const DELAYTIMER_MAX: ::std::os::raw::c_uint = 2147483647;
pub const TTY_NAME_MAX: ::std::os::raw::c_uint = 32;
pub const LOGIN_NAME_MAX: ::std::os::raw::c_uint = 256;
pub const HOST_NAME_MAX: ::std::os::raw::c_uint = 64;
pub const MQ_PRIO_MAX: ::std::os::raw::c_uint = 32768;
pub const SEM_VALUE_MAX: ::std::os::raw::c_uint = 2147483647;
pub const _BITS_POSIX2_LIM_H: ::std::os::raw::c_uint = 1;
pub const _POSIX2_BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const _POSIX2_BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 2;
pub const _POSIX2_EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const _POSIX2_LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const _POSIX2_RE_DUP_MAX: ::std::os::raw::c_uint = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 14;
pub const BC_BASE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_DIM_MAX: ::std::os::raw::c_uint = 2048;
pub const BC_SCALE_MAX: ::std::os::raw::c_uint = 99;
pub const BC_STRING_MAX: ::std::os::raw::c_uint = 1000;
pub const COLL_WEIGHTS_MAX: ::std::os::raw::c_uint = 255;
pub const EXPR_NEST_MAX: ::std::os::raw::c_uint = 32;
pub const LINE_MAX: ::std::os::raw::c_uint = 2048;
pub const CHARCLASS_NAME_MAX: ::std::os::raw::c_uint = 2048;
pub const RE_DUP_MAX: ::std::os::raw::c_uint = 32767;
pub const OCILIB_MAJOR_VERSION: ::std::os::raw::c_uint = 4;
pub const OCILIB_MINOR_VERSION: ::std::os::raw::c_uint = 3;
pub const OCILIB_REVISION_VERSION: ::std::os::raw::c_uint = 2;
pub const OCI_IMPORT_MODE_LINKAGE: ::std::os::raw::c_uint = 1;
pub const OCI_IMPORT_MODE_RUNTIME: ::std::os::raw::c_uint = 2;
pub const OCI_IMPORT_MODE: ::std::os::raw::c_uint = 1;
pub const _WCHAR_H: ::std::os::raw::c_uint = 1;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const __mbstate_t_defined: ::std::os::raw::c_uint = 1;
pub const OCI_CHAR_ANSI: ::std::os::raw::c_uint = 1;
pub const OCI_CHAR_WIDE: ::std::os::raw::c_uint = 2;
pub const OCI_CHAR_TEXT: ::std::os::raw::c_uint = 1;
pub const TRUE: ::std::os::raw::c_uint = 1;
pub const FALSE: ::std::os::raw::c_uint = 0;
pub const OCI_8_0: ::std::os::raw::c_uint = 800;
pub const OCI_8_1: ::std::os::raw::c_uint = 810;
pub const OCI_9_0: ::std::os::raw::c_uint = 900;
pub const OCI_9_2: ::std::os::raw::c_uint = 920;
pub const OCI_10_1: ::std::os::raw::c_uint = 1010;
pub const OCI_10_2: ::std::os::raw::c_uint = 1020;
pub const OCI_11_1: ::std::os::raw::c_uint = 1110;
pub const OCI_11_2: ::std::os::raw::c_uint = 1120;
pub const OCI_12_1: ::std::os::raw::c_uint = 1210;
pub const OCI_ERR_ORACLE: ::std::os::raw::c_uint = 1;
pub const OCI_ERR_OCILIB: ::std::os::raw::c_uint = 2;
pub const OCI_ERR_WARNING: ::std::os::raw::c_uint = 3;
pub const OCI_ERR_NONE: ::std::os::raw::c_uint = 0;
pub const OCI_ERR_NOT_INITIALIZED: ::std::os::raw::c_uint = 1;
pub const OCI_ERR_LOADING_SHARED_LIB: ::std::os::raw::c_uint = 2;
pub const OCI_ERR_LOADING_SYMBOLS: ::std::os::raw::c_uint = 3;
pub const OCI_ERR_MULTITHREADED: ::std::os::raw::c_uint = 4;
pub const OCI_ERR_MEMORY: ::std::os::raw::c_uint = 5;
pub const OCI_ERR_NOT_AVAILABLE: ::std::os::raw::c_uint = 6;
pub const OCI_ERR_NULL_POINTER: ::std::os::raw::c_uint = 7;
pub const OCI_ERR_DATATYPE_NOT_SUPPORTED: ::std::os::raw::c_uint = 8;
pub const OCI_ERR_PARSE_TOKEN: ::std::os::raw::c_uint = 9;
pub const OCI_ERR_MAP_ARGUMENT: ::std::os::raw::c_uint = 10;
pub const OCI_ERR_OUT_OF_BOUNDS: ::std::os::raw::c_uint = 11;
pub const OCI_ERR_UNFREED_DATA: ::std::os::raw::c_uint = 12;
pub const OCI_ERR_MAX_BIND: ::std::os::raw::c_uint = 13;
pub const OCI_ERR_ATTR_NOT_FOUND: ::std::os::raw::c_uint = 14;
pub const OCI_ERR_MIN_VALUE: ::std::os::raw::c_uint = 15;
pub const OCI_ERR_NOT_COMPATIBLE: ::std::os::raw::c_uint = 16;
pub const OCI_ERR_STMT_STATE: ::std::os::raw::c_uint = 17;
pub const OCI_ERR_STMT_NOT_SCROLLABLE: ::std::os::raw::c_uint = 18;
pub const OCI_ERR_BIND_ALREADY_USED: ::std::os::raw::c_uint = 19;
pub const OCI_ERR_BIND_ARRAY_SIZE: ::std::os::raw::c_uint = 20;
pub const OCI_ERR_COLUMN_NOT_FOUND: ::std::os::raw::c_uint = 21;
pub const OCI_ERR_DIRPATH_STATE: ::std::os::raw::c_uint = 22;
pub const OCI_ERR_CREATE_OCI_ENVIRONMENT: ::std::os::raw::c_uint = 23;
pub const OCI_ERR_REBIND_BAD_DATATYPE: ::std::os::raw::c_uint = 24;
pub const OCI_ERR_TYPEINFO_DATATYPE: ::std::os::raw::c_uint = 25;
pub const OCI_ERR_ITEM_NOT_FOUND: ::std::os::raw::c_uint = 26;
pub const OCI_ERR_ARG_INVALID_VALUE: ::std::os::raw::c_uint = 27;
pub const OCI_ERR_COUNT: ::std::os::raw::c_uint = 28;
pub const OCI_MEM_ORACLE: ::std::os::raw::c_uint = 1;
pub const OCI_MEM_OCILIB: ::std::os::raw::c_uint = 2;
pub const OCI_MEM_ALL: ::std::os::raw::c_uint = 3;
pub const OCI_BIND_BY_POS: ::std::os::raw::c_uint = 0;
pub const OCI_BIND_BY_NAME: ::std::os::raw::c_uint = 1;
pub const OCI_BIND_SIZE: ::std::os::raw::c_uint = 6;
pub const OCI_BIND_MAX: ::std::os::raw::c_uint = 65535;
pub const OCI_FETCH_SIZE: ::std::os::raw::c_uint = 20;
pub const OCI_PREFETCH_SIZE: ::std::os::raw::c_uint = 20;
pub const OCI_LONG_EXPLICIT: ::std::os::raw::c_uint = 1;
pub const OCI_LONG_IMPLICIT: ::std::os::raw::c_uint = 2;
pub const OCI_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const OCI_CDT_NUMERIC: ::std::os::raw::c_uint = 1;
pub const OCI_CDT_DATETIME: ::std::os::raw::c_uint = 3;
pub const OCI_CDT_TEXT: ::std::os::raw::c_uint = 4;
pub const OCI_CDT_LONG: ::std::os::raw::c_uint = 5;
pub const OCI_CDT_CURSOR: ::std::os::raw::c_uint = 6;
pub const OCI_CDT_LOB: ::std::os::raw::c_uint = 7;
pub const OCI_CDT_FILE: ::std::os::raw::c_uint = 8;
pub const OCI_CDT_TIMESTAMP: ::std::os::raw::c_uint = 9;
pub const OCI_CDT_INTERVAL: ::std::os::raw::c_uint = 10;
pub const OCI_CDT_RAW: ::std::os::raw::c_uint = 11;
pub const OCI_CDT_OBJECT: ::std::os::raw::c_uint = 12;
pub const OCI_CDT_COLLECTION: ::std::os::raw::c_uint = 13;
pub const OCI_CDT_REF: ::std::os::raw::c_uint = 14;
pub const OCI_CDT_BOOLEAN: ::std::os::raw::c_uint = 15;
pub const OCI_ARG_SHORT: ::std::os::raw::c_uint = 1;
pub const OCI_ARG_USHORT: ::std::os::raw::c_uint = 2;
pub const OCI_ARG_INT: ::std::os::raw::c_uint = 3;
pub const OCI_ARG_UINT: ::std::os::raw::c_uint = 4;
pub const OCI_ARG_BIGINT: ::std::os::raw::c_uint = 5;
pub const OCI_ARG_BIGUINT: ::std::os::raw::c_uint = 6;
pub const OCI_ARG_DOUBLE: ::std::os::raw::c_uint = 7;
pub const OCI_ARG_DATETIME: ::std::os::raw::c_uint = 8;
pub const OCI_ARG_TEXT: ::std::os::raw::c_uint = 9;
pub const OCI_ARG_LOB: ::std::os::raw::c_uint = 10;
pub const OCI_ARG_FILE: ::std::os::raw::c_uint = 11;
pub const OCI_ARG_TIMESTAMP: ::std::os::raw::c_uint = 12;
pub const OCI_ARG_INTERVAL: ::std::os::raw::c_uint = 13;
pub const OCI_ARG_RAW: ::std::os::raw::c_uint = 14;
pub const OCI_ARG_OBJECT: ::std::os::raw::c_uint = 15;
pub const OCI_ARG_COLLECTION: ::std::os::raw::c_uint = 16;
pub const OCI_ARG_REF: ::std::os::raw::c_uint = 17;
pub const OCI_ARG_FLOAT: ::std::os::raw::c_uint = 18;
pub const OCI_ARG_NUMBER: ::std::os::raw::c_uint = 19;
pub const OCI_CST_SELECT: ::std::os::raw::c_uint = 1;
pub const OCI_CST_UPDATE: ::std::os::raw::c_uint = 2;
pub const OCI_CST_DELETE: ::std::os::raw::c_uint = 3;
pub const OCI_CST_INSERT: ::std::os::raw::c_uint = 4;
pub const OCI_CST_CREATE: ::std::os::raw::c_uint = 5;
pub const OCI_CST_DROP: ::std::os::raw::c_uint = 6;
pub const OCI_CST_ALTER: ::std::os::raw::c_uint = 7;
pub const OCI_CST_BEGIN: ::std::os::raw::c_uint = 8;
pub const OCI_CST_DECLARE: ::std::os::raw::c_uint = 9;
pub const OCI_CST_CALL: ::std::os::raw::c_uint = 10;
pub const OCI_ENV_DEFAULT: ::std::os::raw::c_uint = 0;
pub const OCI_ENV_THREADED: ::std::os::raw::c_uint = 1;
pub const OCI_ENV_CONTEXT: ::std::os::raw::c_uint = 2;
pub const OCI_ENV_EVENTS: ::std::os::raw::c_uint = 4;
pub const OCI_SESSION_DEFAULT: ::std::os::raw::c_uint = 0;
pub const OCI_SESSION_XA: ::std::os::raw::c_uint = 1;
pub const OCI_SESSION_SYSDBA: ::std::os::raw::c_uint = 2;
pub const OCI_SESSION_SYSOPER: ::std::os::raw::c_uint = 4;
pub const OCI_SESSION_PRELIM_AUTH: ::std::os::raw::c_uint = 8;
pub const OCI_CNT_OBJECTS: ::std::os::raw::c_uint = 1;
pub const OCI_CNT_ROWS: ::std::os::raw::c_uint = 2;
pub const OCI_CNT_DATABASES: ::std::os::raw::c_uint = 4;
pub const OCI_CNT_ALL: ::std::os::raw::c_uint = 7;
pub const OCI_ENT_STARTUP: ::std::os::raw::c_uint = 1;
pub const OCI_ENT_SHUTDOWN: ::std::os::raw::c_uint = 2;
pub const OCI_ENT_SHUTDOWN_ANY: ::std::os::raw::c_uint = 3;
pub const OCI_ENT_DROP_DATABASE: ::std::os::raw::c_uint = 4;
pub const OCI_ENT_DEREGISTER: ::std::os::raw::c_uint = 5;
pub const OCI_ENT_OBJECT_CHANGED: ::std::os::raw::c_uint = 6;
pub const OCI_ONT_INSERT: ::std::os::raw::c_uint = 2;
pub const OCI_ONT_UPDATE: ::std::os::raw::c_uint = 4;
pub const OCI_ONT_DELETE: ::std::os::raw::c_uint = 8;
pub const OCI_ONT_ALTER: ::std::os::raw::c_uint = 16;
pub const OCI_ONT_DROP: ::std::os::raw::c_uint = 32;
pub const OCI_ONT_GENERIC: ::std::os::raw::c_uint = 64;
pub const OCI_DB_SPM_START: ::std::os::raw::c_uint = 1;
pub const OCI_DB_SPM_MOUNT: ::std::os::raw::c_uint = 2;
pub const OCI_DB_SPM_OPEN: ::std::os::raw::c_uint = 4;
pub const OCI_DB_SPM_FULL: ::std::os::raw::c_uint = 7;
pub const OCI_DB_SPF_DEFAULT: ::std::os::raw::c_uint = 0;
pub const OCI_DB_SPF_FORCE: ::std::os::raw::c_uint = 1;
pub const OCI_DB_SPF_RESTRICT: ::std::os::raw::c_uint = 2;
pub const OCI_DB_SDM_SHUTDOWN: ::std::os::raw::c_uint = 1;
pub const OCI_DB_SDM_CLOSE: ::std::os::raw::c_uint = 2;
pub const OCI_DB_SDM_DISMOUNT: ::std::os::raw::c_uint = 4;
pub const OCI_DB_SDM_FULL: ::std::os::raw::c_uint = 7;
pub const OCI_DB_SDF_DEFAULT: ::std::os::raw::c_uint = 0;
pub const OCI_DB_SDF_TRANS: ::std::os::raw::c_uint = 1;
pub const OCI_DB_SDF_TRANS_LOCAL: ::std::os::raw::c_uint = 2;
pub const OCI_DB_SDF_IMMEDIATE: ::std::os::raw::c_uint = 3;
pub const OCI_DB_SDF_ABORT: ::std::os::raw::c_uint = 4;
pub const OCI_CSF_NONE: ::std::os::raw::c_uint = 0;
pub const OCI_CSF_DEFAULT: ::std::os::raw::c_uint = 1;
pub const OCI_CSF_NATIONAL: ::std::os::raw::c_uint = 2;
pub const OCI_SFM_DEFAULT: ::std::os::raw::c_uint = 0;
pub const OCI_SFM_SCROLLABLE: ::std::os::raw::c_uint = 8;
pub const OCI_SFD_ABSOLUTE: ::std::os::raw::c_uint = 32;
pub const OCI_SFD_RELATIVE: ::std::os::raw::c_uint = 64;
pub const OCI_BAM_EXTERNAL: ::std::os::raw::c_uint = 1;
pub const OCI_BAM_INTERNAL: ::std::os::raw::c_uint = 2;
pub const OCI_BDM_IN: ::std::os::raw::c_uint = 1;
pub const OCI_BDM_OUT: ::std::os::raw::c_uint = 2;
pub const OCI_BDM_IN_OUT: ::std::os::raw::c_uint = 3;
pub const OCI_CPF_NONE: ::std::os::raw::c_uint = 0;
pub const OCI_CPF_IS_IDENTITY: ::std::os::raw::c_uint = 1;
pub const OCI_CPF_IS_GEN_ALWAYS: ::std::os::raw::c_uint = 2;
pub const OCI_CPF_IS_GEN_BY_DEFAULT_ON_NULL: ::std::os::raw::c_uint = 4;
pub const OCI_NUM_UNSIGNED: ::std::os::raw::c_uint = 2;
pub const OCI_NUM_SHORT: ::std::os::raw::c_uint = 4;
pub const OCI_NUM_INT: ::std::os::raw::c_uint = 8;
pub const OCI_NUM_BIGINT: ::std::os::raw::c_uint = 16;
pub const OCI_NUM_FLOAT: ::std::os::raw::c_uint = 32;
pub const OCI_NUM_DOUBLE: ::std::os::raw::c_uint = 64;
pub const OCI_NUM_NUMBER: ::std::os::raw::c_uint = 128;
pub const OCI_NUM_USHORT: ::std::os::raw::c_uint = 6;
pub const OCI_NUM_UINT: ::std::os::raw::c_uint = 10;
pub const OCI_NUM_BIGUINT: ::std::os::raw::c_uint = 18;
pub const OCI_TIMESTAMP: ::std::os::raw::c_uint = 1;
pub const OCI_TIMESTAMP_TZ: ::std::os::raw::c_uint = 2;
pub const OCI_TIMESTAMP_LTZ: ::std::os::raw::c_uint = 3;
pub const OCI_INTERVAL_YM: ::std::os::raw::c_uint = 1;
pub const OCI_INTERVAL_DS: ::std::os::raw::c_uint = 2;
pub const OCI_BLONG: ::std::os::raw::c_uint = 1;
pub const OCI_CLONG: ::std::os::raw::c_uint = 2;
pub const OCI_BLOB: ::std::os::raw::c_uint = 1;
pub const OCI_CLOB: ::std::os::raw::c_uint = 2;
pub const OCI_NCLOB: ::std::os::raw::c_uint = 3;
pub const OCI_LOB_READONLY: ::std::os::raw::c_uint = 1;
pub const OCI_LOB_READWRITE: ::std::os::raw::c_uint = 2;
pub const OCI_BFILE: ::std::os::raw::c_uint = 1;
pub const OCI_CFILE: ::std::os::raw::c_uint = 2;
pub const OCI_SEEK_SET: ::std::os::raw::c_uint = 1;
pub const OCI_SEEK_END: ::std::os::raw::c_uint = 2;
pub const OCI_SEEK_CUR: ::std::os::raw::c_uint = 3;
pub const OCI_TIF_TABLE: ::std::os::raw::c_uint = 1;
pub const OCI_TIF_VIEW: ::std::os::raw::c_uint = 2;
pub const OCI_TIF_TYPE: ::std::os::raw::c_uint = 3;
pub const OCI_OBJ_PERSISTENT: ::std::os::raw::c_uint = 1;
pub const OCI_OBJ_TRANSIENT: ::std::os::raw::c_uint = 2;
pub const OCI_OBJ_VALUE: ::std::os::raw::c_uint = 3;
pub const OCI_COLL_VARRAY: ::std::os::raw::c_uint = 1;
pub const OCI_COLL_NESTED_TABLE: ::std::os::raw::c_uint = 2;
pub const OCI_COLL_INDEXED_TABLE: ::std::os::raw::c_uint = 3;
pub const OCI_POOL_CONNECTION: ::std::os::raw::c_uint = 1;
pub const OCI_POOL_SESSION: ::std::os::raw::c_uint = 2;
pub const OCI_AMS_READY: ::std::os::raw::c_uint = 1;
pub const OCI_AMS_WAITING: ::std::os::raw::c_uint = 2;
pub const OCI_AMS_PROCESSED: ::std::os::raw::c_uint = 3;
pub const OCI_AMS_EXPIRED: ::std::os::raw::c_uint = 4;
pub const OCI_ASD_BEFORE: ::std::os::raw::c_uint = 2;
pub const OCI_ASD_TOP: ::std::os::raw::c_uint = 3;
pub const OCI_AMV_IMMEDIATE: ::std::os::raw::c_uint = 1;
pub const OCI_AMV_ON_COMMIT: ::std::os::raw::c_uint = 2;
pub const OCI_ADM_BROWSE: ::std::os::raw::c_uint = 1;
pub const OCI_ADM_LOCKED: ::std::os::raw::c_uint = 2;
pub const OCI_ADM_REMOVE: ::std::os::raw::c_uint = 3;
pub const OCI_ADM_REMOVE_NODATA: ::std::os::raw::c_uint = 4;
pub const OCI_ADN_FIRST_MSG: ::std::os::raw::c_uint = 1;
pub const OCI_ADN_NEXT_TRANSACTION: ::std::os::raw::c_uint = 2;
pub const OCI_ADN_NEXT_MSG: ::std::os::raw::c_uint = 3;
pub const OCI_APM_BUFFERED: ::std::os::raw::c_uint = 1;
pub const OCI_APM_PERSISTENT: ::std::os::raw::c_uint = 2;
pub const OCI_APM_ALL: ::std::os::raw::c_uint = 3;
pub const OCI_AGM_NONE: ::std::os::raw::c_uint = 0;
pub const OCI_AGM_TRANSACTIONNAL: ::std::os::raw::c_uint = 1;
pub const OCI_AQT_NORMAL: ::std::os::raw::c_uint = 0;
pub const OCI_AQT_EXCEPTION: ::std::os::raw::c_uint = 1;
pub const OCI_AQT_NON_PERSISTENT: ::std::os::raw::c_uint = 2;
pub const OCI_DPR_COMPLETE: ::std::os::raw::c_uint = 1;
pub const OCI_DPR_ERROR: ::std::os::raw::c_uint = 2;
pub const OCI_DPR_FULL: ::std::os::raw::c_uint = 3;
pub const OCI_DPR_PARTIAL: ::std::os::raw::c_uint = 4;
pub const OCI_DPR_EMPTY: ::std::os::raw::c_uint = 5;
pub const OCI_DCM_DEFAULT: ::std::os::raw::c_uint = 1;
pub const OCI_DCM_FORCE: ::std::os::raw::c_uint = 2;
pub const OCI_SIZE_TRACE_ID: ::std::os::raw::c_uint = 64;
pub const OCI_SIZE_TRACE_MODULE: ::std::os::raw::c_uint = 48;
pub const OCI_SIZE_TRACE_ACTION: ::std::os::raw::c_uint = 32;
pub const OCI_SIZE_TRACE_INFO: ::std::os::raw::c_uint = 64;
pub const OCI_TRC_IDENTITY: ::std::os::raw::c_uint = 1;
pub const OCI_TRC_MODULE: ::std::os::raw::c_uint = 2;
pub const OCI_TRC_ACTION: ::std::os::raw::c_uint = 3;
pub const OCI_TRC_DETAIL: ::std::os::raw::c_uint = 4;
pub const OCI_HET_DOWN: ::std::os::raw::c_uint = 0;
pub const OCI_HET_UP: ::std::os::raw::c_uint = 1;
pub const OCI_HES_INSTANCE: ::std::os::raw::c_uint = 0;
pub const OCI_HES_DATABASE: ::std::os::raw::c_uint = 1;
pub const OCI_HES_NODE: ::std::os::raw::c_uint = 2;
pub const OCI_HES_SERVICE: ::std::os::raw::c_uint = 3;
pub const OCI_HES_SERVICE_MEMBER: ::std::os::raw::c_uint = 4;
pub const OCI_HES_ASM_INSTANCE: ::std::os::raw::c_uint = 5;
pub const OCI_HES_PRECONNECT: ::std::os::raw::c_uint = 6;
pub const OCI_FOT_NONE: ::std::os::raw::c_uint = 1;
pub const OCI_FOT_SESSION: ::std::os::raw::c_uint = 2;
pub const OCI_FOT_SELECT: ::std::os::raw::c_uint = 4;
pub const OCI_FOE_END: ::std::os::raw::c_uint = 1;
pub const OCI_FOE_ABORT: ::std::os::raw::c_uint = 2;
pub const OCI_FOE_REAUTH: ::std::os::raw::c_uint = 4;
pub const OCI_FOE_BEGIN: ::std::os::raw::c_uint = 8;
pub const OCI_FOE_ERROR: ::std::os::raw::c_uint = 16;
pub const OCI_FOC_OK: ::std::os::raw::c_uint = 0;
pub const OCI_FOC_RETRY: ::std::os::raw::c_uint = 25410;
pub const OCI_HASH_STRING: ::std::os::raw::c_uint = 1;
pub const OCI_HASH_INTEGER: ::std::os::raw::c_uint = 2;
pub const OCI_HASH_POINTER: ::std::os::raw::c_uint = 3;
pub const OCI_TRS_NEW: ::std::os::raw::c_uint = 1;
pub const OCI_TRS_READONLY: ::std::os::raw::c_uint = 256;
pub const OCI_TRS_READWRITE: ::std::os::raw::c_uint = 512;
pub const OCI_TRS_SERIALIZABLE: ::std::os::raw::c_uint = 1024;
pub const OCI_TRS_LOOSE: ::std::os::raw::c_uint = 65536;
pub const OCI_TRS_TIGHT: ::std::os::raw::c_uint = 131072;
pub const OCI_FMT_DATE: ::std::os::raw::c_uint = 1;
pub const OCI_FMT_TIMESTAMP: ::std::os::raw::c_uint = 2;
pub const OCI_FMT_NUMERIC: ::std::os::raw::c_uint = 3;
pub const OCI_FMT_BINARY_DOUBLE: ::std::os::raw::c_uint = 4;
pub const OCI_FMT_BINARY_FLOAT: ::std::os::raw::c_uint = 5;
pub const OCI_SFC_CREATE_TABLE: ::std::os::raw::c_uint = 1;
pub const OCI_SFC_SET_ROLE: ::std::os::raw::c_uint = 2;
pub const OCI_SFC_INSERT: ::std::os::raw::c_uint = 3;
pub const OCI_SFC_SELECT: ::std::os::raw::c_uint = 4;
pub const OCI_SFC_UPDATE: ::std::os::raw::c_uint = 5;
pub const OCI_SFC_DROP_ROLE: ::std::os::raw::c_uint = 6;
pub const OCI_SFC_DROP_VIEW: ::std::os::raw::c_uint = 7;
pub const OCI_SFC_DROP_TABLE: ::std::os::raw::c_uint = 8;
pub const OCI_SFC_DELETE: ::std::os::raw::c_uint = 9;
pub const OCI_SFC_CREATE_VIEW: ::std::os::raw::c_uint = 10;
pub const OCI_SFC_DROP_USER: ::std::os::raw::c_uint = 11;
pub const OCI_SFC_CREATE_ROLE: ::std::os::raw::c_uint = 12;
pub const OCI_SFC_CREATE_SEQUENCE: ::std::os::raw::c_uint = 13;
pub const OCI_SFC_ALTER_SEQUENCE: ::std::os::raw::c_uint = 14;
pub const OCI_SFC_DROP_SEQUENCE: ::std::os::raw::c_uint = 16;
pub const OCI_SFC_CREATE_SCHEMA: ::std::os::raw::c_uint = 17;
pub const OCI_SFC_CREATE_CLUSTER: ::std::os::raw::c_uint = 18;
pub const OCI_SFC_CREATE_USER: ::std::os::raw::c_uint = 19;
pub const OCI_SFC_CREATE_INDEX: ::std::os::raw::c_uint = 20;
pub const OCI_SFC_DROP_INDEX: ::std::os::raw::c_uint = 21;
pub const OCI_SFC_DROP_CLUSTER: ::std::os::raw::c_uint = 22;
pub const OCI_SFC_VALIDATE_INDEX: ::std::os::raw::c_uint = 23;
pub const OCI_SFC_CREATE_PROCEDURE: ::std::os::raw::c_uint = 24;
pub const OCI_SFC_ALTER_PROCEDURE: ::std::os::raw::c_uint = 25;
pub const OCI_SFC_ALTER_TABLE: ::std::os::raw::c_uint = 26;
pub const OCI_SFC_EXPLAIN: ::std::os::raw::c_uint = 27;
pub const OCI_SFC_GRANT: ::std::os::raw::c_uint = 28;
pub const OCI_SFC_REVOKE: ::std::os::raw::c_uint = 29;
pub const OCI_SFC_CREATE_SYNONYM: ::std::os::raw::c_uint = 30;
pub const OCI_SFC_DROP_SYNONYM: ::std::os::raw::c_uint = 31;
pub const OCI_SFC_ALTER_SYSTEM_SWITCHLOG: ::std::os::raw::c_uint = 32;
pub const OCI_SFC_SET_TRANSACTION: ::std::os::raw::c_uint = 33;
pub const OCI_SFC_PLSQL_EXECUTE: ::std::os::raw::c_uint = 34;
pub const OCI_SFC_LOCK: ::std::os::raw::c_uint = 35;
pub const OCI_SFC_NOOP: ::std::os::raw::c_uint = 36;
pub const OCI_SFC_RENAME: ::std::os::raw::c_uint = 37;
pub const OCI_SFC_COMMENT: ::std::os::raw::c_uint = 38;
pub const OCI_SFC_AUDIT: ::std::os::raw::c_uint = 39;
pub const OCI_SFC_NO_AUDIT: ::std::os::raw::c_uint = 40;
pub const OCI_SFC_ALTER_INDEX: ::std::os::raw::c_uint = 41;
pub const OCI_SFC_CREATE_EXTERNAL_DATABASE: ::std::os::raw::c_uint = 42;
pub const OCI_SFC_DROP_EXTERNALDATABASE: ::std::os::raw::c_uint = 43;
pub const OCI_SFC_CREATE_DATABASE: ::std::os::raw::c_uint = 44;
pub const OCI_SFC_ALTER_DATABASE: ::std::os::raw::c_uint = 45;
pub const OCI_SFC_CREATE_ROLLBACK_SEGMENT: ::std::os::raw::c_uint = 46;
pub const OCI_SFC_ALTER_ROLLBACK_SEGMENT: ::std::os::raw::c_uint = 47;
pub const OCI_SFC_DROP_ROLLBACK_SEGMENT: ::std::os::raw::c_uint = 48;
pub const OCI_SFC_CREATE_TABLESPACE: ::std::os::raw::c_uint = 49;
pub const OCI_SFC_ALTER_TABLESPACE: ::std::os::raw::c_uint = 50;
pub const OCI_SFC_DROP_TABLESPACE: ::std::os::raw::c_uint = 51;
pub const OCI_SFC_ALTER_SESSION: ::std::os::raw::c_uint = 52;
pub const OCI_SFC_ALTER_USER: ::std::os::raw::c_uint = 53;
pub const OCI_SFC_COMMIT_WORK: ::std::os::raw::c_uint = 54;
pub const OCI_SFC_ROLLBACK: ::std::os::raw::c_uint = 55;
pub const OCI_SFC_SAVEPOINT: ::std::os::raw::c_uint = 56;
pub const OCI_SFC_CREATE_CONTROL_FILE: ::std::os::raw::c_uint = 57;
pub const OCI_SFC_ALTER_TRACING: ::std::os::raw::c_uint = 58;
pub const OCI_SFC_CREATE_TRIGGER: ::std::os::raw::c_uint = 59;
pub const OCI_SFC_ALTER_TRIGGER: ::std::os::raw::c_uint = 60;
pub const OCI_SFC_DROP_TRIGGER: ::std::os::raw::c_uint = 61;
pub const OCI_SFC_ANALYZE_TABLE: ::std::os::raw::c_uint = 62;
pub const OCI_SFC_ANALYZE_INDEX: ::std::os::raw::c_uint = 63;
pub const OCI_SFC_ANALYZE_CLUSTER: ::std::os::raw::c_uint = 64;
pub const OCI_SFC_CREATE_PROFILE: ::std::os::raw::c_uint = 65;
pub const OCI_SFC_DROP_PROFILE: ::std::os::raw::c_uint = 66;
pub const OCI_SFC_ALTER_PROFILE: ::std::os::raw::c_uint = 67;
pub const OCI_SFC_DROP_PROCEDURE: ::std::os::raw::c_uint = 68;
pub const OCI_SFC_ALTER_RESOURCE_COST: ::std::os::raw::c_uint = 70;
pub const OCI_SFC_CREATE_SNAPSHOT_LOG: ::std::os::raw::c_uint = 71;
pub const OCI_SFC_ALTER_SNAPSHOT_LOG: ::std::os::raw::c_uint = 72;
pub const OCI_SFC_DROP_SNAPSHOT_LOG: ::std::os::raw::c_uint = 73;
pub const OCI_SFC_DROP_SUMMARY: ::std::os::raw::c_uint = 73;
pub const OCI_SFC_CREATE_SNAPSHOT: ::std::os::raw::c_uint = 74;
pub const OCI_SFC_ALTER_SNAPSHOT: ::std::os::raw::c_uint = 75;
pub const OCI_SFC_DROP_SNAPSHOT: ::std::os::raw::c_uint = 76;
pub const OCI_SFC_CREATE_TYPE: ::std::os::raw::c_uint = 77;
pub const OCI_SFC_DROP_TYPE: ::std::os::raw::c_uint = 78;
pub const OCI_SFC_ALTER_ROLE: ::std::os::raw::c_uint = 79;
pub const OCI_SFC_ALTER_TYPE: ::std::os::raw::c_uint = 80;
pub const OCI_SFC_CREATE_TYPE_BODY: ::std::os::raw::c_uint = 81;
pub const OCI_SFC_ALTER_TYPE_BODY: ::std::os::raw::c_uint = 82;
pub const OCI_SFC_DROP_TYPE_BODY: ::std::os::raw::c_uint = 83;
pub const OCI_SFC_DROP_LIBRARY: ::std::os::raw::c_uint = 84;
pub const OCI_SFC_TRUNCATE_TABLE: ::std::os::raw::c_uint = 85;
pub const OCI_SFC_TRUNCATE_CLUSTER: ::std::os::raw::c_uint = 86;
pub const OCI_SFC_CREATE_BITMAPFILE: ::std::os::raw::c_uint = 87;
pub const OCI_SFC_ALTER_VIEW: ::std::os::raw::c_uint = 88;
pub const OCI_SFC_DROP_BITMAPFILE: ::std::os::raw::c_uint = 89;
pub const OCI_SFC_SET_CONSTRAINTS: ::std::os::raw::c_uint = 90;
pub const OCI_SFC_CREATE_FUNCTION: ::std::os::raw::c_uint = 91;
pub const OCI_SFC_ALTER_FUNCTION: ::std::os::raw::c_uint = 92;
pub const OCI_SFC_DROP_FUNCTION: ::std::os::raw::c_uint = 93;
pub const OCI_SFC_CREATE_PACKAGE: ::std::os::raw::c_uint = 94;
pub const OCI_SFC_ALTER_PACKAGE: ::std::os::raw::c_uint = 95;
pub const OCI_SFC_DROP_PACKAGE: ::std::os::raw::c_uint = 96;
pub const OCI_SFC_CREATE_PACKAGE_BODY: ::std::os::raw::c_uint = 97;
pub const OCI_SFC_ALTER_PACKAGE_BODY: ::std::os::raw::c_uint = 98;
pub const OCI_SFC_DROP_PACKAGE_BODY: ::std::os::raw::c_uint = 99;
pub const OCI_SFC_CREATE_DIRECTORY: ::std::os::raw::c_uint = 157;
pub const OCI_SFC_DROP_DIRECTORY: ::std::os::raw::c_uint = 158;
pub const OCI_SFC_CREATE_LIBRARY: ::std::os::raw::c_uint = 159;
pub const OCI_SFC_CREATE_JAVA: ::std::os::raw::c_uint = 160;
pub const OCI_SFC_ALTER_JAVA: ::std::os::raw::c_uint = 161;
pub const OCI_SFC_DROP_JAVA: ::std::os::raw::c_uint = 162;
pub const OCI_SFC_CREATE_OPERATOR: ::std::os::raw::c_uint = 163;
pub const OCI_SFC_CREATE_INDEXTYPE: ::std::os::raw::c_uint = 164;
pub const OCI_SFC_DROP_INDEXTYPE: ::std::os::raw::c_uint = 165;
pub const OCI_SFC_ALTER_INDEXTYPE: ::std::os::raw::c_uint = 166;
pub const OCI_SFC_DROP_OPERATOR: ::std::os::raw::c_uint = 167;
pub const OCI_SFC_ASSOCIATE_STATISTICS: ::std::os::raw::c_uint = 168;
pub const OCI_SFC_DISASSOCIATE_STATISTICS: ::std::os::raw::c_uint = 169;
pub const OCI_SFC_CALL_METHOD: ::std::os::raw::c_uint = 170;
pub const OCI_SFC_CREATE_SUMMARY: ::std::os::raw::c_uint = 171;
pub const OCI_SFC_ALTER_SUMMARY: ::std::os::raw::c_uint = 172;
pub const OCI_SFC_CREATE_DIMENSION: ::std::os::raw::c_uint = 174;
pub const OCI_SFC_ALTER_DIMENSION: ::std::os::raw::c_uint = 175;
pub const OCI_SFC_DROP_DIMENSION: ::std::os::raw::c_uint = 176;
pub const OCI_SFC_CREATE_CONTEXT: ::std::os::raw::c_uint = 177;
pub const OCI_SFC_DROP_CONTEXT: ::std::os::raw::c_uint = 178;
pub const OCI_SFC_ALTER_OUTLINE: ::std::os::raw::c_uint = 179;
pub const OCI_SFC_CREATE_OUTLINE: ::std::os::raw::c_uint = 180;
pub const OCI_SFC_DROP_OUTLINE: ::std::os::raw::c_uint = 181;
pub const OCI_SFC_UPDATE_INDEXES: ::std::os::raw::c_uint = 182;
pub const OCI_SFC_ALTER_OPERATOR: ::std::os::raw::c_uint = 183;
pub const OCI_SIZE_FORMAT: ::std::os::raw::c_uint = 64;
pub const OCI_SIZE_BUFFER: ::std::os::raw::c_uint = 512;
pub const OCI_SIZE_DATE: ::std::os::raw::c_uint = 45;
pub const OCI_SIZE_TIMESTAMP: ::std::os::raw::c_uint = 54;
pub const OCI_SIZE_FORMAT_TODATE: ::std::os::raw::c_uint = 14;
pub const OCI_SIZE_NULL: ::std::os::raw::c_uint = 4;
pub const OCI_SIZE_PRECISION: ::std::os::raw::c_uint = 10;
pub const OCI_SIZE_ROWID: ::std::os::raw::c_uint = 23;
pub const OCI_SIZE_DIRECTORY: ::std::os::raw::c_uint = 30;
pub const OCI_SIZE_FILENAME: ::std::os::raw::c_uint = 255;
pub const OCI_SIZE_FORMAT_NUMS: ::std::os::raw::c_uint = 40;
pub const OCI_SIZE_FORMAT_NUML: ::std::os::raw::c_uint = 65;
pub const OCI_SIZE_OBJ_NAME: ::std::os::raw::c_uint = 32;
pub const OCI_HASH_DEFAULT_SIZE: ::std::os::raw::c_uint = 256;
pub const OCI_STRING_DEFAULT_PREC: ::std::os::raw::c_uint = 3;
pub const OCI_STRING_TRUE_SIZE: ::std::os::raw::c_uint = 4;
pub const OCI_STRING_FALSE_SIZE: ::std::os::raw::c_uint = 5;
pub const OCI_CHAR_SLASH: u8 = b'/';
pub const VAR_OCILIB_WORKAROUND_UTF16_COLUMN_NAME: &'static [u8; 36usize] =
    b"OCILIB_WORKAROUND_UTF16_COLUMN_NAME\x00";
pub const OCI_ERR_API: ::std::os::raw::c_uint = 1;
pub const OCI_ERR_NOT_SUPPORTED: ::std::os::raw::c_uint = 8;
pub const OCI_SCHEMA_TABLE: ::std::os::raw::c_uint = 1;
pub const OCI_SCHEMA_VIEW: ::std::os::raw::c_uint = 2;
pub const OCI_SCHEMA_TYPE: ::std::os::raw::c_uint = 3;
pub const OCI_8: ::std::os::raw::c_uint = 810;
pub const OCI_9: ::std::os::raw::c_uint = 900;
pub const OCI_10: ::std::os::raw::c_uint = 1010;
pub const OCI_11: ::std::os::raw::c_uint = 1110;
pub const OCI_CHAR_UNICODE: ::std::os::raw::c_uint = 2;
pub const OCI_CSF_CHARSET: ::std::os::raw::c_uint = 1;
pub const OCI_SIZE_TRACE_INF0: ::std::os::raw::c_uint = 64;
pub type wchar_t = ::std::os::raw::c_int;
pub const P_ALL: _bindgen_ty_1 = _bindgen_ty_1::P_ALL;
pub const P_PID: _bindgen_ty_1 = _bindgen_ty_1::P_PID;
pub const P_PGID: _bindgen_ty_1 = _bindgen_ty_1::P_PGID;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_1 { P_ALL = 0, P_PID = 1, P_PGID = 2, }
pub use self::_bindgen_ty_1 as idtype_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_2 {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_2() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_2>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_2>() , 4usize);
}
impl Clone for _bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
pub type div_t = _bindgen_ty_2;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_3 {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__bindgen_ty_3() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_3>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_3>() , 8usize);
}
impl Clone for _bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
pub type ldiv_t = _bindgen_ty_3;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_4 {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__bindgen_ty_4() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_4>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_4>() , 8usize);
}
impl Clone for _bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
pub type lldiv_t = _bindgen_ty_4;
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtol(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(__nptr: *const ::std::os::raw::c_char,
                  __endptr: *mut *mut ::std::os::raw::c_char,
                  __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(__nptr: *const ::std::os::raw::c_char,
                   __endptr: *mut *mut ::std::os::raw::c_char,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(__nptr: *const ::std::os::raw::c_char,
                    __endptr: *mut *mut ::std::os::raw::c_char,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_char;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_5 {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_5() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_5>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_5>() , 4usize);
}
impl Clone for _bindgen_ty_5 {
    fn clone(&self) -> Self { *self }
}
pub type __fsid_t = _bindgen_ty_5;
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type time_t = __time_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulong;
pub type register_t = ::std::os::raw::c_long;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_6 {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_6() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_6>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_6>() , 8usize);
}
impl Clone for _bindgen_ty_6 {
    fn clone(&self) -> Self { *self }
}
pub type __sigset_t = _bindgen_ty_6;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(::std::mem::size_of::<timespec>() , 16usize);
    assert_eq!(::std::mem::align_of::<timespec>() , 8usize);
}
impl Clone for timespec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(::std::mem::size_of::<timeval>() , 16usize);
    assert_eq!(::std::mem::align_of::<timeval>() , 8usize);
}
impl Clone for timeval {
    fn clone(&self) -> Self { *self }
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_7 {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_7() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_7>() , 128usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_7>() , 8usize);
}
impl Clone for _bindgen_ty_7 {
    fn clone(&self) -> Self { *self }
}
pub type fd_set = _bindgen_ty_7;
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                  __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                  __timeout: *mut timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(__nfds: ::std::os::raw::c_int, __readfds: *mut fd_set,
                   __writefds: *mut fd_set, __exceptfds: *mut fd_set,
                   __timeout: *const timespec, __sigmask: *const __sigset_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: ::std::os::raw::c_ulonglong)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: ::std::os::raw::c_uint,
                           __minor: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ulonglong;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(::std::mem::size_of::<pthread_attr_t>() , 56usize);
    assert_eq!(::std::mem::align_of::<pthread_attr_t>() , 8usize);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(::std::mem::size_of::<__pthread_internal_list>() , 16usize);
    assert_eq!(::std::mem::align_of::<__pthread_internal_list>() , 8usize);
}
impl Clone for __pthread_internal_list {
    fn clone(&self) -> Self { *self }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
pub union _bindgen_ty_8 {
    pub __data: _bindgen_ty_8___pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_8___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout__bindgen_ty_8___pthread_mutex_s() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_8___pthread_mutex_s>() ,
               40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_8___pthread_mutex_s>() ,
               8usize);
}
impl Clone for _bindgen_ty_8___pthread_mutex_s {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_8() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_8>() , 40usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_8>() , 8usize);
}
pub type pthread_mutex_t = _bindgen_ty_8;
#[repr(C)]
#[derive(Copy)]
pub union _bindgen_ty_9 {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_9() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_9>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_9>() , 4usize);
}
impl Clone for _bindgen_ty_9 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_mutexattr_t = _bindgen_ty_9;
#[repr(C)]
pub union _bindgen_ty_10 {
    pub __data: _bindgen_ty_10__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_10__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__bindgen_ty_10__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_10__bindgen_ty_1>() ,
               48usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_10__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _bindgen_ty_10__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_10() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_10>() , 48usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_10>() , 8usize);
}
pub type pthread_cond_t = _bindgen_ty_10;
#[repr(C)]
#[derive(Copy)]
pub union _bindgen_ty_11 {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_11() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_11>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_11>() , 4usize);
}
impl Clone for _bindgen_ty_11 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_condattr_t = _bindgen_ty_11;
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
pub union _bindgen_ty_12 {
    pub __data: _bindgen_ty_12__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _bindgen_ty_12__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_char,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout__bindgen_ty_12__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_12__bindgen_ty_1>() ,
               56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_12__bindgen_ty_1>() ,
               8usize);
}
impl Clone for _bindgen_ty_12__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_12() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_12>() , 56usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_12>() , 8usize);
}
pub type pthread_rwlock_t = _bindgen_ty_12;
#[repr(C)]
#[derive(Copy)]
pub union _bindgen_ty_13 {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__bindgen_ty_13() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_13>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_13>() , 8usize);
}
impl Clone for _bindgen_ty_13 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_rwlockattr_t = _bindgen_ty_13;
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy)]
pub union _bindgen_ty_14 {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__bindgen_ty_14() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_14>() , 32usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_14>() , 8usize);
}
impl Clone for _bindgen_ty_14 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_barrier_t = _bindgen_ty_14;
#[repr(C)]
#[derive(Copy)]
pub union _bindgen_ty_15 {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__bindgen_ty_15() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_15>() , 4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_15>() , 4usize);
}
impl Clone for _bindgen_ty_15 {
    fn clone(&self) -> Self { *self }
}
pub type pthread_barrierattr_t = _bindgen_ty_15;
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(__seed: ::std::os::raw::c_uint,
                     __statebuf: *mut ::std::os::raw::c_char,
                     __statelen: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(::std::mem::size_of::<random_data>() , 48usize);
    assert_eq!(::std::mem::align_of::<random_data>() , 8usize);
}
impl Clone for random_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: ::std::os::raw::c_uint, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(__seed: ::std::os::raw::c_uint,
                       __statebuf: *mut ::std::os::raw::c_char,
                       __statelen: usize, __buf: *mut random_data)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(__statebuf: *mut ::std::os::raw::c_char,
                      __buf: *mut random_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort)
     -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(::std::mem::size_of::<drand48_data>() , 24usize);
    assert_eq!(::std::mem::align_of::<drand48_data>() , 8usize);
}
impl Clone for drand48_data {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data, __result: *mut f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(__buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(__xsubi: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data,
                     __result: *mut ::std::os::raw::c_long)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: ::std::os::raw::c_long,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(__seed16v: *mut ::std::os::raw::c_ushort,
                    __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(__param: *mut ::std::os::raw::c_ushort,
                     __buffer: *mut drand48_data) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut ::std::os::raw::c_void, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn cfree(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(__memptr: *mut *mut ::std::os::raw::c_void,
                          __alignment: usize, __size: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(__func:
                             ::std::option::Option<unsafe extern "C" fn()>)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(__func:
                       ::std::option::Option<unsafe extern "C" fn(__status:
                                                                      ::std::os::raw::c_int,
                                                                  __arg:
                                                                      *mut ::std::os::raw::c_void)>,
                   __arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(__name: *const ::std::os::raw::c_char,
                  __value: *const ::std::os::raw::c_char,
                  __replace: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(__template: *mut ::std::os::raw::c_char,
                    __suffixlen: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(__name: *const ::std::os::raw::c_char,
                    __resolved: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t =
    ::std::option::Option<unsafe extern "C" fn(arg1:
                                                   *const ::std::os::raw::c_void,
                                               arg2:
                                                   *const ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn bsearch(__key: *const ::std::os::raw::c_void,
                   __base: *const ::std::os::raw::c_void, __nmemb: usize,
                   __size: usize, __compar: __compar_fn_t)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(__base: *mut ::std::os::raw::c_void, __nmemb: usize,
                 __size: usize, __compar: __compar_fn_t);
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int)
     -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long,
                __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: ::std::os::raw::c_longlong,
                 __denom: ::std::os::raw::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __decpt: *mut ::std::os::raw::c_int,
                __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __decpt: *mut ::std::os::raw::c_int,
                 __sign: *mut ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(__value: f64, __ndigit: ::std::os::raw::c_int,
                 __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                  __decpt: *mut ::std::os::raw::c_int,
                  __sign: *mut ::std::os::raw::c_int,
                  __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(__value: f64, __ndigit: ::std::os::raw::c_int,
                   __decpt: *mut ::std::os::raw::c_int,
                   __sign: *mut ::std::os::raw::c_int,
                   __buf: *mut ::std::os::raw::c_char, __len: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                  __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t,
                    __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(__optionp: *mut *mut ::std::os::raw::c_char,
                     __tokens: *const *const ::std::os::raw::c_char,
                     __valuep: *mut *mut ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_char,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(::std::mem::size_of::<_IO_FILE>() , 216usize);
    assert_eq!(::std::mem::align_of::<_IO_FILE>() , 8usize);
}
impl Clone for _IO_FILE {
    fn clone(&self) -> Self { *self }
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_16 {
    pub __count: ::std::os::raw::c_int,
    pub __value: _bindgen_ty_16__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy)]
pub union _bindgen_ty_16__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout__bindgen_ty_16__bindgen_ty_1() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_16__bindgen_ty_1>() ,
               4usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_16__bindgen_ty_1>() ,
               4usize);
}
impl Clone for _bindgen_ty_16__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout__bindgen_ty_16() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_16>() , 8usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_16>() , 4usize);
}
impl Clone for _bindgen_ty_16 {
    fn clone(&self) -> Self { *self }
}
pub type __mbstate_t = _bindgen_ty_16;
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_17 {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__bindgen_ty_17() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_17>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_17>() , 8usize);
}
impl Clone for _bindgen_ty_17 {
    fn clone(&self) -> Self { *self }
}
pub type _G_fpos_t = _bindgen_ty_17;
#[repr(C)]
#[derive(Copy)]
pub struct _bindgen_ty_18 {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__bindgen_ty_18() {
    assert_eq!(::std::mem::size_of::<_bindgen_ty_18>() , 16usize);
    assert_eq!(::std::mem::align_of::<_bindgen_ty_18>() , 8usize);
}
impl Clone for _bindgen_ty_18 {
    fn clone(&self) -> Self { *self }
}
pub type _G_fpos64_t = _bindgen_ty_18;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t([u8; 0]);
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(::std::mem::size_of::<_IO_marker>() , 24usize);
    assert_eq!(::std::mem::align_of::<_IO_marker>() , 8usize);
}
impl Clone for _IO_marker {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum __codecvt_result {
    __codecvt_ok = 0,
    __codecvt_partial = 1,
    __codecvt_error = 2,
    __codecvt_noconv = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus([u8; 0]);
extern "C" {
    #[link_name = "_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *mut ::std::os::raw::c_char,
                                               __nbytes: usize) -> __ssize_t>;
pub type __io_write_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __buf:
                                                   *const ::std::os::raw::c_char,
                                               __n: usize) -> __ssize_t>;
pub type __io_seek_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void,
                                               __pos: *mut __off64_t,
                                               __w: ::std::os::raw::c_int)
                              -> ::std::os::raw::c_int>;
pub type __io_close_fn =
    ::std::option::Option<unsafe extern "C" fn(__cookie:
                                                   *mut ::std::os::raw::c_void)
                              -> ::std::os::raw::c_int>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(arg1: *mut _IO_FILE,
                       arg2: *const ::std::os::raw::c_char,
                       arg3: *mut __va_list_tag,
                       arg4: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(arg1: *mut _IO_FILE,
                        arg2: *const ::std::os::raw::c_char,
                        arg3: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int,
                    arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void,
                     arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int,
                       arg4: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t,
                       arg3: ::std::os::raw::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(__old: *const ::std::os::raw::c_char,
                  __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(__oldfd: ::std::os::raw::c_int,
                    __old: *const ::std::os::raw::c_char,
                    __newfd: ::std::os::raw::c_int,
                    __new: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(__dir: *const ::std::os::raw::c_char,
                   __pfx: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(__filename: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(__filename: *const ::std::os::raw::c_char,
                   __modes: *const ::std::os::raw::c_char,
                   __stream: *mut FILE) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int,
                  __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(__s: *mut ::std::os::raw::c_void, __len: usize,
                    __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(__bufloc: *mut *mut ::std::os::raw::c_char,
                          __sizeloc: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                   __modes: ::std::os::raw::c_int, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char,
                     __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(__s: *mut ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(__s: *mut ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                    __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(__s: *mut ::std::os::raw::c_char, __maxlen: usize,
                     __format: *const ::std::os::raw::c_char,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(__fd: ::std::os::raw::c_int,
                    __fmt: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(__fd: ::std::os::raw::c_int,
                   __fmt: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(__s: *const ::std::os::raw::c_char,
                  __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fscanf"]
    pub fn fscanf1(__stream: *mut FILE,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_sscanf"]
    pub fn sscanf1(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(__format: *const ::std::os::raw::c_char,
                  __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(__s: *const ::std::os::raw::c_char,
                   __format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfscanf"]
    pub fn vfscanf1(__s: *mut FILE, __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vscanf"]
    pub fn vscanf1(__format: *const ::std::os::raw::c_char,
                   __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vsscanf"]
    pub fn vsscanf1(__s: *const ::std::os::raw::c_char,
                    __format: *const ::std::os::raw::c_char,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(__s: *mut ::std::os::raw::c_char, __n: ::std::os::raw::c_int,
                 __stream: *mut FILE) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                      __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                      __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(__lineptr: *mut *mut ::std::os::raw::c_char,
                    __n: *mut usize, __delimiter: ::std::os::raw::c_int,
                    __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn getline(__lineptr: *mut *mut ::std::os::raw::c_char,
                   __n: *mut usize, __stream: *mut FILE) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                 __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite(__ptr: *const ::std::os::raw::c_void, __size: usize,
                  __n: usize, __s: *mut FILE) -> usize;
}
extern "C" {
    pub fn fread_unlocked(__ptr: *mut ::std::os::raw::c_void, __size: usize,
                          __n: usize, __stream: *mut FILE) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(__ptr: *const ::std::os::raw::c_void,
                           __size: usize, __n: usize, __stream: *mut FILE)
     -> usize;
}
extern "C" {
    pub fn fseek(__stream: *mut FILE, __off: ::std::os::raw::c_long,
                 __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(__stream: *mut FILE, __off: __off_t,
                  __whence: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(__command: *const ::std::os::raw::c_char,
                 __modes: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub const _ISupper: _bindgen_ty_19 = _bindgen_ty_19::_ISupper;
pub const _ISlower: _bindgen_ty_19 = _bindgen_ty_19::_ISlower;
pub const _ISalpha: _bindgen_ty_19 = _bindgen_ty_19::_ISalpha;
pub const _ISdigit: _bindgen_ty_19 = _bindgen_ty_19::_ISdigit;
pub const _ISxdigit: _bindgen_ty_19 = _bindgen_ty_19::_ISxdigit;
pub const _ISspace: _bindgen_ty_19 = _bindgen_ty_19::_ISspace;
pub const _ISprint: _bindgen_ty_19 = _bindgen_ty_19::_ISprint;
pub const _ISgraph: _bindgen_ty_19 = _bindgen_ty_19::_ISgraph;
pub const _ISblank: _bindgen_ty_19 = _bindgen_ty_19::_ISblank;
pub const _IScntrl: _bindgen_ty_19 = _bindgen_ty_19::_IScntrl;
pub const _ISpunct: _bindgen_ty_19 = _bindgen_ty_19::_ISpunct;
pub const _ISalnum: _bindgen_ty_19 = _bindgen_ty_19::_ISalnum;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_19 {
    _ISupper = 256,
    _ISlower = 512,
    _ISalpha = 1024,
    _ISdigit = 2048,
    _ISxdigit = 4096,
    _ISspace = 8192,
    _ISprint = 16384,
    _ISgraph = 32768,
    _ISblank = 1,
    _IScntrl = 2,
    _ISpunct = 4,
    _ISalnum = 8,
}
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_struct___locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct___locale_data([u8; 0]);
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(::std::mem::size_of::<__locale_struct>() , 232usize);
    assert_eq!(::std::mem::align_of::<__locale_struct>() , 8usize);
}
impl Clone for __locale_struct {
    fn clone(&self) -> Self { *self }
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
pub type wint_t = ::std::os::raw::c_uint;
pub type wctype_t = ::std::os::raw::c_ulong;
pub const __ISwupper: _bindgen_ty_20 = _bindgen_ty_20::__ISwupper;
pub const __ISwlower: _bindgen_ty_20 = _bindgen_ty_20::__ISwlower;
pub const __ISwalpha: _bindgen_ty_20 = _bindgen_ty_20::__ISwalpha;
pub const __ISwdigit: _bindgen_ty_20 = _bindgen_ty_20::__ISwdigit;
pub const __ISwxdigit: _bindgen_ty_20 = _bindgen_ty_20::__ISwxdigit;
pub const __ISwspace: _bindgen_ty_20 = _bindgen_ty_20::__ISwspace;
pub const __ISwprint: _bindgen_ty_20 = _bindgen_ty_20::__ISwprint;
pub const __ISwgraph: _bindgen_ty_20 = _bindgen_ty_20::__ISwgraph;
pub const __ISwblank: _bindgen_ty_20 = _bindgen_ty_20::__ISwblank;
pub const __ISwcntrl: _bindgen_ty_20 = _bindgen_ty_20::__ISwcntrl;
pub const __ISwpunct: _bindgen_ty_20 = _bindgen_ty_20::__ISwpunct;
pub const __ISwalnum: _bindgen_ty_20 = _bindgen_ty_20::__ISwalnum;
pub const _ISwupper: _bindgen_ty_20 = _bindgen_ty_20::_ISwupper;
pub const _ISwlower: _bindgen_ty_20 = _bindgen_ty_20::_ISwlower;
pub const _ISwalpha: _bindgen_ty_20 = _bindgen_ty_20::_ISwalpha;
pub const _ISwdigit: _bindgen_ty_20 = _bindgen_ty_20::_ISwdigit;
pub const _ISwxdigit: _bindgen_ty_20 = _bindgen_ty_20::_ISwxdigit;
pub const _ISwspace: _bindgen_ty_20 = _bindgen_ty_20::_ISwspace;
pub const _ISwprint: _bindgen_ty_20 = _bindgen_ty_20::_ISwprint;
pub const _ISwgraph: _bindgen_ty_20 = _bindgen_ty_20::_ISwgraph;
pub const _ISwblank: _bindgen_ty_20 = _bindgen_ty_20::_ISwblank;
pub const _ISwcntrl: _bindgen_ty_20 = _bindgen_ty_20::_ISwcntrl;
pub const _ISwpunct: _bindgen_ty_20 = _bindgen_ty_20::_ISwpunct;
pub const _ISwalnum: _bindgen_ty_20 = _bindgen_ty_20::_ISwalnum;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum _bindgen_ty_20 {
    __ISwupper = 0,
    __ISwlower = 1,
    __ISwalpha = 2,
    __ISwdigit = 3,
    __ISwxdigit = 4,
    __ISwspace = 5,
    __ISwprint = 6,
    __ISwgraph = 7,
    __ISwblank = 8,
    __ISwcntrl = 9,
    __ISwpunct = 10,
    __ISwalnum = 11,
    _ISwupper = 16777216,
    _ISwlower = 33554432,
    _ISwalpha = 67108864,
    _ISwdigit = 134217728,
    _ISwxdigit = 268435456,
    _ISwspace = 536870912,
    _ISwprint = 1073741824,
    _ISwgraph = -2147483648,
    _ISwblank = 65536,
    _ISwcntrl = 131072,
    _ISwpunct = 262144,
    _ISwalnum = 524288,
}
extern "C" {
    pub fn iswalnum(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswalpha(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswcntrl(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswdigit(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswgraph(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswlower(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswprint(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswpunct(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswspace(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswupper(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswxdigit(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswblank(__wc: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctype(__property: *const ::std::os::raw::c_char) -> wctype_t;
}
extern "C" {
    pub fn iswctype(__wc: wint_t, __desc: wctype_t) -> ::std::os::raw::c_int;
}
pub type wctrans_t = *const __int32_t;
extern "C" {
    pub fn towlower(__wc: wint_t) -> wint_t;
}
extern "C" {
    pub fn towupper(__wc: wint_t) -> wint_t;
}
extern "C" {
    pub fn wctrans(__property: *const ::std::os::raw::c_char) -> wctrans_t;
}
extern "C" {
    pub fn towctrans(__wc: wint_t, __desc: wctrans_t) -> wint_t;
}
extern "C" {
    pub fn iswalnum_l(__wc: wint_t, __locale: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswalpha_l(__wc: wint_t, __locale: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswcntrl_l(__wc: wint_t, __locale: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswdigit_l(__wc: wint_t, __locale: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswgraph_l(__wc: wint_t, __locale: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswlower_l(__wc: wint_t, __locale: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswprint_l(__wc: wint_t, __locale: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswpunct_l(__wc: wint_t, __locale: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswspace_l(__wc: wint_t, __locale: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswupper_l(__wc: wint_t, __locale: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswxdigit_l(__wc: wint_t, __locale: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswblank_l(__wc: wint_t, __locale: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctype_l(__property: *const ::std::os::raw::c_char,
                    __locale: __locale_t) -> wctype_t;
}
extern "C" {
    pub fn iswctype_l(__wc: wint_t, __desc: wctype_t, __locale: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn towlower_l(__wc: wint_t, __locale: __locale_t) -> wint_t;
}
extern "C" {
    pub fn towupper_l(__wc: wint_t, __locale: __locale_t) -> wint_t;
}
extern "C" {
    pub fn wctrans_l(__property: *const ::std::os::raw::c_char,
                     __locale: __locale_t) -> wctrans_t;
}
extern "C" {
    pub fn towctrans_l(__wc: wint_t, __desc: wctrans_t, __locale: __locale_t)
     -> wint_t;
}
extern "C" {
    pub fn memcpy(__dest: *mut ::std::os::raw::c_void,
                  __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(__dest: *mut ::std::os::raw::c_void,
                   __src: *const ::std::os::raw::c_void,
                   __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(__s: *mut ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(__s1: *const ::std::os::raw::c_void,
                  __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(__s: *const ::std::os::raw::c_void,
                  __c: ::std::os::raw::c_int, __n: usize)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(__s1: *const ::std::os::raw::c_char,
                  __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(__s1: *const ::std::os::raw::c_char,
                   __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strcoll_l(__s1: *const ::std::os::raw::c_char,
                     __s2: *const ::std::os::raw::c_char, __l: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize,
                     __l: __locale_t) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(__string: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(__s: *const ::std::os::raw::c_char,
                   __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(__s: *const ::std::os::raw::c_char,
                   __reject: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(__s: *const ::std::os::raw::c_char,
                  __accept: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(__s: *const ::std::os::raw::c_char,
                   __accept: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(__haystack: *const ::std::os::raw::c_char,
                  __needle: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(__s: *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(__s: *mut ::std::os::raw::c_char,
                      __delim: *const ::std::os::raw::c_char,
                      __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(__s: *mut ::std::os::raw::c_char,
                    __delim: *const ::std::os::raw::c_char,
                    __save_ptr: *mut *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize)
     -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__xpg_strerror_r"]
    pub fn strerror_r(__errnum: ::std::os::raw::c_int,
                      __buf: *mut ::std::os::raw::c_char, __buflen: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(__errnum: ::std::os::raw::c_int, __l: __locale_t)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcopy(__src: *const ::std::os::raw::c_void,
                 __dest: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn bcmp(__s1: *const ::std::os::raw::c_void,
                __s2: *const ::std::os::raw::c_void, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn index(__s: *const ::std::os::raw::c_char,
                 __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(__s: *const ::std::os::raw::c_char,
                  __c: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(__s1: *const ::std::os::raw::c_char,
                      __s2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(__s1: *const ::std::os::raw::c_char,
                       __s2: *const ::std::os::raw::c_char, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strsep(__stringp: *mut *mut ::std::os::raw::c_char,
                  __delim: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(__dest: *mut ::std::os::raw::c_char,
                    __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(__dest: *mut ::std::os::raw::c_char,
                  __src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(__dest: *mut ::std::os::raw::c_char,
                     __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(__dest: *mut ::std::os::raw::c_char,
                   __src: *const ::std::os::raw::c_char, __n: usize)
     -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(::std::mem::size_of::<tm>() , 56usize);
    assert_eq!(::std::mem::align_of::<tm>() , 8usize);
}
impl Clone for tm {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(::std::mem::size_of::<itimerspec>() , 32usize);
    assert_eq!(::std::mem::align_of::<itimerspec>() , 8usize);
}
impl Clone for itimerspec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent([u8; 0]);
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(__s: *mut ::std::os::raw::c_char, __maxsize: usize,
                    __format: *const ::std::os::raw::c_char, __tp: *const tm)
     -> usize;
}
extern "C" {
    pub fn strftime_l(__s: *mut ::std::os::raw::c_char, __maxsize: usize,
                      __format: *const ::std::os::raw::c_char,
                      __tp: *const tm, __loc: __locale_t) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "__tzname"]
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    #[link_name = "__daylight"]
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__timezone"]
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    #[link_name = "tzname"]
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    #[link_name = "daylight"]
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "timezone"]
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(__requested_time: *const timespec,
                     __remaining: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(__clock_id: clockid_t,
                           __flags: ::std::os::raw::c_int,
                           __req: *const timespec, __rem: *mut timespec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(__clock_id: clockid_t, __evp: *mut sigevent,
                        __timerid: *mut timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(__timerid: timer_t, __flags: ::std::os::raw::c_int,
                         __value: *const itimerspec,
                         __ovalue: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
pub type mbstate_t = __mbstate_t;
extern "C" {
    pub fn wcscpy(__dest: *mut wchar_t, __src: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(__dest: *mut wchar_t, __src: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncat(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(__s1: *const wchar_t, __s2: *const wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncmp(__s1: *const wchar_t, __s2: *const wchar_t, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp(__s1: *const wchar_t, __s2: *const wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp(__s1: *const wchar_t, __s2: *const wchar_t, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp_l(__s1: *const wchar_t, __s2: *const wchar_t,
                        __loc: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp_l(__s1: *const wchar_t, __s2: *const wchar_t,
                         __n: usize, __loc: __locale_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscoll(__s1: *const wchar_t, __s2: *const wchar_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize)
     -> usize;
}
extern "C" {
    pub fn wcscoll_l(__s1: *const wchar_t, __s2: *const wchar_t,
                     __loc: __locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm_l(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize,
                     __loc: __locale_t) -> usize;
}
extern "C" {
    pub fn wcsdup(__s: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcschr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrchr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(__wcs: *const wchar_t, __reject: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcsspn(__wcs: *const wchar_t, __accept: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcspbrk(__wcs: *const wchar_t, __accept: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(__haystack: *const wchar_t, __needle: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcstok(__s: *mut wchar_t, __delim: *const wchar_t,
                  __ptr: *mut *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslen(__s: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcsnlen(__s: *const wchar_t, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn wmemchr(__s: *const wchar_t, __c: wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wmemcmp(__s1: *const wchar_t, __s2: *const wchar_t, __n: usize)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wmemmove(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wmemset(__s: *mut wchar_t, __c: wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn btowc(__c: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn wctob(__c: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbsinit(__ps: *const mbstate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbrtowc(__pwc: *mut wchar_t, __s: *const ::std::os::raw::c_char,
                   __n: usize, __p: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcrtomb(__s: *mut ::std::os::raw::c_char, __wc: wchar_t,
                   __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn __mbrlen(__s: *const ::std::os::raw::c_char, __n: usize,
                    __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbrlen(__s: *const ::std::os::raw::c_char, __n: usize,
                  __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbsrtowcs(__dst: *mut wchar_t,
                     __src: *mut *const ::std::os::raw::c_char, __len: usize,
                     __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcsrtombs(__dst: *mut ::std::os::raw::c_char,
                     __src: *mut *const wchar_t, __len: usize,
                     __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbsnrtowcs(__dst: *mut wchar_t,
                      __src: *mut *const ::std::os::raw::c_char, __nmc: usize,
                      __len: usize, __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcsnrtombs(__dst: *mut ::std::os::raw::c_char,
                      __src: *mut *const wchar_t, __nwc: usize, __len: usize,
                      __ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wcstod(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn wcstof(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn wcstold(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t)
     -> f64;
}
extern "C" {
    pub fn wcstol(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                  __base: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                   __base: ::std::os::raw::c_int) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoll(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                   __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t,
                    __base: ::std::os::raw::c_int)
     -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcpcpy(__dest: *mut wchar_t, __src: *const wchar_t)
     -> *mut wchar_t;
}
extern "C" {
    pub fn wcpncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize)
     -> *mut wchar_t;
}
extern "C" {
    pub fn open_wmemstream(__bufloc: *mut *mut wchar_t, __sizeloc: *mut usize)
     -> *mut __FILE;
}
extern "C" {
    pub fn fwide(__fp: *mut __FILE, __mode: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwprintf(__stream: *mut __FILE, __format: *const wchar_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wprintf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swprintf(__s: *mut wchar_t, __n: usize,
                    __format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwprintf(__s: *mut __FILE, __format: *const wchar_t,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf(__format: *const wchar_t, __arg: *mut __va_list_tag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf(__s: *mut wchar_t, __n: usize, __format: *const wchar_t,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf(__stream: *mut __FILE, __format: *const wchar_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf(__s: *const wchar_t, __format: *const wchar_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fwscanf"]
    pub fn fwscanf1(__stream: *mut __FILE, __format: *const wchar_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_wscanf"]
    pub fn wscanf1(__format: *const wchar_t, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_swscanf"]
    pub fn swscanf1(__s: *const wchar_t, __format: *const wchar_t, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwscanf(__s: *mut __FILE, __format: *const wchar_t,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwscanf(__format: *const wchar_t, __arg: *mut __va_list_tag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswscanf(__s: *const wchar_t, __format: *const wchar_t,
                    __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfwscanf"]
    pub fn vfwscanf1(__s: *mut __FILE, __format: *const wchar_t,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vwscanf"]
    pub fn vwscanf1(__format: *const wchar_t, __arg: *mut __va_list_tag)
     -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vswscanf"]
    pub fn vswscanf1(__s: *const wchar_t, __format: *const wchar_t,
                     __arg: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwc(__stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwc(__wc: wchar_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(__wc: wchar_t) -> wint_t;
}
extern "C" {
    pub fn fgetws(__ws: *mut wchar_t, __n: ::std::os::raw::c_int,
                  __stream: *mut __FILE) -> *mut wchar_t;
}
extern "C" {
    pub fn fputws(__ws: *const wchar_t, __stream: *mut __FILE)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(__wc: wint_t, __stream: *mut __FILE) -> wint_t;
}
extern "C" {
    pub fn wcsftime(__s: *mut wchar_t, __maxsize: usize,
                    __format: *const wchar_t, __tp: *const tm) -> usize;
}
pub type otext = ::std::os::raw::c_char;
extern "C" {
    pub fn ocisprintf(str: *mut ::std::os::raw::c_char,
                      size: ::std::os::raw::c_int,
                      format: *const ::std::os::raw::c_char, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ocistrdup(src: *const ::std::os::raw::c_char)
     -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ocistrcasecmp(str1: *const ::std::os::raw::c_char,
                         str2: *const ::std::os::raw::c_char)
     -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ociwcsdup(src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn ociwcscasecmp(str1: *const wchar_t, str2: *const wchar_t)
     -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Pool([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Connection([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Statement([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Bind([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Resultset([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Column([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Lob([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_File([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Transaction([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Long([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Number([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Date([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Timestamp([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Interval([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Object([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Coll([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Elem([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Iter([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Ref([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_TypeInfo([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_HashTable([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Error([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Mutex([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Thread([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_DirPath([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Subscription([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Event([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Msg([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Agent([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Dequeue([u8; 0]);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OCI_Enqueue([u8; 0]);
/**
 * @var POCI_ERROR
 *
 * @brief
 * Error procedure prototype
 *
 * @param err - Error handle
 *
 */
pub type POCI_ERROR =
    ::std::option::Option<unsafe extern "C" fn(err: *mut OCI_Error)>;
/**
 * @var POCI_THREAD
 *
 * @brief
 * Thread procedure prototype
 *
 * @param thread - Thread handle
 * @param arg    - Pointer passed to OCI_ThreadRun()
 *
 */
pub type POCI_THREAD =
    ::std::option::Option<unsafe extern "C" fn(thread: *mut OCI_Thread,
                                               arg:
                                                   *mut ::std::os::raw::c_void)>;
/**
 * @var POCI_THREADKEYDEST
 *
 * @brief
 * Thread key destructor prototype.
 *
 * @param data - Thread Key current pointer value
 *
 */
pub type POCI_THREADKEYDEST =
    ::std::option::Option<unsafe extern "C" fn(data:
                                                   *mut ::std::os::raw::c_void)>;
/**
 * @var POCI_NOTIFY
 *
 * @brief
 * Database Change Notification User callback prototype.
 *
 * @param event - Event handle
 *
 */
pub type POCI_NOTIFY =
    ::std::option::Option<unsafe extern "C" fn(event: *mut OCI_Event)>;
/**
 * @var POCI_NOTIFY_AQ
 *
 * @brief
 * AQ notification callback prototype.
 *
 * @param dequeue - dequeue handle
 *
 */
pub type POCI_NOTIFY_AQ =
    ::std::option::Option<unsafe extern "C" fn(dequeue: *mut OCI_Dequeue)>;
/**
 * @var POCI_TAF_HANDLER
 *
 * @brief
 * Failover Notification User callback prototype.
 *
 * @param con   - Connection handle related to the event
 * @param type  - Event type
 * @param event - Event code
 *
 * @note
 * Possible values for parameter 'type' :
 *  - OCI_FOT_NONE
 *  - OCI_FOT_SESSION
 *  - OCI_FOT_SELECT
 *
 * @note
 * Possible values for parameter 'event' :
 *  - OCI_FOE_END
 *  - OCI_FOE_ABORT
 *  - OCI_FOE_REAUTH
 *  - OCI_FOE_BEGIN
 *  - OCI_FOE_ERROR
 *
 * @return
 * User callback should return one of the following value :
 *  - OCI_FOC_OK
 *  - OCI_FOC_RETRY
 *
 */
pub type POCI_TAF_HANDLER =
    ::std::option::Option<unsafe extern "C" fn(con: *mut OCI_Connection,
                                               type_: ::std::os::raw::c_uint,
                                               event: ::std::os::raw::c_uint)
                              -> ::std::os::raw::c_uint>;
/**
 * @var POCI_HA_HANDLER
 *
 * @brief
 * HA (High Availability) events Notification User callback prototype.
 *
 * @param con    - Connection handle related to the event
 * @param source - source of the event
 * @param event  - type of the event
 * @param time   - Timestamp of the event
 *
 * @note
 * Currently, Oracle only send HA down events
 *
 * @note
 * Possible values for parameter 'source' :
 *  - OCI_HES_INSTANCE
 *  - OCI_HES_DATABASE
 *  - OCI_HES_NODE
 *  - OCI_HES_SERVICE
 *  - OCI_HES_SERVICE_MEMBER
 *  - OCI_HES_ASM_INSTANCE
 *  - OCI_HES_PRECONNECT
 *
 * @note
 * Possible values for parameter 'event' :
 *  - OCI_HET_DOWN : HA event type down
 *  - OCI_HET_UP   : HA event type up
 *
 */
pub type POCI_HA_HANDLER =
    ::std::option::Option<unsafe extern "C" fn(con: *mut OCI_Connection,
                                               source: ::std::os::raw::c_uint,
                                               event: ::std::os::raw::c_uint,
                                               time: *mut OCI_Timestamp)>;
/**
 * @typedef OCI_XID
 *
 * @brief
 * Global transaction identifier
 *
 */
#[repr(C)]
pub struct OCI_XID {
    pub formatID: ::std::os::raw::c_long,
    pub gtrid_length: ::std::os::raw::c_long,
    pub bqual_length: ::std::os::raw::c_long,
    pub data: [::std::os::raw::c_char; 128usize],
}
#[test]
fn bindgen_test_layout_OCI_XID() {
    assert_eq!(::std::mem::size_of::<OCI_XID>() , 152usize);
    assert_eq!(::std::mem::align_of::<OCI_XID>() , 8usize);
}
/**
 * @union OCI_Variant
 *
 * @brief
 * Internal Variant type based on union C type.
 *
 * @note
 * Helpful for generic buffer, it reduces the amount of casts
 *
 */
#[repr(C)]
#[derive(Copy)]
pub union OCI_Variant {
    pub num: ::std::os::raw::c_int,
    pub p_bytes: *mut ::std::os::raw::c_uchar,
    pub p_void: *mut ::std::os::raw::c_void,
    pub p_int: *mut ::std::os::raw::c_int,
    pub p_float: *mut f32,
    pub p_double: *mut f64,
    pub p_text: *mut otext,
    pub p_date: *mut OCI_Date,
    pub p_interval: *mut OCI_Interval,
    pub p_timestamp: *mut OCI_Timestamp,
    pub p_long: *mut OCI_Long,
    pub p_lob: *mut OCI_Lob,
    pub p_file: *mut OCI_File,
    pub p_stmt: *mut OCI_Statement,
    pub p_col: *mut OCI_Column,
    pub p_obj: *mut OCI_Object,
    pub p_coll: *mut OCI_Coll,
    pub p_iter: *mut OCI_Iter,
    pub p_elem: *mut OCI_Elem,
}
#[test]
fn bindgen_test_layout_OCI_Variant() {
    assert_eq!(::std::mem::size_of::<OCI_Variant>() , 8usize);
    assert_eq!(::std::mem::align_of::<OCI_Variant>() , 8usize);
}
impl Clone for OCI_Variant {
    fn clone(&self) -> Self { *self }
}
/**
* @typedef OCI_HashValue
*
* @brief
* Hash table entry value
*
* OCILIB implementation of hash tables uses chaining method for dealing with collisions
*
*/
#[repr(C)]
#[derive(Copy)]
pub struct OCI_HashValue {
    pub value: OCI_Variant,
    pub next: *mut OCI_HashValue,
}
#[test]
fn bindgen_test_layout_OCI_HashValue() {
    assert_eq!(::std::mem::size_of::<OCI_HashValue>() , 16usize);
    assert_eq!(::std::mem::align_of::<OCI_HashValue>() , 8usize);
}
impl Clone for OCI_HashValue {
    fn clone(&self) -> Self { *self }
}
/**
 * @typedef OCI_HashEntry
 *
 * @brief
 * Hash table entry
 *
 */
#[repr(C)]
#[derive(Debug, Copy)]
pub struct OCI_HashEntry {
    pub key: *mut otext,
    pub values: *mut OCI_HashValue,
    pub next: *mut OCI_HashEntry,
}
#[test]
fn bindgen_test_layout_OCI_HashEntry() {
    assert_eq!(::std::mem::size_of::<OCI_HashEntry>() , 24usize);
    assert_eq!(::std::mem::align_of::<OCI_HashEntry>() , 8usize);
}
impl Clone for OCI_HashEntry {
    fn clone(&self) -> Self { *self }
}
pub type big_int = ::std::os::raw::c_longlong;
pub type big_uint = ::std::os::raw::c_ulonglong;
extern "C" {
    /**
 * @brief
 * Initialize the library
 *
 * @param err_handler  - Pointer to error handler procedure (optional)
 * @param lib_path     - Oracle shared library path (optional)
 * @param mode         - Environment mode
 *
 * Possible values for parameter mode:
 * - OCI_ENV_DEFAULT  : default mode
 * - OCI_ENV_THREADED : multi-threading support
 * - OCI_ENV_CONTEXT  : thread contextual error handling
 * - OCI_ENV_EVENTS   : enables events for subscription, HA Events, AQ notifications
 *
 * @note
 * This function must be called before any OCILIB library function.
 *
 * @warning
 * - The parameter 'libpath' is only used if OCILIB has been built with the option OCI_IMPORT_RUNTIME
 * - If the parameter 'lib_path' is NULL, the Oracle library is loaded from system environment variables
 *
 * @warning
 * OCI_Initialize() should be called <b>ONCE</b> per application
 *
 * @return
 * TRUE on success otherwise FALSE (only with Oracle runtime loading mode
 * if the oracle shared libraries can't be loaded or if OCI subsystem cannot be initialized)
 *
 */
    pub fn OCI_Initialize(err_handler: POCI_ERROR, lib_path: *const otext,
                          mode: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Clean up all resources allocated by the library
 *
 * @note
 * * This function must be the last OCILIB library function call.
 * - It deallocates objects not explicitly freed by the program (connections, statements, ...)
 * - It unloads the Oracle shared library if it has been dynamically loaded
 *
 * @warning
 * OCI_Cleanup() should be called <b>ONCE</b> per application
 *
 * @return TRUE
 */
    pub fn OCI_Cleanup() -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the version of OCI used for compilation
 *
 * @note
 * - with linkage build option, the version is determined from the oci.h header through different ways
 * - with runtime loading build option, the version is set to the highest version
 *   of OCI needed by OCILIB, not necessarily the real OCI version
 *
 */
    pub fn OCI_GetOCICompileVersion() -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the version of OCI used at runtime
 *
 * @note
 * - with linkage build option, the version is determined from the oci.h header
 *   through different ways
 * - with runtime loading build option, the version determined from the symbols
 *   dynamically loaded.
 *
 */
    pub fn OCI_GetOCIRuntimeVersion() -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the Oracle shared library import mode
 *
 * @note
 * Possible values are:
 * - OCI_IMPORT_MODE_LINKAGE
 * - OCI_IMPORT_MODE_RUNTIME
 *
 */
    pub fn OCI_GetImportMode() -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the OCILIB charset type
 *
 * @note
 * Possible values are:
 * - OCI_CHAR_ANSI
 * - OCI_CHAR_WIDE
 *
 */
    pub fn OCI_GetCharset() -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
* @brief
* Return the current number of bytes allocated internally in the library
*
* @param mem_type : type of memory to request
* 
* @note
* Possible values are:
* - OCI_MEM_ORACLE : bytes allocated by Oracle client library
* - OCI_MEM_OCILIB : bytes allocated by OCILIB library
* - OCI_MEM_ORACLE : bytes allocated by all libraries
*
*/
    pub fn OCI_GetAllocatedBytes(mem_type: ::std::os::raw::c_uint)
     -> big_uint;
}
extern "C" {
    /**
 * @brief
 * Enable or disable Oracle warning notifications
 *
 * @param value  - enable/disable warnings
 *
 * @note
 * Default value is FALSE
 *
 */
    pub fn OCI_EnableWarnings(value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the global error user handler
 *
 * @param handler  - Pointer to error handler procedure
 *
 * @note
 * Use this call to change or remove the user callback error handler installed by OCI_Initialize()
 *
 */
    pub fn OCI_SetErrorHandler(handler: POCI_ERROR) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the High availability (HA) user handler
 *
 * @param handler - Pointer to HA handler procedure
 *
 * @note
 * See POCI_HA_HANDLER documentation for more details
 *
 * @note
 * OCI_ENV_EVENTS flag must be passed to OCI_Initialize() to be able to use
 * HA events
 *
 * @warning
 * This call is supported from Oracle 10gR2.
 * For previous versions, it returns FALSE without throwing any exception.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SetHAHandler(handler: POCI_HA_HANDLER)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Retrieve the last error or warning occurred within the last OCILIB call
 *
 * @note
 * OCI_GetLastError() is based on thread context and thus OCILIB must be
 * initialized with the flag OCI_ENV_CONTEXT
 *
 * @warning
 * OCILIB functions that returns a boolean value to indicate their success :
 * - return TRUE if no error occurred OR if a warning occurred
 * - return FALSE if an error occurred
 *
 */
    pub fn OCI_GetLastError() -> *mut OCI_Error;
}
extern "C" {
    /**
 * @brief
 * Retrieve error message from error handle
 *
 * @param err - Error handle
 *
 */
    pub fn OCI_ErrorGetString(err: *mut OCI_Error) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Retrieve the type of error from error handle
 *
 * @param err - Error handle
 *
 * @note
 * Returns one of the following values:
 *
 * - OCI_ERR_ORACLE
 * - OCI_ERR_OCILIB
 * - OCI_ERR_WARNING
 *
 * @return
 * Object type or OCI_UNKNOWN the input handle is NULL
 *
 */
    pub fn OCI_ErrorGetType(err: *mut OCI_Error) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Retrieve Oracle Error code from error handle
 *
 * @param err - Error handle
 *
 */
    pub fn OCI_ErrorGetOCICode(err: *mut OCI_Error) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Retrieve Internal Error code from error handle
 *
 * @param err - Error handle
 *
 */
    pub fn OCI_ErrorGetInternalCode(err: *mut OCI_Error)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Retrieve connection handle within the error occurred
 *
 * @param err - Error handle
 *
 */
    pub fn OCI_ErrorGetConnection(err: *mut OCI_Error) -> *mut OCI_Connection;
}
extern "C" {
    /**
 * @brief
 * Retrieve statement handle within the error occurred
 *
 * @param err - Error handle
 *
 * @note
 * If the error occurred outside of a statement context, it returns NULL
 *
 */
    pub fn OCI_ErrorGetStatement(err: *mut OCI_Error) -> *mut OCI_Statement;
}
extern "C" {
    /**
 * @brief
 * Return the row index which caused an error during statement execution
 *
 * @param err - Error handle
 *
 * @warning
 * Row index start at 1.
 *
 * @return
 * 0 is the error is not related to array DML otherwise the index of the given
 * row which caused the error
 *
 */
    pub fn OCI_ErrorGetRow(err: *mut OCI_Error) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Create a physical connection to an Oracle database server
 *
 * @param db   - Oracle Service Name
 * @param user - Oracle User name
 * @param pwd  - Oracle User password
 * @param mode - Session mode
 *
 * Possible values for parameter mode :
 * - OCI_SESSION_DEFAULT
 * - OCI_SESSION_SYSDBA
 * - OCI_SESSION_SYSOPER
 * - OCI_SESSION_XA
 *
 * @note
 * External credentials are supported by supplying a null value for the
 * 'user' and 'pwd' parameters.
 * If the param 'db' is NULL then a connection to the default local DB is done
 *
 * @note
 * For parameter 'mode', the possible values are exclusive and cannot be combined
 *
 * @par Oracle XA support
 *
 * OCILIB supports Oracle XA connectivity. In order to get a connection using
 * the XA interface :
 *  - For parameter 'db' : pass the value of the 'DB' parameter of the given
 *   XA connection string passed to the Transaction Processing Monitor (TPM)
 *  - Pass NULL to the 'user' and 'pwd' parameters
 *  - Pass the value OCI_SESSION_XA to parameter 'mode'
 *
 * @par Oracle XA Connection String
 *
 * The XA connection string used in a transaction monitor to connect to Oracle must
 * be compatible with OCILIB :
 *
 *   - the XA parameter 'Objects' MUST be set to 'true'
 *   - If OCI_ENV_THREADED is passed to OCI_Initialize(), the XA parameter 'Threads' must
 *     be set to 'true', otherwise to 'false'
 *   - If OCI_ENV_EVENTS is passed to OCI_Initialize(), the XA parameter 'Events' must
 *     be set to 'true', otherwise to 'false'
 *   - As Oracle does not support Unicode UTF16 character set through the XA interface,
 *     Only OCI_CHARSET_ANSI builds of OCILIB can be used
 *   - You still can use UTF8 if the NLS_LANG environment variable is set with a valid
 *     UTF8 NLS value
 *   - DO NOT USE OCI_CHARSET_WIDE OCILIB builds with XA connections
 *
 * @note
 * On success, a local transaction is automatically created and started ONLY for regular
 * standalone connections and connections retrieved from connection pools.
 * No transaction is created for a XA connection or q connection retrieved from session pools.
 *
 * @return
 * Connection handle on success or NULL on failure
 *
 */
    pub fn OCI_ConnectionCreate(db: *const otext, user: *const otext,
                                pwd: *const otext,
                                mode: ::std::os::raw::c_uint)
     -> *mut OCI_Connection;
}
extern "C" {
    /**
 * @brief
 * Close a physical connection to an Oracle database server
 *
 * @param con - Connection handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ConnectionFree(con: *mut OCI_Connection)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Returns TRUE is the given connection is still connected otherwise FALSE
 *
 * @param con - Connection handle
 *
 */
    pub fn OCI_IsConnected(con: *mut OCI_Connection) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the pointer to user data previously associated with the connection
 *
 * @param con - Connection handle
 *
 */
    pub fn OCI_GetUserData(con: *mut OCI_Connection)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Associate a pointer to user data to the given connection
 *
 * @param con  - Connection handle
 * @param data - User data pointer
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SetUserData(con: *mut OCI_Connection,
                           data: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Associate a tag to the given connection/session
 *
 * @param con - Connection handle
 * @param tag - user tag string
 *
 * @note
 * Use this call only for connections retrieved from a session pool
 * See OCI_PoolGetConnection() for more details
 *
 * @note
 * To untag a session, call OCI_SetSessionTag() with 'tag' parameter set to NULL
 *
 * @warning
 * No error is raised if the connection is a standalone connection or retrieved from a connection
 * pool
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SetSessionTag(con: *mut OCI_Connection, tag: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the tag associated the given connection
 *
 * @param con - Connection handle
 *
 */
    pub fn OCI_GetSessionTag(con: *mut OCI_Connection) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the name of the connected database/service name
 *
 * @param con - Connection handle
 *
 */
    pub fn OCI_GetDatabase(con: *mut OCI_Connection) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the current logged user name
 *
 * @param con - Connection handle
 *
 */
    pub fn OCI_GetUserName(con: *mut OCI_Connection) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the current logged user password
 *
 * @param con - Connection handle
 *
 */
    pub fn OCI_GetPassword(con: *mut OCI_Connection) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Change the password of the logged user
 *
 * @param con      - Connection handle
 * @param password - New password
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SetPassword(con: *mut OCI_Connection, password: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Change the password of the given user on the given database
 *
 * @param db      - Oracle Service Name
 * @param user    - Oracle User name
 * @param pwd     - Oracle User password
 * @param new_pwd - Oracle User New password
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SetUserPassword(db: *const otext, user: *const otext,
                               pwd: *const otext, new_pwd: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the current session mode
 *
 * @param con - Connection handle
 *
 * @note
 * See OCI_ConnectionCreate() for possible values
 *
 */
    pub fn OCI_GetSessionMode(con: *mut OCI_Connection)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the connected database server version
 *
 * @param con - Connection handle
 *
 */
    pub fn OCI_GetVersionServer(con: *mut OCI_Connection) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the major version number of the connected database server
 *
 * @param con - Connection handle
 *
 * @return
 * Version number or 0 on failure
 *
 */
    pub fn OCI_GetServerMajorVersion(con: *mut OCI_Connection)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the minor version number of the connected database server
 *
 * @param con - Connection handle
 *
 * @return
 * Version number or 0 on failure
 *
 */
    pub fn OCI_GetServerMinorVersion(con: *mut OCI_Connection)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the revision version number of the connected database server
 *
 * @param con - Connection handle
 *
 * @return
 * Version number or 0 on failure
 *
 */
    pub fn OCI_GetServerRevisionVersion(con: *mut OCI_Connection)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set the format string for implicit string conversions of the given type
 *
 * @param con    - Connection handle (optional)
 * @param type   - Type of format
 * @param format - Format string
 *
 * Formats can set at 2 levels:
 * - Library level: by passing a NULL Connection handle
 * - Connection level: by passing a valid Connection handle
 *
 * When the library needs to perform a string conversion, it search for a valid format using the
 * following order:
 * - Connection format
 * - Library format
 * - Default format
 *
 * @note
 * Possible values of parameter 'type' :
 *
 * - OCI_FMT_DATE          : format used to convert DATE to string
 * - OCI_FMT_TIMESTAMP     : format used to convert TIMESTAMP to string
 * - OCI_FMT_NUMERIC       : format used to convert numeric types to string
 * - OCI_FMT_BINARY_DOUBLE : format used to convert BINARY_DOUBLE to string
 * - OCI_FMT_BINARY FLOAT  : format used to convert BINARY_FLOAT to string
 *
 * @note
 * Default format values are :
 * - OCI_FMT_DATE          : constant OCI_STRING_FORMAT_DATE
 * - OCI_FMT_TIMESTAMP     : constant OCI_STRING_FORMAT_TIMESTAMP
 * - OCI_FMT_NUMERIC       : constant OCI_STRING_FORMAT_NUMERIC
 * - OCI_FMT_BINARY_DOUBLE : constant OCI_STRING_FORMAT_BINARY_DOUBLE
 * - OCI_FMT_BINARY FLOAT  : constant OCI_STRING_FORMAT_BINARY_FLOAT
 *
 * @note
 * Conversions are performed by Oracle built-in functions whenever possible.
 * For DATE, TIMESTAMP and numeric types, see documentation of Oracle SQL to_char() function for more details
 * For BINARY_DOUBLE and BINARY_FLOAT, refer to the C Standard Library printf() family documentation
 *
 */
    pub fn OCI_SetFormat(con: *mut OCI_Connection,
                         type_: ::std::os::raw::c_uint, format: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the format string for implicit string conversions of the given type
 *
 * @param con    - Connection handle
 * @param type   - Type of format
 *
 * @note
 *  See OCI_SetFormat() for possible values
 *
 */
    pub fn OCI_GetFormat(con: *mut OCI_Connection,
                         type_: ::std::os::raw::c_uint) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the current transaction of the connection
 *
 * @param con - Connection handle
 *
 * @note
 * From v3.9.4, no more default transaction object is created for a new connection
 *
 */
    pub fn OCI_GetTransaction(con: *mut OCI_Connection)
     -> *mut OCI_Transaction;
}
extern "C" {
    /**
 * @brief
 * Set a transaction to a connection
 *
 * @param con   - Connection handle
 * @param trans - Transaction handle to assign
 *
 * @note
 * The current transaction (if any) is automatically stopped but the newly assigned is not
 * started or resumed
 *
 * @warning
 * Do not set transaction object to XA connection or connection retrieved from a session pool
 *
 */
    pub fn OCI_SetTransaction(con: *mut OCI_Connection,
                              trans: *mut OCI_Transaction)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the highest Oracle version is supported by the connection
 *
 * @param con - connection handle
 *
 * @note
 * The highest supported version is the lower version between client and server:
 *
 * @note
 * Returns one of the following values:
 *
 * - OCI_UNKNOWN
 * - OCI_8_0
 * - OCI_8_1
 * - OCI_9_0
 * - OCI_9_2
 * - OCI_10_1
 * - OCI_10_2
 * - OCI_11_1
 * - OCI_11_2
 * - OCI_12_1
 *
 */
    pub fn OCI_GetVersionConnection(con: *mut OCI_Connection)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set tracing information to the session of the given connection
 *
 * @param con   - connection handle
 * @param trace - trace type
 * @param value - trace content
 *
 * Store current trace information to the given connection handle.
 * These information:
 *
 * - is stored in the system view V$SESSION
 * - can be retrieved from the connection property of an OCI_Error handle
 *
 * @note
 * Possible values of parameter 'trace' :
 *
 * - OCI_TRC_IDENTITY : Specifies the user defined identifier in the session.
 *                      It's recorded in the column CLIENT_IDENTIFIER of the
 *                      system view V$SESSION
 * - OCI_TRC_MODULE   : name of the current module in the client application.
 *                      It's recorded in the column MODULE of the
 *                      system view V$SESSION
 * - OCI_TRC_ACTION   : name of the current action within the current module.
 *                      It's recorded in the column ACTION of the
 *                      system view V$SESSION
 * - OCI_TRC_DETAIL   : Client application additional information.
 *                      It's recorded in the column CLIENT_INFO of the
 *                      system view V$SESSION
 *
 * @warning
 * The system view V$SESSION is updated on Oracle versions >= 10g
 *
 * @warning
 * Oracle limits the size of these traces content and thus OCILIB will truncate
 * the given values if needed :
 *
 * - OCI_TRC_IDENTITY : 64 bytes
 * - OCI_TRC_MODULE   : 48 bytes
 * - OCI_TRC_ACTION   : 32 bytes
 * - OCI_TRC_DETAIL   : 64 bytes
 *
 */
    pub fn OCI_SetTrace(con: *mut OCI_Connection,
                        trace: ::std::os::raw::c_uint, value: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the current trace for the trace type from the given connection.
 *
 * @param con   - connection handle
 * @param trace - trace type
 *
 * @note
 * See OCI_SetTrace() for more details.
 *
 */
    pub fn OCI_GetTrace(con: *mut OCI_Connection,
                        trace: ::std::os::raw::c_uint) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Makes a round trip call to the server to confirm that the connection and the server are active.
 *
 * @param con - Connection handle
 *
 * @note
 * Returns TRUE is the connection is still alive otherwise FALSE
 *
 * @warning
 * This call is supported from Oracle 10g.
 * For previous versions, it returns FALSE without throwing any exception.
 *
 */
    pub fn OCI_Ping(con: *mut OCI_Connection) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the Oracle server database name of the connected database/service name
 *
 * @param con - Connection handle
 *
 * @warning
 * This call is supported from Oracle 10gR2.
 * For previous versions, it returns NULL without throwing any exception.
 *
 */
    pub fn OCI_GetDBName(con: *mut OCI_Connection) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the Oracle server Instance name of the connected database/service name
 *
 * @param con - Connection handle
 *
 * @warning
 * This call is supported from Oracle 10gR2.
 * For previous versions, it returns NULL without throwing any exception.
 *
 */
    pub fn OCI_GetInstanceName(con: *mut OCI_Connection) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the Oracle server service name of the connected database/service name
 *
 * @param con - Connection handle
 *
 * @warning
 * This call is supported from Oracle 10gR2.
 * For previous versions, it returns NULL without throwing any exception.
 *
 */
    pub fn OCI_GetServiceName(con: *mut OCI_Connection) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the Oracle server machine name of the connected database/service name
 *
 * @param con - Connection handle
 *
 * @warning
 * This call is supported from Oracle 10gR2.
 * For previous versions, it returns NULL without throwing any exception.
 *
 */
    pub fn OCI_GetServerName(con: *mut OCI_Connection) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the Oracle server domain name of the connected database/service name
 *
 * @param con - Connection handle
 *
 * @warning
 * This call is supported from Oracle 10gR2.
 * For previous versions, it returns NULL without throwing any exception.
 *
 */
    pub fn OCI_GetDomainName(con: *mut OCI_Connection) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the date and time (Timestamp) server instance start of the
 * connected database/service name
 *
 * @param con - Connection handle
 *
 * @warning
 * This call is supported from Oracle 10gR2.
 * For previous versions, it returns NULL without throwing any exception.
 *
 */
    pub fn OCI_GetInstanceStartTime(con: *mut OCI_Connection)
     -> *mut OCI_Timestamp;
}
extern "C" {
    /**
 * @brief
 * Verify if the given connection support TAF events
 *
 * @param con - Connection handle
 *
 * @note
 * Returns TRUE is the connection supports TAF event otherwise FALSE
 *
 * @warning
 * This call is supported from Oracle 10gR2.
 * For previous versions, it returns FALSE without throwing any exception.
 *
 */
    pub fn OCI_IsTAFCapable(con: *mut OCI_Connection)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the Transparent Application Failover (TAF) user handler
 *
 * @param con     - Connection handle
 * @param handler - Pointer to TAF handler procedure
 *
 * @note
 * See POCI_TAF_HANDLER documentation for more details
 *
* @warning
 * This call is supported from Oracle 10gR2.
 * For previous versions, it returns FALSE without throwing any exception.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SetTAFHandler(con: *mut OCI_Connection,
                             handler: POCI_TAF_HANDLER)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the maximum number of statements to keep in the statement cache
 *
 * @param con  - Connection handle
 *
 * @note
 * Default value is 20 (value from Oracle Documentation)
 *
 * @warning
 * Requires Oracle Client 9.2 or above
 *
 */
    pub fn OCI_GetStatementCacheSize(con: *mut OCI_Connection)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set the maximum number of statements to keep in the statement cache
 *
 * @param con   - Connection handle
 * @param value - maximum number of statements in the cache
 *
 * @warning
 * Requires Oracle Client 9.2 or above
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SetStatementCacheSize(con: *mut OCI_Connection,
                                     value: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the default LOB prefetch buffer size for the connection
 *
 * @param con  - Connection handle
 *
 * @warning
 * Requires Oracle Client AND Server 11gR1 or above
 *
 * @note
 * Prefetch size is:
 * - number of bytes for BLOBs and BFILEs
 * - number of characters for CLOBs.
 *
 * @note
 * Default is 0 (prefetching disabled)
 *
 */
    pub fn OCI_GetDefaultLobPrefetchSize(con: *mut OCI_Connection)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Enable or disable prefetching for all LOBs fetched in the connection
 *
 * @param con   - Connection handle
 * @param value - default prefetch buffer size
 *
 * @note
 * If parameter 'value':
 * - is == 0, it disables prefetching for all LOBs fetched in the connection.
 * - is >  0, it enables prefetching for all LOBs fetched in the connection
 * and the given buffer size is used for prefetching LOBs
 *
 * @note
 * LOBs prefetching is disabled by default
 *
 * @warning
 * Requires Oracle Client AND Server 11gR1 or above.
 *
 * @note
 * Prefetch size is:
 * - number of bytes for BLOBs and BFILEs
 * - number of characters for CLOBs.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SetDefaultLobPrefetchSize(con: *mut OCI_Connection,
                                         value: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Return the maximum number of SQL statements that can be opened in one session
*
* @param con  - Connection handle
*
* @warning
* Requires Oracle Client AND Server 12cR1 or above
*
* @note
* the returned value is the same as the db parameter 'open_cursors' from server's parameter file
*
* @note
* Return 0 if the client and server version are < 12cR1
*
*/
    pub fn OCI_GetMaxCursors(con: *mut OCI_Connection)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Create an Oracle pool of connections or sessions
 *
 * @param db       - Oracle Service Name
 * @param user     - Oracle User name
 * @param pwd      - Oracle User password
 * @param type     - Type of pool
 * @param mode     - Session mode
 * @param min_con  - minimum number of  connections/sessions that can be opened.
 * @param max_con  - maximum number of  connections/sessions that can be opened.
 * @param incr_con - next increment for connections/sessions to be opened
 *
 * Possible values for parameter 'type':
 * - OCI_POOL_CONNECTION
 * - OCI_POOL_SESSION
 *
 * Possible values for parameter 'mode':
 * - OCI_SESSION_DEFAULT
 * - OCI_SESSION_SYSDAB
 * - OCI_SESSION_SYSOPER
 *
 * @note
 * External credentials are supported by supplying a null value for the 'user'
 * and 'pwd' parameters
 * If the param 'db' is NULL then a connection to the default local DB is done
 *
 * @return
 * Connection or session pool handle on success or NULL on failure
 *
 */
    pub fn OCI_PoolCreate(db: *const otext, user: *const otext,
                          pwd: *const otext, type_: ::std::os::raw::c_uint,
                          mode: ::std::os::raw::c_uint,
                          min_con: ::std::os::raw::c_uint,
                          max_con: ::std::os::raw::c_uint,
                          incr_con: ::std::os::raw::c_uint) -> *mut OCI_Pool;
}
extern "C" {
    /**
 * @brief
 * Destroy a pool object
 *
 * @param pool - Pool handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_PoolFree(pool: *mut OCI_Pool) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get a connection from the pool
 *
 * @param pool - Pool handle
 * @param tag  - user tag string
 *
 * @par Session tagging
 *
 * Session pools have a nice feature that is 'session tagging'
 * It's possible to tag a session with a string identifier
 * when the session is returned to the pool, it keeps its tags.
 * When requesting a connection from the session pool, it's
 * possible to request a session that has the given 'tag' parameter
 * If one exists, it is returned. If not and if an untagged session
 * is available, it is then returned. So check the connection tag
 * property with OCI_GetSessionTag() to find out if the returned
 * connection is tagged or not.
 *
 * This features is described in the OCI developer guide as the following :
 *
 *  "The tags provide a way for users to customize sessions in the pool.
 *   A client may get a default or untagged session from a pool, set certain
 *   attributes on the session (such as NLS settings), and return the session
 *   to the pool, labeling it with an appropriate tag.
 *   The user may request a session with the same tags in order to have a
 *   session with the same attributes"
 *
 * @return
 * Connection handle otherwise NULL on failure
 */
    pub fn OCI_PoolGetConnection(pool: *mut OCI_Pool, tag: *const otext)
     -> *mut OCI_Connection;
}
extern "C" {
    /**
 * @brief
 * Get the idle timeout for connections/sessions in the pool
 *
 * @param pool - Pool handle
 *
 * @note
 * Connections/sessions idle for more than this time value (in seconds) is terminated
 *
 * @note
 * Timeout is not available for internal pooling implementation (client < 9i)
 *
 */
    pub fn OCI_PoolGetTimeout(pool: *mut OCI_Pool) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set the connections/sessions idle timeout
 *
 * @param pool  - Pool handle
 * @param value - Timeout value
 *
 * @note
 * connections/sessions idle for more than this time value (in seconds) is terminated
 *
 * @note
 * This call has no effect if pooling is internally implemented (client < 9i)
 *
 */
    pub fn OCI_PoolSetTimeout(pool: *mut OCI_Pool,
                              value: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the waiting mode used when no more connections/sessions are available
 * from the pool
 *
 * @param pool - Pool handle
 *
 * @return
 * - FALSE to wait for an available object if the pool is saturated
 * - TRUE to not wait for an available object
 *
 */
    pub fn OCI_PoolGetNoWait(pool: *mut OCI_Pool) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the waiting mode used when no more connections/sessions are available
 * from the pool
 *
 * @param pool  - Pool handle
 * @param value - wait for object
 *
 * @note
 * Pass :
 * - FALSE to wait for an available object if the pool is saturated
 * - TRUE to not wait for an available object
 *
 */
    pub fn OCI_PoolSetNoWait(pool: *mut OCI_Pool,
                             value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the current number of busy connections/sessions
 *
 * @param pool - Pool handle
 *
 */
    pub fn OCI_PoolGetBusyCount(pool: *mut OCI_Pool)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the current number of opened connections/sessions
 *
 * @param pool - Pool handle
 *
 */
    pub fn OCI_PoolGetOpenedCount(pool: *mut OCI_Pool)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the minimum number of connections/sessions that can be opened to the database
 *
 * @param pool - Pool handle
 *
 */
    pub fn OCI_PoolGetMin(pool: *mut OCI_Pool) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the maximum number of connections/sessions that can be opened to the database
 *
 * @param pool - Pool handle
 *
 */
    pub fn OCI_PoolGetMax(pool: *mut OCI_Pool) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the increment for connections/sessions to be opened to the database when the pool is
 * not full
 *
 * @param pool - Pool handle
 *
 */
    pub fn OCI_PoolGetIncrement(pool: *mut OCI_Pool)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the maximum number of statements to keep in the pool statement cache
 *
 * @param pool - Pool handle
 *
 * @note
 * Default value is 20 (value from Oracle Documentation)
 *
 */
    pub fn OCI_PoolGetStatementCacheSize(pool: *mut OCI_Pool)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set the maximum number of statements to keep in the pool statement cache
 *
 * @param pool  - Pool handle
 * @param value - maximum number of statements in the cache
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_PoolSetStatementCacheSize(pool: *mut OCI_Pool,
                                         value: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Commit current pending changes
 *
 * @param con - Connection handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_Commit(con: *mut OCI_Connection) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Cancel current pending changes
 *
 * @param con - Connection handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_Rollback(con: *mut OCI_Connection) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Enable / disable auto commit mode
 *
 * The auto commit mode allows commit changes after every executed SQL order
 *
 * @param con    - Connection handle
 * @param enable - Enable (TRUE) or disable (FALSE)
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SetAutoCommit(con: *mut OCI_Connection,
                             enable: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get current auto commit mode status
 *
 * @param con - Connection handle
 *
 * @return
 * TRUE if auto commit mode is activated otherwise FALSE
 *
 */
    pub fn OCI_GetAutoCommit(con: *mut OCI_Connection)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create a new global transaction or a serializable/read-only local transaction
 *
 * @param con     - Connection handle
 * @param timeout - Time that a transaction stays inactive after being stopped
 * @param mode    - Transaction mode
 * @param pxid    - pointer to a global transaction identifier structure
 *
 *
 * @note
 * The parameter 'mode' can be one of the following values :
 *
 * - Global transactions:
 *      - OCI_TRS_NEW : By default starts a new, tightly coupled and
 *                      migratable branch.
 *      - OCI_TRS_TIGHT : explicitly specifies a tightly coupled branch
 *      - OCI_TRS_LOOSE : specifies a loosely coupled branch
 *
 * - Global and local transactions :
 *      - OCI_TRS_READONLY - start a read-only transaction
 *      - OCI_TRS_READWRITE - start a read-write transaction
 *      - OCI_TRS_SERIALIZABLE : start a serializable transaction
 *
 * @note
 * For local transaction:
 * - pass a NULL value for pxid
 *
 */
    pub fn OCI_TransactionCreate(con: *mut OCI_Connection,
                                 timeout: ::std::os::raw::c_uint,
                                 mode: ::std::os::raw::c_uint,
                                 pxid: *mut OCI_XID) -> *mut OCI_Transaction;
}
extern "C" {
    /**
 * @brief
 * Free current transaction
 *
 * @param trans - Connection handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TransactionFree(trans: *mut OCI_Transaction)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Start global transaction
 *
 * @param trans - Connection handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TransactionStart(trans: *mut OCI_Transaction)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Stop current global transaction
 *
 * @param trans - Connection handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TransactionStop(trans: *mut OCI_Transaction)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Resume a stopped global transaction
 *
 * @param trans - Global transaction handle
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_TransactionResume(trans: *mut OCI_Transaction)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Prepare a global transaction validation
 *
 * @param trans - Global transaction handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TransactionPrepare(trans: *mut OCI_Transaction)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Cancel the prepared global transaction validation
 *
 * @param trans - Global transaction handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TransactionForget(trans: *mut OCI_Transaction)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return global transaction mode.
 *
 * @note:
 * see OCI_TransactionCreate() for possible values
 *
 * @param trans - Global transaction handle
 *
 * @return
 * Transaction mode or OCI_UNKNOW if trans is NULL
 *
 */
    pub fn OCI_TransactionGetMode(trans: *mut OCI_Transaction)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return global transaction Timeout
 *
 * @param trans - Global transaction handle
 *
 * @return
 * Transaction timeout or 0 if trans is NULL
 *
 */
    pub fn OCI_TransactionGetTimeout(trans: *mut OCI_Transaction)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Create a statement object and return its handle
 *
 * @param con - Connection handle
 *
 * @return
 * A statement handle on success otherwise NULL
 *
 */
    pub fn OCI_StatementCreate(con: *mut OCI_Connection)
     -> *mut OCI_Statement;
}
extern "C" {
    /**
 * @brief
 * Free a statement and all resources associated to it (resultsets ...)
 *
 * @param stmt - Connection handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_StatementFree(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Prepare a SQL statement or PL/SQL block.
 *
 * @param stmt - Statement handle
 * @param sql  - SQL order or PL/SQL block
 *
 * @note
 * Do not call this function for fetched statements (REF cursors)
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_Prepare(stmt: *mut OCI_Statement, sql: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Execute a prepared SQL statement or PL/SQL block.
 *
 * @param stmt - Statement handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 * @warning
 * If a SQL warning occurs:
 * - the function returns TRUE
 * - the SQL warning triggers the global error handler with an OCI_Error having its OCI_ErrorGetType()
 *   attribute set to OCI_ERR_WARNING
 * - If OCILIB is initialized with the OCI_ENV_CONTEXT mode, OCI_GetLastError() will return the OCI_Error
 *   object corresponding to the warning
 *
 */
    pub fn OCI_Execute(stmt: *mut OCI_Statement) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Prepare and Execute a SQL statement or PL/SQL block.
 *
 * @param stmt - Statement handle
 * @param sql  - SQL order - PL/SQL block
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 * @warning
 * If a SQL warning occurs:
 * - the function returns TRUE
 * - the SQL warning triggers the global error handler with an OCI_Error having its OCI_ErrorGetType()
 *   attribute set to OCI_ERR_WARNING
 * - If OCILIB is initialized with the OCI_ENV_CONTEXT mode, OCI_GetLastError() will return the OCI_Error
 *   object corresponding to the warning
 *
 */
    pub fn OCI_ExecuteStmt(stmt: *mut OCI_Statement, sql: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Parse a SQL statement or PL/SQL block.
 *
 * @param stmt - Statement handle
 * @param sql  - SQL order - PL/SQL block
 *
 * @note
 * This call sends the SQL or PL/SQL command to the server for parsing only.
 * The command is not executed.
 * This call is only useful to check is a command is valid or not.
 *
 * @note
 * This call prepares the statement (internal call to OCI_Prepare()) and ask
 * the Oracle server to parse its SQL or PL/SQL command.
 * OCI_Execute() can be call after OCI_Parse() in order to execute the
 * statement, which means that the server will re-parse again the command.
 *
 * @warning
 * Do not use OCI_Parse() unless you're only interested in the parsing result
 * because the statement will be parsed again when executed and thus leading to
 * unnecessary server round-trips and less performance
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_Parse(stmt: *mut OCI_Statement, sql: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Describe the select list of a SQL select statement.
 *
 * @param stmt - Statement handle
 * @param sql  - SELECT sql statement
 *
 * @note
 * This call sends the SELECT SQL order to the server for retrieving the
 * description of the select order only.
 * The command is not executed.
 * This call is only useful to retrieve information on the associated resultset
 * Call OCI_GetResultet() after OCI_Describe() to access to SELECT list
 * information
 *
 * @note
 * This call prepares the statement (internal call to OCI_Prepare()) and ask
 * the Oracle server to describe the output SELECT list.
 * OCI_Execute() can be called after OCI_Desbribe() in order to execute the
 * statement, which means that the server will parse, and describe again the SQL
 * order.
 *
 * @warning
 * Do not use OCI_Desbribe() unless you're only interested in the resultset
 * information because the statement will be parsed again when executed and thus
 * leading to unnecessary server round-trips and less performance
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_Describe(stmt: *mut OCI_Statement, sql: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the last SQL or PL/SQL statement prepared or executed by the statement
 *
 * @param stmt - Statement handle
 *
 */
    pub fn OCI_GetSql(stmt: *mut OCI_Statement) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the error position (in terms of characters) in the SQL statement
 * where the error occurred in case of SQL parsing error
 *
 * @param stmt - Statement handle
 *
 * @note
 * Positions start at 1.
 *
 */
    pub fn OCI_GetSqlErrorPos(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the number of rows affected by the SQL statement
 *
 * @param stmt - Statement handle
 *
 * The returned value is :
 *  - For UPDATEs : number of rows updated
 *  - For INSERTs : number of rows inserted
 *  - For DELETEs : number of rows deleted
 *
 * @note
 * For SELECTs  statements, use OCI_GetRowCount() instead
 *
 * @note
 * For PL/SQL blocks performing "select into :<bind>":
 *  - it returns the number of rows selected from PL/SQL
 *  - Up to version 4.3.0, OCI_Execute() returned FALSE and generated an error ORA-01403 - "No Data Found"
 *  - From version 4.3.1, OCI_Execute() returns 0 if no data found, otherwise the number of selected rows
 *
 */
    pub fn OCI_GetAffectedRows(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the Oracle SQL code the command held by the statement handle
 *
 * @param stmt - Statement handle
 *
 * @warning
 * OCI_GetSQLCommand() must be called after the statement has be executed
 * because that's the server engine that computes the SQL command code
 *
 * @return
 * The SQL command code of the statement otherwise OCI_UNKOWN
 */
    pub fn OCI_GetSQLCommand(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the verb of the SQL command held by the statement handle
 *
 * @param stmt - Statement handle
 *
 * @warning
 * OCI_GetSQLVerb() must be called after the statement has been executed
 * because that's the server engine that computes the SQL verb
 *
 * @note
 * The SQL verb list is available in Oracle documentations and guides
 *
 * @return
 * The SQL command verb of the statement otherwise NULL
 */
    pub fn OCI_GetSQLVerb(stmt: *mut OCI_Statement) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Set the input array size for bulk operations
 *
 * @param stmt - Statement handle
 * @param size - Array size
 *
 * @warning
 * Do not use OCI_BindArraySetSize() for PL/SQL tables binding
 *
 * @note
 * OCI_BindArraySetSize() is used to set the size of input bind array when using
 * arrays for DML statements.
 * OCI_BindArraySetSize() MUST be called to set the maximum size of the arrays
 * to bind to the statement before any of its execution. This initial call must
 * be bone AFTER OCI_Prepare() and BEFORE any OCI_BindArrayOfxxx() call.
 *
 * @note
 * OCI_BindArraySetSize() can optionally be called before any later OCI_Execute()
 * call in order to notify the statement of the exact number of elements
 * populating the input arrays for the next execution. The array size passed to
 * later OCI_BindArraySetSize() calls cannot be greater than the initial size
 * otherwise an exception will be thrown.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_BindArraySetSize(stmt: *mut OCI_Statement,
                                size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the current input array size for bulk operations
 *
 * @param stmt - Statement handle
 *
 * @return
 * Array size value or 0 if OCI_BindArraySetSize() has not been called
 *
 */
    pub fn OCI_BindArrayGetSize(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Allow different host variables to be binded using the same bind name or
 * position between executions of a prepared statement
 *
 * @param stmt  - Statement handle
 * @param value - Rebinding mode allowed
 *
 * @note
 * Default value is FALSE
 *
 * @warning
 * When using rebinding feature, host variable re-binded to a previously allocated
 * bind MUST be of the same data type !
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_AllowRebinding(stmt: *mut OCI_Statement,
                              value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Indicate if rebinding is allowed on the given statement
 *
 * @param stmt - Statement handle
 *
 * @note
 * See OCI_AllowRebinding() for more details
 *
 * @return
 * TRUE if allowed otherwise FALSE
 */
    pub fn OCI_IsRebindingAllowed(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Bind a boolean variable (PL/SQL ONLY)
*
* @param stmt - Statement handle
* @param name - Variable name
* @param data - Pointer to boolean variable
*
* @note
* parameter 'data' can NULL if the statement bind allocation mode
* has been set to OCI_BAM_INTERNAL
*
* @warning
* - OCI_BindBoolean() CAN ONLY BE USED for PL/SQL boolean type when calling PL/SQL procedures/function
* - ONLY supported by Oracle 12c and above !
*
* @return
* TRUE on success otherwise FALSE
*/
    pub fn OCI_BindBoolean(stmt: *mut OCI_Statement, name: *const otext,
                           data: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Bind an Number variable
*
* @param stmt - Statement handle
* @param name - Variable name
* @param data - Pointer to short variable
*
* @note
* parameter 'data' can NULL if the statement bind allocation mode
* has been set to OCI_BAM_INTERNAL
*
* @return
* TRUE on success otherwise FALSE
*/
    pub fn OCI_BindNumber(stmt: *mut OCI_Statement, name: *const otext,
                          data: *mut OCI_Number) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Bind an array of Number
*
* @param stmt   - Statement handle
* @param name   - Variable name
* @param data   - Array of numbers
* @param nbelem - Number of element in the array (PL/SQL table only)
*
* @warning
* Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
* For regular DML array operations, pass the value 0.
*
* @note
* parameter 'data' can NULL if the statement bind allocation mode
* has been set to OCI_BAM_INTERNAL
*
* @return
* TRUE on success otherwise FALSE
*/
    pub fn OCI_BindArrayOfNumbers(stmt: *mut OCI_Statement,
                                  name: *const otext,
                                  data: *mut *mut OCI_Number,
                                  nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an short variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Pointer to short variable
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindShort(stmt: *mut OCI_Statement, name: *const otext,
                         data: *mut ::std::os::raw::c_short)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of shorts
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of shorts
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindArrayOfShorts(stmt: *mut OCI_Statement, name: *const otext,
                                 data: *mut ::std::os::raw::c_short,
                                 nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an unsigned short variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Pointer to unsigned short variable
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindUnsignedShort(stmt: *mut OCI_Statement, name: *const otext,
                                 data: *mut ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of unsigned shorts
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of unsigned shorts
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindArrayOfUnsignedShorts(stmt: *mut OCI_Statement,
                                         name: *const otext,
                                         data: *mut ::std::os::raw::c_ushort,
                                         nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an integer variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Pointer to int variable
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindInt(stmt: *mut OCI_Statement, name: *const otext,
                       data: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of integers
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of int
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindArrayOfInts(stmt: *mut OCI_Statement, name: *const otext,
                               data: *mut ::std::os::raw::c_int,
                               nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an unsigned integer variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Pointer to unsigned int variable
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindUnsignedInt(stmt: *mut OCI_Statement, name: *const otext,
                               data: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of unsigned integers
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of unsigned int
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindArrayOfUnsignedInts(stmt: *mut OCI_Statement,
                                       name: *const otext,
                                       data: *mut ::std::os::raw::c_uint,
                                       nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind a big integer variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Pointer to big int variable
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindBigInt(stmt: *mut OCI_Statement, name: *const otext,
                          data: *mut big_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of big integers
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of big int
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindArrayOfBigInts(stmt: *mut OCI_Statement,
                                  name: *const otext, data: *mut big_int,
                                  nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an unsigned big integer variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Pointer to unsigned big int variable
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindUnsignedBigInt(stmt: *mut OCI_Statement,
                                  name: *const otext, data: *mut big_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of unsigned big integers
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Array of unsigned big int
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindArrayOfUnsignedBigInts(stmt: *mut OCI_Statement,
                                          name: *const otext,
                                          data: *mut big_uint,
                                          nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind a string variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - String to bind
 * @param len  - Max length of the string (in character without
 *               the zero null terminal character)
 *
 * @note
 * if len == 0, len is set to the string size
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindString(stmt: *mut OCI_Statement, name: *const otext,
                          data: *mut otext, len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of strings
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of string
 * @param len    - Max length of a single string element (in character without
 *                 the zero null terminal character)
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @warning
 * if len <= 0, it returns FALSE
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindArrayOfStrings(stmt: *mut OCI_Statement,
                                  name: *const otext, data: *mut otext,
                                  len: ::std::os::raw::c_uint,
                                  nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind a raw buffer
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - buffer to bind
 * @param len  - Max length of the buffer
 *
 * @note
 * if len <= 0, it returns false
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindRaw(stmt: *mut OCI_Statement, name: *const otext,
                       data: *mut ::std::os::raw::c_void,
                       len: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of raw buffers
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of buffers
 * @param len    - Size in bytes on a single RAW array element
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * The buffer must be a contiguous block of data elements
 *
 * @note
 * If len <= 0, it returns FALSE
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindArrayOfRaws(stmt: *mut OCI_Statement, name: *const otext,
                               data: *mut ::std::os::raw::c_void,
                               len: ::std::os::raw::c_uint,
                               nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind a double variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Pointer to double variable
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindDouble(stmt: *mut OCI_Statement, name: *const otext,
                          data: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of doubles
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of double
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindArrayOfDoubles(stmt: *mut OCI_Statement,
                                  name: *const otext, data: *mut f64,
                                  nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind a float variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Pointer to float variable
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindFloat(stmt: *mut OCI_Statement, name: *const otext,
                         data: *mut f32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of floats
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of float
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindArrayOfFloats(stmt: *mut OCI_Statement, name: *const otext,
                                 data: *mut f32,
                                 nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind a date variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Date handle
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindDate(stmt: *mut OCI_Statement, name: *const otext,
                        data: *mut OCI_Date) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of dates
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of date handle
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindArrayOfDates(stmt: *mut OCI_Statement, name: *const otext,
                                data: *mut *mut OCI_Date,
                                nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind a timestamp variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Timestamp handle
 *
 * @note
 * parameter 'data' CANNOT be NULL whatever the statement bind allocation mode
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindTimestamp(stmt: *mut OCI_Statement, name: *const otext,
                             data: *mut OCI_Timestamp)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of timestamp handles
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of Timestamp handle
 * @param type   - Timestamp type
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * See OCI_TimestampCreate() for possible values of parameter 'type'
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindArrayOfTimestamps(stmt: *mut OCI_Statement,
                                     name: *const otext,
                                     data: *mut *mut OCI_Timestamp,
                                     type_: ::std::os::raw::c_uint,
                                     nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an interval variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Interval handle
 *
 * @note
 * parameter 'data' CANNOT be NULL whatever the statement bind allocation mode
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_BindInterval(stmt: *mut OCI_Statement, name: *const otext,
                            data: *mut OCI_Interval) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of interval handles
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of Interval handle
 * @param type   - Interval type
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * See OCI_IntervalCreate() for possible values of parameter 'type'
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_BindArrayOfIntervals(stmt: *mut OCI_Statement,
                                    name: *const otext,
                                    data: *mut *mut OCI_Interval,
                                    type_: ::std::os::raw::c_uint,
                                    nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind a Lob variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Lob handle
 *
 * @note
 * parameter 'data' CANNOT be NULL whatever the statement bind allocation mode
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindLob(stmt: *mut OCI_Statement, name: *const otext,
                       data: *mut OCI_Lob) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of Lob handles
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of Lob handle
 * @param type   - Lob type
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * See OCI_LobCreate() for possible values of parameter 'type'
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindArrayOfLobs(stmt: *mut OCI_Statement, name: *const otext,
                               data: *mut *mut OCI_Lob,
                               type_: ::std::os::raw::c_uint,
                               nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind a File variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - File handle
 *
 * @note
 * parameter 'data' CANNOT be NULL whatever the statement bind allocation mode
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindFile(stmt: *mut OCI_Statement, name: *const otext,
                        data: *mut OCI_File) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of File handles
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of File handle
 * @param type   - File type
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * See OCI_FileCreate() for possible values of parameter 'type'
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindArrayOfFiles(stmt: *mut OCI_Statement, name: *const otext,
                                data: *mut *mut OCI_File,
                                type_: ::std::os::raw::c_uint,
                                nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an object (named type) variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Object handle
 *
 * @note
 * parameter 'data' CANNOT be NULL whatever the statement bind allocation mode
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_BindObject(stmt: *mut OCI_Statement, name: *const otext,
                          data: *mut OCI_Object) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of object handles
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of object handle
 * @param typinf - type info handle
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_BindArrayOfObjects(stmt: *mut OCI_Statement,
                                  name: *const otext,
                                  data: *mut *mut OCI_Object,
                                  typinf: *mut OCI_TypeInfo,
                                  nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind a Collection variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Collection handle to bind
 *
 * @note
 * parameter 'data' CANNOT be NULL whatever the statement bind allocation mode
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindColl(stmt: *mut OCI_Statement, name: *const otext,
                        data: *mut OCI_Coll) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of Collection handles
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of Collection handle
 * @param typinf - Type info handle
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * See OCI_CollCreate() for possible values of parameter 'type'
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_BindArrayOfColls(stmt: *mut OCI_Statement, name: *const otext,
                                data: *mut *mut OCI_Coll,
                                typinf: *mut OCI_TypeInfo,
                                nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind a Ref variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Ref handle to bind
 *
 * @note
 * parameter 'data' CANNOT be NULL whatever the statement bind allocation mode
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindRef(stmt: *mut OCI_Statement, name: *const otext,
                       data: *mut OCI_Ref) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind an array of Ref handles
 *
 * @param stmt   - Statement handle
 * @param name   - Variable name
 * @param data   - Array of Ref handle
 * @param typinf - type info handle
 * @param nbelem - Number of element in the array (PL/SQL table only)
 *
 * @warning
 * Parameter 'nbelem' SHOULD ONLY be USED for PL/SQL tables.
 * For regular DML array operations, pass the value 0.
 *
 * @note
 * parameter 'data' can NULL if the statement bind allocation mode
 * has been set to OCI_BAM_INTERNAL
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_BindArrayOfRefs(stmt: *mut OCI_Statement, name: *const otext,
                               data: *mut *mut OCI_Ref,
                               typinf: *mut OCI_TypeInfo,
                               nbelem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind a Statement variable (PL/SQL Ref Cursor)
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Statement handle to bind
 *
 * @note
 * parameter 'data' CANNOT be NULL whatever the statement bind allocation mode
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindStatement(stmt: *mut OCI_Statement, name: *const otext,
                             data: *mut OCI_Statement)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Bind a Long variable
 *
 * @param stmt - Statement handle
 * @param name - Variable name
 * @param data - Long handle
 * @param size - Size of the long buffer in bytes or characters
 *
 * @note
 * Size is expressed in:
 * - Bytes for BLONGs
 * - Characters for CLONGs
 *
 * @note
 * parameter 'data' CANNOT be NULL whatever the statement bind allocation mode
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindLong(stmt: *mut OCI_Statement, name: *const otext,
                        data: *mut OCI_Long, size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Returns the first or next error that occurred within a DML array statement execution
 *
 * @param stmt - Statement handle
 *
 * @return
 * The first or next error handle otherwise NULL
 */
    pub fn OCI_GetBatchError(stmt: *mut OCI_Statement) -> *mut OCI_Error;
}
extern "C" {
    /**
 * @brief
 * Returns the number of errors that occurred within the last DML array statement
 *
 * @param stmt - Statement handle
 *
 */
    pub fn OCI_GetBatchErrorCount(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the number of binds currently associated to a statement
 *
 * @param stmt - Statement handle
 *
 */
    pub fn OCI_GetBindCount(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the bind handle at the given index in the internal array of bind
 * handle
 *
 * @param stmt  - Statement handle
 * @param index - Bind position
 *
 * @note
 * Index starts at 1.
 *
 * @note
 * Bind handle are created sequentially. For example, the third call to a
 * OCI_BindXXX() generates a bind handle of index 3.
 *
 * @return
 * The bind handle or NULL if index is out of bounds
 *
 */
    pub fn OCI_GetBind(stmt: *mut OCI_Statement,
                       index: ::std::os::raw::c_uint) -> *mut OCI_Bind;
}
extern "C" {
    /**
 * @brief
 * Return a bind handle from its name
 *
 * @param stmt - Statement handle
 * @param name - Bind variable name
 *
 * @note
 * Bind names must include a semicolon at the beginning.
 *
 * @return
 * The bind handle or NULL if not found
 *
 */
    pub fn OCI_GetBind2(stmt: *mut OCI_Statement, name: *const otext)
     -> *mut OCI_Bind;
}
extern "C" {
    /**
* @brief
* Return the index of the bind  from its name belonging to the given statement
*
* @param stmt - Statement handle
* @param name - Bind variable name
*
* @warning
* The bind name is case insensitive
*
* @note
* Bind indexes start with 1 in OCILIB
*
* @return
* Bind index on success or zero if the bind does not exists or if statement is NULL
*
*/
    pub fn OCI_GetBindIndex(stmt: *mut OCI_Statement, name: *const otext)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the name of the given bind
 *
 * @param bnd - Bind handle
 *
 */
    pub fn OCI_BindGetName(bnd: *mut OCI_Bind) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Set the direction mode of a bind handle
 *
 * @param bnd       - Bind handle
 * @param direction - direction mode
 *
 * @note
 * Possible values for parameter 'direction' :
 *   - OCI_BDM_IN      : input values  (not modified by the server)
 *   - OCI_BDM_OUT     : output values (modified by the server)
 *   - OCI_BDM_IN_OUT  : input and output values
 *
 * @note
 * Default value is OCI_BDM_IN_OUT
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_BindSetDirection(bnd: *mut OCI_Bind,
                                direction: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the direction mode of a bind handle
 *
 * @param bnd - Bind handle
 *
 * @note
 * see OCI_BindSetDirection() for more details
 *
 * return the bind direction mode on success otherwise OCI_UNKNWON
 *
 */
    pub fn OCI_BindGetDirection(bnd: *mut OCI_Bind) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the OCILIB type of the given bind
 *
 * @param bnd - Bind handle
 *
 * @note
 * Possible values are :
 *
 * - OCI_CDT_NUMERIC     : short, int, long long, float, double
 * - OCI_CDT_DATETIME    : OCI_Date *
 * - OCI_CDT_TEXT        : otext *
 * - OCI_CDT_LONG        : OCI_Long *
 * - OCI_CDT_CURSOR      : OCI_Statement *
 * - OCI_CDT_LOB         : OCI_Lob  *
 * - OCI_CDT_FILE        : OCI_File *
 * - OCI_CDT_TIMESTAMP   : OCI_Timestamp *
 * - OCI_CDT_INTERVAL    : OCI_Interval *
 * - OCI_CDT_RAW         : void *
 * - OCI_CDT_OBJECT      : OCI_Object *
 * - OCI_CDT_COLLECTION  : OCI_Coll *
 * - OCI_CDT_REF         : OCI_Ref *
 * - OCI_CDT_BOOLEAN     : boolean
 *
 * @return
 * The column type or OCI_CDT_UNKNOWN on error
 *
 */
    pub fn OCI_BindGetType(bnd: *mut OCI_Bind) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the OCILIB object subtype of the given bind
 *
 * @param bnd - Bind handle
 *
 * @note
 * * This call is valid for the following OCILIB types:
 * - OCI_CDT_NUMERIC
 * - OCI_CDT_LONG
 * - OCI_CDT_LOB
 * - OCI_CDT_FILE
 * - OCI_CDT_TIMESTAMP
 * - OCI_CDT_INTERVAL
 *
 * For numeric binds the possible values are:
 * - OCI_NUM_SHORT
 * - OCI_NUM_INT
 * - OCI_NUM_BIGINT
 * - OCI_NUM_USHORT
 * - OCI_NUM_UINT
 * - OCI_NUM_BIGUINT
 * - OCI_NUM_DOUBLE
 * - OCI_NUM_FLOAT
 *
 * For OCI_Long type the possible values are:
 * - OCI_BLONG
 * - OCI_CLONG
 *
 * For OCI_Lob type the possible values are:
 * - OCI_BLOB
 * - OCI_CLOB
 * - OCI_NCLOB
 *
 * For OCI_File type the possible values are:
 * - OCI_BFILE
 * - OCI_CFILE
 *
 * For OCI_Timestamp type the possible values are:
 * - OCI_TIMESTAMP
 * - OCI_TIMESTAMP_TZ
 * - OCI_TIMESTAMP_LTZ
 *
 * For OCI_Interval type the possible values are:
 * - OCI_INTERVAL_YM
 * - OCI_INTERVAL_DS
 *
 * @note
 * For all other OCILIB types, it returns OCI_UNKNOWN
 *
 */
    pub fn OCI_BindGetSubtype(bnd: *mut OCI_Bind) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the number of elements of the bind handle
 *
 * @param bnd - Bind handle
 *
 * @return
 * - For single binds, it returns 1
 * - For array binds, it returns the number of element in the array
 *
 */
    pub fn OCI_BindGetDataCount(bnd: *mut OCI_Bind) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the user defined data associated with a bind handle
 *
 * @param bnd - Bind handle
 *
 * @return
 * - The pointer to variable/array passed to an OCI_BindXXX() or
 *   OCI_BindArrayOfXXX() call
 *
 */
    pub fn OCI_BindGetData(bnd: *mut OCI_Bind) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return the statement handle associated with a bind handle
 *
 * @param bnd - bind handle
 *
 */
    pub fn OCI_BindGetStatement(bnd: *mut OCI_Bind) -> *mut OCI_Statement;
}
extern "C" {
    /**
 * @brief
 * Set the actual size of the element held by the given bind handle
 *
 * @param bnd  - bind handle
 * @param size - data size
 *
 * @note
 * This call is not mandatory and should ONLY be called for RAWs binds to set
 * the real size of the given data if different from the expected column or
 * parameter size
 *
 * @note
 * It works as well with string based PL/SQL tables (in or in/out but NOT out)
 * even if it's not necessary.
 *
 * @warning
 * For binds of type OCI_CDT_TEXT (strings), the parameter 'size' is expressed in
 * number of characters.
 *
 * @return
 * Data size if the bind type is listed above otherwise 0.
 *
 */
    pub fn OCI_BindSetDataSize(bnd: *mut OCI_Bind,
                               size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the size of the element at the given position in
 * the bind input array
 *
 * @param bnd      - bind handle
 * @param position - Position in the array
 * @param size     - data size
 *
 * @note
 * See OCI_BindSetDataSize() for supported data types
 *
 * @warning
 * Before execution, it returns the max default size for the bind and not the real
 * data size, unless a custom size has been set with OCI_BindSetDataSizeXXX()
 * After execution, it returns the real data size.
 *
 * @warning
 * For binds of type OCI_CDT_TEXT (strings), the parameter 'size' is expressed in
 * number of characters.
 *
 * @return
 * Data size if the bind type is listed above otherwise 0.
 *
 */
    pub fn OCI_BindSetDataSizeAtPos(bnd: *mut OCI_Bind,
                                    position: ::std::os::raw::c_uint,
                                    size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the actual size of the element held by the given bind handle
 *
 * @param bnd - bind handle
 *
 * @note
 * See OCI_BindSetDataSize() for supported data types
 *
 * @warning
 * For binds of type OCI_CDT_TEXT (strings), the returned value is expressed in
 * number of characters.
 *
 */
    pub fn OCI_BindGetDataSize(bnd: *mut OCI_Bind) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the actual size of the element at the given position in
 * the bind input array
 *
 * @param bnd      - bind handle
 * @param position - Position in the array
 *
 * @note
 * See OCI_BindSetDataSize() for supported data types
 *
 * @warning
 * For binds of type OCI_CDT_TEXT (strings), the returned value is expressed in
 * number of characters.
 *
 */
    pub fn OCI_BindGetDataSizeAtPos(bnd: *mut OCI_Bind,
                                    position: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set the bind variable to null
 *
 * @param bnd   - Bind handle
 *
 * @note
 * There is no notion of null value in C.
 * It's necessary to explicitly tell Oracle that the bind has a null value.
 * It must be done before an OCI_Execute() call
 *
 * @note
 * For handled based data types (non scalar types), OCILIB performs an extra
 * check on handles and set the bind status to null is the handle is null
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindSetNull(bnd: *mut OCI_Bind) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set to null the entry in the bind variable input array
 *
 * @param bnd      - Bind handle
 * @param position - Position in the array
 *
 * @note
 * There is no notion of null value in C.
 * It's necessary to explicitly tell Oracle that the bind has a null value.
 * It must be done before an OCI_Execute() call
 *
 * @warning
 * Position starts with 1
 *
 * @note
 * For handled based data types (non scalar types), OCILIB performs an extra
 * check on handles and set the bind status to null is the handle is null
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindSetNullAtPos(bnd: *mut OCI_Bind,
                                position: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the bind variable to NOT null
 *
 * @param bnd   - Bind handle
 *
 * @note
 * There is no notion of null value in C.
 * It's necessary to explicitly tell Oracle that the bind has a null value.
 * It must be done before an OCI_Execute() call
 *
 * @note
 * For handled based data types (non scalar types), OCILIB performs an extra
 * check on handles and set the bind status to null is the handle is null
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindSetNotNull(bnd: *mut OCI_Bind) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set to NOT null the entry in the bind variable input array
 *
 * @param bnd      - Bind handle
 * @param position - Position in the array
 *
 * @note
 * There is no notion of null value in C.
 * It's necessary to explicitly tell Oracle that the bind has a null value.
 * It must be done before an OCI_Execute() call
 *
 * @warning
 * Position starts with 1
 *
 * @note
 * For handled based data  types (non scalar types), OCILIB performs an extra
 * check on handles and set the bind status to null is the handle is null
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_BindSetNotNullAtPos(bnd: *mut OCI_Bind,
                                   position: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Check if the current value of the binded variable is marked as NULL
 *
 * @param bnd - Bind handle
 *
 * @return
 * TRUE if it's null otherwise FALSE
 *
 */
    pub fn OCI_BindIsNull(bnd: *mut OCI_Bind) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Check if the current entry value at the given index of the binded array
 * is marked as NULL
 *
 * @param bnd      - Bind handle
 * @param position - Position in the array
 *
 * @warning
 * Position starts with 1
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_BindIsNullAtPos(bnd: *mut OCI_Bind,
                               position: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the charset form of the given character based bind variable
 *
 * @param bnd   - Bind handle
 * @param csfrm - charset form
 *
 * @note
 * Possible values are :
 *
 * - OCI_CSF_DEFAULT : the column has default charset
 * - OCI_CSF_NATIONAL: the column has national charset
 *
 * @note
 * This call has to be made after OCI_Prepare() but before OCI_Execute()
 *
 * @warning
 * This call does nothing :
 *  - if the csform is out of range
 *  - if the bind type is not OCI_CFT_TEXT or OCI_CDT_LONG
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_BindSetCharsetForm(bnd: *mut OCI_Bind,
                                  csfrm: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Retrieve the resultset handle from an executed statement
 *
 * @param stmt - Statement handle
 *
 * @note
 * See @ref OcilibCApiFetching for more details about what statements can return resultsets
 *
 * @warning
 * If the statement has not been prepared and executed, no resultset will be  returned
 *
 * @return
 * A resultset handle on success otherwise NULL
 *
 */
    pub fn OCI_GetResultset(stmt: *mut OCI_Statement) -> *mut OCI_Resultset;
}
extern "C" {
    /**
 * @brief
 * Free the statement resultsets
 *
 * @param stmt - Statement handle
 *
 * @note
 * This call is optional. Resultsets are automatically freed when the
 * statement is destroyed or when it's reused.
 *
 * @note
 * This function has been introduced for releasing big resultsets when the
 * application wants to keep the statement alive and doesn't know when it
 * will be destroyed.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ReleaseResultsets(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Fetch the next row of the resultset
 *
 * @param rs - Resultset handle
 *
 * @note
 * OCI_FetchNext() works for normal and scrollable resultsets
 *
 * @return
 * TRUE on success otherwise FALSE if :
 * - Empty resultset
 * - Last row already fetched
 * - An error occurred
 *
 */
    pub fn OCI_FetchNext(rs: *mut OCI_Resultset) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Fetch the previous row of the resultset
 *
 * @param rs - Resultset handle
 *
 * @note
 * OCI_FetchPrev() works ONLY for scrollable resultsets
 *
 * @return
 * TRUE on success otherwise FALSE if :
 * - Empty resultset
 * - First row already fetched
 * - An error occurred
 *
 */
    pub fn OCI_FetchPrev(rs: *mut OCI_Resultset) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Fetch the first row of the resultset
 *
 * @param rs - Resultset handle
 *
 * @note
 * OCI_FetchFirst() works ONLY for scrollable resultsets
 *
 * @return
 * TRUE on success otherwise FALSE if :
 * - Empty resultset
 * - An error occurred
 *f
 */
    pub fn OCI_FetchFirst(rs: *mut OCI_Resultset) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Fetch the last row of the resultset
 *
 * @param rs - Resultset handle
 *
 * @note
 * OCI_FetchLast() works ONLY for scrollable resultsets
 *
 * @return
 * TRUE on success otherwise FALSE if:
 * - Empty resultset
 * - An error occurred
 *
 */
    pub fn OCI_FetchLast(rs: *mut OCI_Resultset) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Custom Fetch of the resultset
 *
 * @param rs      - Resultset handle
 * @param mode    - Fetch direction
 * @param offset  - Fetch offset
 *
 * @note
 * Possible values for 'direction' parameter are:
 *  - OCI_SFD_ABSOLUTE
 *  - OCI_SFD_RELATIVE
 *
 * @note
 * OCI_FetchSeek() works ONLY for scrollable resultsets
 *
 * @warning
 * If you intend to use OCI_FetchSeek() on a scrollable statement and if any of the
 * selected columns is a ref cursor or a nested table, you must set the fetching size
 * to 1 using OCI_SetFetchSize() before calling OCI_GetResultset()
 * Otherwise OCI_FetchSeek() will fails with a OCI-10002 error
 *
 * @return
 * TRUE on success otherwise FALSE if:
 * - Empty resultset
 * - An error occurred
 * - OCI_SetFetchMode() has not been called with OCI_SFM_SCROLLABLE
 *
 */
    pub fn OCI_FetchSeek(rs: *mut OCI_Resultset, mode: ::std::os::raw::c_uint,
                         offset: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Retrieve the number of rows fetched so far
 *
 * @param rs - Resultset handle
 *
 */
    pub fn OCI_GetRowCount(rs: *mut OCI_Resultset) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Retrieve the current row number
 *
 * @param rs - Resultset handle
 *
 * @note
 * - OCI_GetCurrentRow() returns the current row number starting from 1
 * - If the resultset has not been fetched or if the resultset is empty, it returns 0
 * - If the resultset has been fully fetched, it returns the last fetched row number
 *
 */
    pub fn OCI_GetCurrentRow(rs: *mut OCI_Resultset)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the number of columns in the resultset
 *
 * @param rs - Resultset handle
 *
 */
    pub fn OCI_GetColumnCount(rs: *mut OCI_Resultset)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the column object handle at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @return
 * - Column handle on success
 * - NULL if index is out of bounds or on error
 *
 */
    pub fn OCI_GetColumn(rs: *mut OCI_Resultset,
                         index: ::std::os::raw::c_uint) -> *mut OCI_Column;
}
extern "C" {
    /**
 * @brief
 * Return the column object handle from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @note
 * The column name is case insensitive
 *
 * @return
 * - Column handle on success or
 * - NULL if no column found with the given name or on error
 *
 */
    pub fn OCI_GetColumn2(rs: *mut OCI_Resultset, name: *const otext)
     -> *mut OCI_Column;
}
extern "C" {
    /**
 * @brief
 * Return the index of the column in the result from its name
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @note
 * The column name is case insensitive
 *
 * @note
 * Column indexes start with 1 in OCILIB
 *
 * @return
 * Column index on success or zero on error
 *
 */
    pub fn OCI_GetColumnIndex(rs: *mut OCI_Resultset, name: *const otext)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the name of the given column
 *
 * @param col   - Column handle
 *
 */
    pub fn OCI_ColumnGetName(col: *mut OCI_Column) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the type of the given column
 *
 * @param col   - Column handle
 *
 * @note
 * Possible values are :
 *
 * - OCI_CDT_NUMERIC     : short, int, long long, float, double
 * - OCI_CDT_DATETIME    : OCI_Date *
 * - OCI_CDT_TEXT        : otext *
 * - OCI_CDT_LONG        : OCI_Long *
 * - OCI_CDT_CURSOR      : OCI_Statement *
 * - OCI_CDT_LOB         : OCI_Lob  *
 * - OCI_CDT_FILE        : OCI_File *
 * - OCI_CDT_TIMESTAMP   : OCI_Timestamp *
 * - OCI_CDT_INTERVAL    : OCI_Interval *
 * - OCI_CDT_RAW         : void *
 * - OCI_CDT_OBJECT      : OCI_Object *
 * - OCI_CDT_COLLECTION  : OCI_Coll *
 * - OCI_CDT_REF         : OCI_Ref *
 * - OCI_CDT_BOOLEAN     : boolean
 *
 * @return
 * The column type or OCI_CDT_UNKNOWN if index is out of bounds
 *
 */
    pub fn OCI_ColumnGetType(col: *mut OCI_Column) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the charset form of the given column
 *
 * @param col   - Column handle
 *
 * @note
 * Possible values are :
 * - OCI_CSF_NONE     : the column is not an character or lob column
 * - OCI_CSF_DEFAULT  : the column has server default charset
 * - OCI_CSF_NATIONAL : the column has national server charset
 *
 */
    pub fn OCI_ColumnGetCharsetForm(col: *mut OCI_Column)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the Oracle SQL type name of the column data type
 *
 * @param col   - Column handle
 *
 * @note
 * For possible values, consults Oracle Documentation
 *
 */
    pub fn OCI_ColumnGetSQLType(col: *mut OCI_Column) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the Oracle SQL Full name including precision and size of the
 * column data type
 *
 * @param col    - Column handle
 * @param buffer - buffer to store the full column type name and size
 * @param len    - max size of the buffer in characters
 *
 * @note
 * This function returns a description that matches the one given by SQL*Plus
 *
 * @note
 * Return the number of characters written into the buffer
 *
 */
    pub fn OCI_ColumnGetFullSQLType(col: *mut OCI_Column, buffer: *mut otext,
                                    len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the size of the column
 *
 * @note
 * For all types, the size is expressed is bytes, excepted for character
 * based columns that were created with a character based size or of type NCHAR/NVARCHAR
 *
 * @param col   - Column handle
 *
 */
    pub fn OCI_ColumnGetSize(col: *mut OCI_Column) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the scale of the column for numeric columns
 *
 * @param col   - Column handle
 *
 */
    pub fn OCI_ColumnGetScale(col: *mut OCI_Column) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the precision of the column for numeric columns
 *
 * @param col   - Column handle
 *
 */
    pub fn OCI_ColumnGetPrecision(col: *mut OCI_Column)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the fractional precision of the column for timestamp and interval columns
 *
 * @param col   - Column handle
 *
 */
    pub fn OCI_ColumnGetFractionalPrecision(col: *mut OCI_Column)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the leading precision of the column for interval columns
 *
 * @param col   - Column handle
 *
 */
    pub fn OCI_ColumnGetLeadingPrecision(col: *mut OCI_Column)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the nullable attribute of the column
 *
 * @param col   - Column handle
 *
 * @return
 * Return TRUE if the column is nullable otherwise FALSE
 *
 */
    pub fn OCI_ColumnGetNullable(col: *mut OCI_Column)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return TRUE if the length of the column is character-length or  FALSE if
 * it is byte-length
 *
 * @param col - Column handle
 *
 * @note
 * This was introduced in Oracle 9i. So for version that are not supporting this
 * property, it always return FALSE
 *
 */
    pub fn OCI_ColumnGetCharUsed(col: *mut OCI_Column)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the column property flags
 *
 * @param col - Column handle
 *
 * For flags are:
 * - OCI_CPF_NONE : The column has no flags or the OCI client does not support this call
 * - OCI_CPF_IS_IDENTITY :
 *      - If Set, the column is an IDENTITY column
 *      - Otherwise, it is not an IDENTITY column
 * - OCI_CPF_IS_GEN_ALWAYS (only if OCI_CPF_IS_IDENTITY is set) :
 *      - If set, means that the value is "ALWAYS GENERATED"
 *      - Otherwise mens that the value is "GENERATED BY"
 * - OCI_CPF_IS_GEN_BY_DEFAULT_ON_NULL (only if OCI_CPF_IS_IDENTITY is set):
 *      - If set, means that the value is generated by default on NULL
 *
 * @note
 * This was introduced in Oracle 12cR1.
 * It is currently used for identifying Identity columns.
 * For earlier versions, it always return OCI_CPF_NONE
 *
 */
    pub fn OCI_ColumnGetPropertyFlags(col: *mut OCI_Column)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the type information object associated to the column
 *
 * @param col - Column handle
 *
 * @note
 * This call is used only for Named Object typed and collection columns.
 * It returns NULL if the column is not a Named Object or a collection.
 *
 */
    pub fn OCI_ColumnGetTypeInfo(col: *mut OCI_Column) -> *mut OCI_TypeInfo;
}
extern "C" {
    /**
 * @brief
 * Return the OCILIB object subtype of a column
 *
 * @param col - Column handle
 *
 * @note
 * This call is valid for the following OCILIB types:
 *
 * - OCI_CDT_LONG
 * - OCI_CDT_LOB
 * - OCI_CDT_FILE
 * - OCI_CDT_TIMESTAMP
 * - OCI_CDT_INTERVAL
 *
 * For OCI_Long type the possible values are:
 * - OCI_BLONG
 * - OCI_CLONG
 *
 * For OCI_Lob type the possible values are:
 * - OCI_BLOB
 * - OCI_CLOB
 * - OCI_NCLOB
 *
 * For OCI_File type the possible values are:
 * - OCI_BFILE
 * - OCI_CFILE
 *
 * For OCI_Timestamp type the possible values are:
 * - OCI_TIMESTAMP
 * - OCI_TIMESTAMP_TZ
 * - OCI_TIMESTAMP_LTZ
 *
 * For OCI_Interval type the possible values are:
 * - OCI_INTERVAL_YM
 * - OCI_INTERVAL_DS
 *
 * @note
 * For all other OCILIB types, it returns OCI_UNKNOWN
 *
 */
    pub fn OCI_ColumnGetSubType(col: *mut OCI_Column)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * set the numeric data type of the given structure member (identified from position in the
 * resultset)  to retrieve when calling OCI_GetStruct()
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 * @param type  - Numeric type
 *
 * @note
 * Possible values for parameter 'type' :
 * - OCI_NUM_SHORT
 * - OCI_NUM_USHORT
 * - OCI_NUM_INT
 * - OCI_NUM_UINT
 * - OCI_NUM_BIGINT
 * - OCI_NUM_BIGUINT
 * - OCI_NUM_DOUBLE
 * - OCI_NUM_FLOAT
 *
 * @return
 * Return TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SetStructNumericType(rs: *mut OCI_Resultset,
                                    index: ::std::os::raw::c_uint,
                                    type_: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * set the numeric data type of the given structure member (identified from column name in the
 * resultset)  to retrieve when calling OCI_GetStruct()
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 * @param type  - Numeric type
 *
 * @note
 * Possible values for parameter 'type' :
 *   - OCI_NUM_SHORT
 *   - OCI_NUM_USHORT
 *   - OCI_NUM_INT
 *   - OCI_NUM_UINT
 *   - OCI_NUM_BIGINT
 *   - OCI_NUM_BIGUINT
 *   - OCI_NUM_DOUBLE
 *   - OCI_NUM_FLOAT
 *
 * @return
 * Return TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SetStructNumericType2(rs: *mut OCI_Resultset,
                                     name: *const otext,
                                     type_: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the row columns values into a single structure
 *
 * @param rs              - Resultset handle
 * @param row_struct      - pointer to user row structure
 * @param row_struct_ind  - pointer to user indicator structure
 *
 * @note
 * Structure members values are contextual to the current row.
 * The returned values can get out of scope when the current row
 * changes when calling any OCI_FecthXXX() calls
 *
 * @par User row structure
 *
 * The user structure must have the same members than the resultset.
 * Each column in the resultset must have its equivalent in the structure.
 * Fields must be in the same order.
 *
 * The mapping rules are :
 *
 *   - LOBs (CLOB, NCLOB, BLOB) : OCI_Lob *
 *   - DATE : OCI_Date *
 *   - TIMESTAMPS : OCI_Timestamp *
 *   - INTERVALS : OCI_Interval *
 *   - LONG, LONG RAW : OCI_Long *
 *   - REFs : OCI_Ref *
 *   - CURSOR, RESULSET : OCI_Statement *
 *   - OBJECTS, UDT : OCI_Object *
 *   - Character columns (CHAR,VARCHAR, etc..) : otext *
 *   - All NUMERIC types :
 *        - default : big_int
 *        - user defined (see OCI_SetStructNumericType())
 *
 * The user structure pointer is not mandatory
 *
 * @par User row indicator structure

 * This structure must have one boolean field per column in
 * the resultset and respect in the same member order.
 *
 * If the value of the given member is TRUE, it means the value in
 * the user row structure is NOT NULL, otherwise its NULL
 *
 * The user indicator structure pointer is  mandatory
 *
 * @return
 * Return TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_GetStruct(rs: *mut OCI_Resultset,
                         row_struct: *mut ::std::os::raw::c_void,
                         row_struct_ind: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Return the current Number value of the column at the given index in the resultset
*
* @param rs    - Resultset handle
* @param index - Column position
*
* @note
* Column position starts at 1.
*
* @return
* The column current row value or 0 if index is out of bounds
*
*/
    pub fn OCI_GetNumber(rs: *mut OCI_Resultset,
                         index: ::std::os::raw::c_uint) -> *mut OCI_Number;
}
extern "C" {
    /**
* @brief
* Return the current number value of the column from its name in the resultset
*
* @param rs    - Resultset handle
* @param name  - Column name
*
* @note
* The column name is case insensitive
*
* @return
* The column current row value or 0 if no column found with the given name
*
*/
    pub fn OCI_GetNumber2(rs: *mut OCI_Resultset, name: *const otext)
     -> *mut OCI_Number;
}
extern "C" {
    /**
 * @brief
 * Return the current short value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or 0 if index is out of bounds
 *
 */
    pub fn OCI_GetShort(rs: *mut OCI_Resultset, index: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_short;
}
extern "C" {
    /**
 * @brief
 * Return the current short value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @note
 * The column name is case insensitive
 *
 * @return
 * The column current row value or 0 if no column found with the given name
 *
 */
    pub fn OCI_GetShort2(rs: *mut OCI_Resultset, name: *const otext)
     -> ::std::os::raw::c_short;
}
extern "C" {
    /**
 * @brief
 * Return the current unsigned short value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or 0 if index is out of bounds
 *
 */
    pub fn OCI_GetUnsignedShort(rs: *mut OCI_Resultset,
                                index: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_ushort;
}
extern "C" {
    /**
 * @brief
 * Return the current unsigned short value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @note
 * The column name is case insensitive
 *
 * @return
 * The column current row value or 0 if no column found with the given name
 *
 */
    pub fn OCI_GetUnsignedShort2(rs: *mut OCI_Resultset, name: *const otext)
     -> ::std::os::raw::c_ushort;
}
extern "C" {
    /**
 * @brief
 * Return the current integer value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or 0 if index is out of bounds
 *
 */
    pub fn OCI_GetInt(rs: *mut OCI_Resultset, index: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the current integer value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @note
 * The column name is case insensitive
 *
 * @return
 * The column current row value or 0 if no column found with the given name
 *
 */
    pub fn OCI_GetInt2(rs: *mut OCI_Resultset, name: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the current unsigned integer value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or 0 if index is out of bounds
 *
 */
    pub fn OCI_GetUnsignedInt(rs: *mut OCI_Resultset,
                              index: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the current unsigned integer value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @note
 * The column name is case insensitive
 *
 * @return
 * The column current row value or 0 if no column found with the given name
 *
 */
    pub fn OCI_GetUnsignedInt2(rs: *mut OCI_Resultset, name: *const otext)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the current big integer value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or 0 if index is out of bounds
 *
 */
    pub fn OCI_GetBigInt(rs: *mut OCI_Resultset,
                         index: ::std::os::raw::c_uint) -> big_int;
}
extern "C" {
    /**
 * @brief
 * Return the current big integer value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @note
 * The column name is case insensitive
 *
 * @return
 * The column current row value or 0 if no column found with the given name
 *
 */
    pub fn OCI_GetBigInt2(rs: *mut OCI_Resultset, name: *const otext)
     -> big_int;
}
extern "C" {
    /**
 * @brief
 * Return the current unsigned big integer value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or 0 if index is out of bounds
 *
 */
    pub fn OCI_GetUnsignedBigInt(rs: *mut OCI_Resultset,
                                 index: ::std::os::raw::c_uint) -> big_uint;
}
extern "C" {
    /**
 * @brief
 * Return the current unsigned big integer value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @note
 * The column name is case insensitive
 *
 * @return
 * The column current row value or 0 if no column found with the given name
 *
 */
    pub fn OCI_GetUnsignedBigInt2(rs: *mut OCI_Resultset, name: *const otext)
     -> big_uint;
}
extern "C" {
    /**
 * @brief
 * Return the current string value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @note
 * OCI_GetString() performs an implicit conversion from  the
 * following data types:
 *
 * - Numerics (based on the current connection handle numeric format)
 * - Binary doubles and floats (using the standard C Library functions)
 * - OCI_Number (based on the current connection handle numeric format)
 * - OCI_Date (based on the current connection handle date format)
 * - OCI_Timestamp (based on the current connection handle date format)
 * - OCI_Interval (based on Oracle default conversion)
 * - OCI_Lob (for BLOBs, output is expressed in hexadecimal)
 * - OCI_Long  (for BLONGs, output is expressed in hexadecimal)
 * - OCI_File ("[directory]/[name]" will be output)
 * - OCI_Object (Textual SQL string representation)
 * - OCI_Coll (Textual SQL string representation)
 * - RAW buffer (expressed in hexadecimal)
 * - OCI_Statement (SQL statement string or cursor name)
 *
 * @return
 * The column current row value or NULL if index is out of bounds
 *
 */
    pub fn OCI_GetString(rs: *mut OCI_Resultset,
                         index: ::std::os::raw::c_uint) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the current string value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @note
 * The column name is case insensitive
 *
 * @return
 * The column current row value or NULL if no column found with the given name
 *
 */
    pub fn OCI_GetString2(rs: *mut OCI_Resultset, name: *const otext)
     -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Copy the current raw value of the column at the given index into the specified buffer
 *
 * @param rs     - Resultset handle
 * @param index  - Column position
 * @param buffer - Buffer that receive the raw value
 * @param len    - Max size of the input buffer in bytes
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * Number of bytes copied into the buffer on SUCCESS otherwise 0
 *
 */
    pub fn OCI_GetRaw(rs: *mut OCI_Resultset, index: ::std::os::raw::c_uint,
                      buffer: *mut ::std::os::raw::c_void,
                      len: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Copy the current raw value of the column from its name into the specified buffer
 *
 * @param rs     - Resultset handle
 * @param name   - Column name
 * @param buffer - Buffer that receive the raw value
 * @param len    - Max size of the input buffer
 *
 * @note
 * The column name is case insensitive
 *
 * @return
 * Number of bytes copied into the buffer on SUCCESS otherwise 0
 *
 */
    pub fn OCI_GetRaw2(rs: *mut OCI_Resultset, name: *const otext,
                       buffer: *mut ::std::os::raw::c_void,
                       len: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the current double value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or 0.O if index is out of bounds
 *
 */
    pub fn OCI_GetDouble(rs: *mut OCI_Resultset,
                         index: ::std::os::raw::c_uint) -> f64;
}
extern "C" {
    /**
 * @brief
 * Return the current double value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @note
 * The column name is case insensitive
 *
 * @return
 * The column current row value or 0.0 if no column found with the given name
 *
 */
    pub fn OCI_GetDouble2(rs: *mut OCI_Resultset, name: *const otext) -> f64;
}
extern "C" {
    /**
 * @brief
 * Return the current float value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or 0.O if index is out of bounds
 *
 */
    pub fn OCI_GetFloat(rs: *mut OCI_Resultset, index: ::std::os::raw::c_uint)
     -> f32;
}
extern "C" {
    /**
 * @brief
 * Return the current float value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @note
 * The column name is case insensitive
 *
 * @return
 * The column current row value or 0.0 if no column found with the given name
 *
 */
    pub fn OCI_GetFloat2(rs: *mut OCI_Resultset, name: *const otext) -> f32;
}
extern "C" {
    /**
 * @brief
 * Return the current date value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or NULL if index is out of bounds
 *
 */
    pub fn OCI_GetDate(rs: *mut OCI_Resultset, index: ::std::os::raw::c_uint)
     -> *mut OCI_Date;
}
extern "C" {
    /**
 * @brief
 * Return the current date value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @return
 * The column current row value or NULL if no column found with the given name
 *
 */
    pub fn OCI_GetDate2(rs: *mut OCI_Resultset, name: *const otext)
     -> *mut OCI_Date;
}
extern "C" {
    /**
 * @brief
 * Return the current timestamp value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or NULL if index is out of bounds
 *
 */
    pub fn OCI_GetTimestamp(rs: *mut OCI_Resultset,
                            index: ::std::os::raw::c_uint)
     -> *mut OCI_Timestamp;
}
extern "C" {
    /**
 * @brief
 * Return the current timestamp value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @return
 * The column current row value or NULL if no column found with the given name
 *
 */
    pub fn OCI_GetTimestamp2(rs: *mut OCI_Resultset, name: *const otext)
     -> *mut OCI_Timestamp;
}
extern "C" {
    /**
 * @brief
 * Return the current interval value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or NULL if index is out of bounds
 *
 */
    pub fn OCI_GetInterval(rs: *mut OCI_Resultset,
                           index: ::std::os::raw::c_uint)
     -> *mut OCI_Interval;
}
extern "C" {
    /**
 * @brief
 * Return the current interval value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @return
 * The column current row value or NULL if no column found with the given name
 *
 */
    pub fn OCI_GetInterval2(rs: *mut OCI_Resultset, name: *const otext)
     -> *mut OCI_Interval;
}
extern "C" {
    /**
 * @brief
 * Return the current cursor value (Nested table) of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or NULL if index is out of bounds
 *
 */
    pub fn OCI_GetStatement(rs: *mut OCI_Resultset,
                            index: ::std::os::raw::c_uint)
     -> *mut OCI_Statement;
}
extern "C" {
    /**
 * @brief
 * Return the current cursor value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @return
 * The column current row value or NULL if no column found with the given name
 *
 */
    pub fn OCI_GetStatement2(rs: *mut OCI_Resultset, name: *const otext)
     -> *mut OCI_Statement;
}
extern "C" {
    /**
 * @brief
 * Return the current lob value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or NULL if index is out of bounds
 *
 */
    pub fn OCI_GetLob(rs: *mut OCI_Resultset, index: ::std::os::raw::c_uint)
     -> *mut OCI_Lob;
}
extern "C" {
    /**
 * @brief
 * Return the current lob value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @return
 * The column current row value or NULL if no column found with the given name
 *
 */
    pub fn OCI_GetLob2(rs: *mut OCI_Resultset, name: *const otext)
     -> *mut OCI_Lob;
}
extern "C" {
    /**
 * @brief
 * Return the current File value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or NULL if index is out of bounds
 *
 */
    pub fn OCI_GetFile(rs: *mut OCI_Resultset, index: ::std::os::raw::c_uint)
     -> *mut OCI_File;
}
extern "C" {
    /**
 * @brief
 * Return the current File value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @return
 * The column current row value or NULL if no column found with the given name
 *
 */
    pub fn OCI_GetFile2(rs: *mut OCI_Resultset, name: *const otext)
     -> *mut OCI_File;
}
extern "C" {
    /**
 * @brief
 * Return the current Object value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or NULL if index is out of bounds
 *
 */
    pub fn OCI_GetObject(rs: *mut OCI_Resultset,
                         index: ::std::os::raw::c_uint) -> *mut OCI_Object;
}
extern "C" {
    /**
 * @brief
 * Return the current Object value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @return
 * The column current row value or NULL if no column found with the given name
 *
 */
    pub fn OCI_GetObject2(rs: *mut OCI_Resultset, name: *const otext)
     -> *mut OCI_Object;
}
extern "C" {
    /**
 * @brief
 * Return the current Collection value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or NULL if index is out of bounds
 *
 */
    pub fn OCI_GetColl(rs: *mut OCI_Resultset, index: ::std::os::raw::c_uint)
     -> *mut OCI_Coll;
}
extern "C" {
    /**
 * @brief
 * Return the current Collection value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @return
 * The column current row value or NULL if no column found with the given name
 *
 */
    pub fn OCI_GetColl2(rs: *mut OCI_Resultset, name: *const otext)
     -> *mut OCI_Coll;
}
extern "C" {
    /**
 * @brief
 * Return the current Ref value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or NULL if index is out of bounds
 *
 */
    pub fn OCI_GetRef(rs: *mut OCI_Resultset, index: ::std::os::raw::c_uint)
     -> *mut OCI_Ref;
}
extern "C" {
    /**
 * @brief
 * Return the current Ref value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @return
 * The column current row value or NULL if no column found with the given name
 *
 */
    pub fn OCI_GetRef2(rs: *mut OCI_Resultset, name: *const otext)
     -> *mut OCI_Ref;
}
extern "C" {
    /**
 * @brief
 * Return the current Long value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row value or NULL if index is out of bounds
 *
 */
    pub fn OCI_GetLong(rs: *mut OCI_Resultset, index: ::std::os::raw::c_uint)
     -> *mut OCI_Long;
}
extern "C" {
    /**
 * @brief
 * Return the current Long value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @return
 * The column current row value or NULL if no column found with the given name
 *
 */
    pub fn OCI_GetLong2(rs: *mut OCI_Resultset, name: *const otext)
     -> *mut OCI_Long;
}
extern "C" {
    /**
 * @brief
 * Check if the current row value is null for the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * TRUE if it's null otherwise FALSE
 *
 */
    pub fn OCI_IsNull(rs: *mut OCI_Resultset, index: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the size of the value of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @warning
 * For binds of type OCI_CDT_TEXT (strings), the returned value is expressed in
 * number of characters.
 *
 * @return value size of 0 if the value is NULL
 *
 */
    pub fn OCI_GetDataSize(rs: *mut OCI_Resultset,
                           index: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the size of the value of the column from its name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @warning
 * For binds of type OCI_CDT_TEXT (strings), the returned value is expressed in
 * number of characters.
 *
 * @return value size of 0 if the value is NULL
 *
 */
    pub fn OCI_GetDataSize2(rs: *mut OCI_Resultset, name: *const otext)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Check if the current row value is null for the column of the given name in the resultset
 *
 * @param rs    - Resultset handle
 * @param name  - Column name
 *
 * @return
 * TRUE if it's null otherwise FALSE
 *
 */
    pub fn OCI_IsNull2(rs: *mut OCI_Resultset, name: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the statement handle associated with a resultset handle
 *
 * @param rs - resultset handle
 *
 */
    pub fn OCI_ResultsetGetStatement(rs: *mut OCI_Resultset)
     -> *mut OCI_Statement;
}
extern "C" {
    /**
 * @brief
 * Return the current row data length of the column at the given index in the resultset
 *
 * @param rs    - Resultset handle
 * @param index - Column position
 *
 * @note
 * Column position starts at 1.
 *
 * @return
 * The column current row data length or 0 if index is out of bounds
 *
 */
    pub fn OCI_GetDataLength(rs: *mut OCI_Resultset,
                             index: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Enable the server output
 *
 * @param con     - Connection handle
 * @param bufsize - server buffer max size (server side)
 * @param arrsize - number of lines to retrieve per server round-trip
 * @param lnsize  - maximum size of one line
 *
 * @note
 * This call is equivalent to the command 'set serveroutput on' in SQL*PLUS
 *
 * @note
 * 'bufsize' minimum value is 2000, maximum 1000000 with Oracle < 10.2g and can be unlimited above
 *
 * @note
 * 'lnsize' maximum value is 255 with Oracle < 10g R2 and 32767 above
 *
 * @warning
 * If OCI_ServerEnableOutput() is not called, OCI_ServerGetOutput() will return NULL
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ServerEnableOutput(con: *mut OCI_Connection,
                                  bufsize: ::std::os::raw::c_uint,
                                  arrsize: ::std::os::raw::c_uint,
                                  lnsize: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Disable the server output
 *
 * @param con - Connection handle
 *
 * @note
 * After this call, OCI_ServerGetOutput() will return NULL.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ServerDisableOutput(con: *mut OCI_Connection)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Retrieve one line of the server buffer
 *
 * @param con   - Connection handle
 *
 * @note
 * Internally, OCILIB gets the server buffer through an array of lines in
 * order to minimize round-trips with the server
 *
 * @return
 * return a server output buffer line or NULL if the server buffer is empty
 *
 */
    pub fn OCI_ServerGetOutput(con: *mut OCI_Connection) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Create a local collection instance
 *
 * @param typinf - Type info handle of the collection type descriptor
 *
 * @return
 * Return the collection object handle on success otherwise NULL on failure
 *
 */
    pub fn OCI_CollCreate(typinf: *mut OCI_TypeInfo) -> *mut OCI_Coll;
}
extern "C" {
    /**
 * @brief
 * Free a local collection
 *
 * @param coll - Collection handle
 *
 * @warning
 * Only collection created with OCI_CollCreate() should be freed
 * by OCI_CollFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_CollFree(coll: *mut OCI_Coll) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create an array of Collection object
 *
 * @param con    - Connection handle
 * @param typinf - Object type (type info handle)
 * @param nbelem - number of elements in the array
 *
 * @note
 * see OCI_ObjectCreate() for more details
 *
 * @return
 * Return the Collection handle array on success otherwise NULL on failure
 *
 */
    pub fn OCI_CollArrayCreate(con: *mut OCI_Connection,
                               typinf: *mut OCI_TypeInfo,
                               nbelem: ::std::os::raw::c_uint)
     -> *mut *mut OCI_Coll;
}
extern "C" {
    /**
 * @brief
 * Free an array of Collection objects
 *
 * @param colls - Array of Collection objects
 *
 * @warning
 * Only arrays of Collection created with OCI_CollArrayCreate()
 * should be freed by OCI_CollArrayFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_CollArrayFree(colls: *mut *mut OCI_Coll)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Assign a collection to another one
 *
 * @param coll     - Destination Collection handle
 * @param coll_src - Source Collection handle
 *
 * @note
 * Oracle proceeds to a deep copy of the collection content
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_CollAssign(coll: *mut OCI_Coll, coll_src: *mut OCI_Coll)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the type info object associated to the collection
 *
 * @param coll - Collection handle
 *
 */
    pub fn OCI_CollGetTypeInfo(coll: *mut OCI_Coll) -> *mut OCI_TypeInfo;
}
extern "C" {
    /**
 * @brief
 * Return the collection type
 *
 * @param coll - Collection handle
 *
 * @note
 * Current collection types are:
 *
 * - OCI_COLL_VARRAY: Oracle VARRAY
 * - OCI_COLL_NESTED_TABLE: Oracle Nested Table
 *
 * @return
 * Collection type or OCI_UNKNOWN if the collection handle is null
 *
 */
    pub fn OCI_CollGetType(coll: *mut OCI_Coll) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Returns the maximum number of elements of the given collection.
 *
 * @param coll - Collection handle
 *
 */
    pub fn OCI_CollGetMax(coll: *mut OCI_Coll) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Returns the total number of elements of the given collection.
 *
 * @param coll - Collection handle
 *
 */
    pub fn OCI_CollGetSize(coll: *mut OCI_Coll) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Returns the current number of elements of the given collection.
 *
 * @note
 * - For VARRAYs, it returns the same value than OCI_CollGetSize() as VARRAYs cannot contains holes
 * - For Nested Tables that are spare collections that can have holes, it returns the total number
 *   of elements minus the total of deleted elements
 *
 * @param coll - Collection handle
 *
 */
    pub fn OCI_CollGetCount(coll: *mut OCI_Coll) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Trims the given number of elements from the end of the collection
 *
 * @param coll    - Collection handle
 * @param nb_elem - Number of elements to trim
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_CollTrim(coll: *mut OCI_Coll, nb_elem: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * clear all items of the given collection
 *
 * @param coll - Collection handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_CollClear(coll: *mut OCI_Coll) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the element at the given position in the collection
 *
 * @param coll  - Collection handle
 * @param index - Index of the destination element
 *
 * @note
 * Collection indexes start at position 1.
 *
 * @return
 * Element handle on success otherwise FALSE
 *
 */
    pub fn OCI_CollGetElem(coll: *mut OCI_Coll, index: ::std::os::raw::c_uint)
     -> *mut OCI_Elem;
}
extern "C" {
    /**
 * @brief
 * Return the element at the given position in the collection
 *
 * @param coll  - Collection handle
 * @param index - Index of the destination element
 * @param elem  - Element handle to hold the collection item data
 *
 * @note
 * Collection indexes start at position 1.
 *
 * @return
 * Element handle on success otherwise FALSE
 *
 */
    pub fn OCI_CollGetElem2(coll: *mut OCI_Coll,
                            index: ::std::os::raw::c_uint,
                            elem: *mut OCI_Elem) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Assign the given element value to the element at the given position in
 * the collection
 *
 * @param coll  - Collection handle
 * @param index - Index of the destination element
 * @param elem  - Source element handle to assign
 *
 * @note
 * Collection indexes start at position 1.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_CollSetElem(coll: *mut OCI_Coll, index: ::std::os::raw::c_uint,
                           elem: *mut OCI_Elem) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Append the given element at the end of the collection
 *
 * @param coll  - Collection handle
 * @param elem  - Element handle to add
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_CollAppend(coll: *mut OCI_Coll, elem: *mut OCI_Elem)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Convert a collection handle value to a string
 *
 * @param coll - Collection handle
 * @param size - Destination string length pointer in characters
 * @param str  - Destination string
 *
 * @note
 * In order to compute the needed string length, call the method with a NULL string
 * Then call the method again with a valid buffer
 *
 * @note
 * The resulting string is similar to the SQL*PLUS output for collections
 * For RAWs and BLOBs attributes, their binary values are converted to hexadecimal strings
 *
 * @warning
 * This convenient method shall not be used when performance matters. It is usually called twice (buffer length
 * computation) and must also care about quotes within strings.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_CollToText(coll: *mut OCI_Coll,
                          size: *mut ::std::os::raw::c_uint, str: *mut otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Delete the element at the given position in the Nested Table Collection
 *
 * @param coll  - Collection handle
 * @param index - Index of the element to delete
 *
 * @note
 * Collection indexes start at position 1.
 *
 * @warning
 * OCI_CollDeleteElem() is only valid for nested tables.
 *
 * @return
 * - if the input collection is a nested table, it returns TRUE if the element
 *   is successfully deleted otherwise FALSE on error
 * - if the input collection is a VARRAY, it always returns FALSE without spawning an exception
 *
 */
    pub fn OCI_CollDeleteElem(coll: *mut OCI_Coll,
                              index: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create an iterator handle to iterate through a collection
 *
 * @param coll  - Collection handle
 *
 * @return
 * Return the iterator handle on success otherwise NULL on failure
 *
 */
    pub fn OCI_IterCreate(coll: *mut OCI_Coll) -> *mut OCI_Iter;
}
extern "C" {
    /**
 * @brief
 * Free an iterator handle
 *
 * @param iter - Iterator handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_IterFree(iter: *mut OCI_Iter) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the next element in the collection
 *
 * @param iter - Iterator handle
 *
 * @return
 * Element handle on success otherwise NULL if:
 * - Empty collection
 * - Iterator already positioned on the last collection element
 * - An error occurred
 *
 */
    pub fn OCI_IterGetNext(iter: *mut OCI_Iter) -> *mut OCI_Elem;
}
extern "C" {
    /**
 * @brief
 * Get the previous element in the collection
 *
 * @param iter - Iterator handle
 *
 * @return
 * Element handle on success otherwise NULL if:
 * - Empty collection
 * - Iterator already positioned on the last collection element
 * - An error occurred
 *
 */
    pub fn OCI_IterGetPrev(iter: *mut OCI_Iter) -> *mut OCI_Elem;
}
extern "C" {
    /**
 * @brief
 * Get the current element in the collection
 *
 * @param iter - Iterator handle
 *
 * @return
 * Element handle on success otherwise NULL if:
 * - Empty collection
 * - Iterator already positioned on the last collection element
 * - An error occurred
 *
 */
    pub fn OCI_IterGetCurrent(iter: *mut OCI_Iter) -> *mut OCI_Elem;
}
extern "C" {
    /**
 * @brief
 * Create a local collection element instance based on a collection type
 * descriptor
 *
 * @param typinf  - Type info handle
 *
 * @return
 * Return the collection element handle on success otherwise NULL on failure
 *
 */
    pub fn OCI_ElemCreate(typinf: *mut OCI_TypeInfo) -> *mut OCI_Elem;
}
extern "C" {
    /**
 * @brief
 * Free a local collection element
 *
 * @param elem   - Element handle
 *
 * @warning
 * Only element created with OCI_ElemCreate() should be freed
 * by OCI_ElemFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemFree(elem: *mut OCI_Elem) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Return the boolean value of the given collection element
*
* @param elem   - Element handle
*
* @warning
* OCI_ElemGetBoolean() returns a valid value only for collection elements of PL/SQL boolean type
*
* @return
* boolean value or FALSE on failure
*
*/
    pub fn OCI_ElemGetBoolean(elem: *mut OCI_Elem) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Return the number value of the given collection element
*
* @param elem   - Element handle
*
* @return
* number handle or NULL on failure
*
*/
    pub fn OCI_ElemGetNumber(elem: *mut OCI_Elem) -> *mut OCI_Number;
}
extern "C" {
    /**
 * @brief
 * Return the short value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * Short value or 0 on failure
 *
 */
    pub fn OCI_ElemGetShort(elem: *mut OCI_Elem) -> ::std::os::raw::c_short;
}
extern "C" {
    /**
 * @brief
 * Return the unsigned short value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * Unsigned short value or 0 on failure
 *
 */
    pub fn OCI_ElemGetUnsignedShort(elem: *mut OCI_Elem)
     -> ::std::os::raw::c_ushort;
}
extern "C" {
    /**
 * @brief
 * Return the int value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * Int value or 0 on failure
 *
 */
    pub fn OCI_ElemGetInt(elem: *mut OCI_Elem) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the unsigned int value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * Unsigned int value or 0 on failure
 *
 */
    pub fn OCI_ElemGetUnsignedInt(elem: *mut OCI_Elem)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the big int value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * Big int value or 0 on failure
 *
 */
    pub fn OCI_ElemGetBigInt(elem: *mut OCI_Elem) -> big_int;
}
extern "C" {
    /**
 * @brief
 * Return the unsigned big int value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * Unsigned big int value or 0 on failure
 *
 */
    pub fn OCI_ElemGetUnsignedBigInt(elem: *mut OCI_Elem) -> big_uint;
}
extern "C" {
    /**
 * @brief
 * Return the Double value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * Double value or 0 on failure
 *
 */
    pub fn OCI_ElemGetDouble(elem: *mut OCI_Elem) -> f64;
}
extern "C" {
    /**
 * @brief
 * Return the float value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * Double value or 0 on failure
 *
 */
    pub fn OCI_ElemGetFloat(elem: *mut OCI_Elem) -> f32;
}
extern "C" {
    /**
 * @brief
 * Return the String value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * String value or NULL on failure
 *
 */
    pub fn OCI_ElemGetString(elem: *mut OCI_Elem) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Read the RAW value of the collection element into the given buffer
 *
 * @param elem   - Element handle
 * @param value  - Buffer to store the RAW value
 * @param len    - Size of the buffer
 *
 * @return
 * Number of bytes read from the RAW value or 0 on failure
 *
 */
    pub fn OCI_ElemGetRaw(elem: *mut OCI_Elem,
                          value: *mut ::std::os::raw::c_void,
                          len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
* @brief
* Return the raw attribute value size of the given element handle
*
* @param elem   - Element handle
*
* @return
* size in bytes of the RAW value or 0 on failure or wrong attribute type
*
*/
    pub fn OCI_ElemGetRawSize(elem: *mut OCI_Elem) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the Date value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * Date handle or NULL on failure
 *
 */
    pub fn OCI_ElemGetDate(elem: *mut OCI_Elem) -> *mut OCI_Date;
}
extern "C" {
    /**
 * @brief
 * Return the Timestamp value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * Timestamp handle or NULL on failure
 *
 */
    pub fn OCI_ElemGetTimestamp(elem: *mut OCI_Elem) -> *mut OCI_Timestamp;
}
extern "C" {
    /**
 * @brief
 * Return the Interval value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * Interval handle or NULL on failure
 *
 */
    pub fn OCI_ElemGetInterval(elem: *mut OCI_Elem) -> *mut OCI_Interval;
}
extern "C" {
    /**
 * @brief
 * Return the Lob value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * Lob handle or NULL on failure
 *
 */
    pub fn OCI_ElemGetLob(elem: *mut OCI_Elem) -> *mut OCI_Lob;
}
extern "C" {
    /**
 * @brief
 * Return the File value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * File handle or NULL on failure
 *
 */
    pub fn OCI_ElemGetFile(elem: *mut OCI_Elem) -> *mut OCI_File;
}
extern "C" {
    /**
 * @brief
 * Return the object value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * Object handle or NULL on failure
 *
 */
    pub fn OCI_ElemGetObject(elem: *mut OCI_Elem) -> *mut OCI_Object;
}
extern "C" {
    /**
 * @brief
 * Return the collection value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * Collection handle or NULL on failure
 *
 */
    pub fn OCI_ElemGetColl(elem: *mut OCI_Elem) -> *mut OCI_Coll;
}
extern "C" {
    /**
 * @brief
 * Return the Ref value of the given collection element
 *
 * @param elem   - Element handle
 *
 * @return
 * Ref handle or NULL on failure
 *
 */
    pub fn OCI_ElemGetRef(elem: *mut OCI_Elem) -> *mut OCI_Ref;
}
extern "C" {
    /**
* @brief
* Set a boolean value to a collection element
*
* @param elem   - Element handle
* @param value  - Short value
*
*@warning
* OCI_ElemSetBoolean() is only valid value only for collection elements of PL / SQL boolean type
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_ElemSetBoolean(elem: *mut OCI_Elem,
                              value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Set a number value to a collection element
*
* @param elem   - Element handle
* @param value  - number value
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_ElemSetNumber(elem: *mut OCI_Elem, value: *mut OCI_Number)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set a short value to a collection element
 *
 * @param elem   - Element handle
 * @param value  - Short value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetShort(elem: *mut OCI_Elem,
                            value: ::std::os::raw::c_short)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set a unsigned short value to a collection element
 *
 * @param elem   - Element handle
 * @param value  - Unsigned short value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetUnsignedShort(elem: *mut OCI_Elem,
                                    value: ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set a int value to a collection element
 *
 * @param elem   - Element handle
 * @param value  - Int value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetInt(elem: *mut OCI_Elem, value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set a unsigned int value to a collection element
 *
 * @param elem   - Element handle
 * @param value  - Unsigned int value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetUnsignedInt(elem: *mut OCI_Elem,
                                  value: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set a big int value to a collection element
 *
 * @param elem   - Element handle
 * @param value  - big int value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetBigInt(elem: *mut OCI_Elem, value: big_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set a unsigned big_int value to a collection element
 *
 * @param elem   - Element handle
 * @param value  - Unsigned big int value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetUnsignedBigInt(elem: *mut OCI_Elem, value: big_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set a double value to a collection element
 *
 * @param elem   - Element handle
 * @param value  - Double value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetDouble(elem: *mut OCI_Elem, value: f64)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set a float value to a collection element
 *
 * @param elem   - Element handle
 * @param value  - float value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetFloat(elem: *mut OCI_Elem, value: f32)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set a string value to a collection element
 *
 * @param elem   - Element handle
 * @param value  - String value
 *
 * @note
 * passing a null pointer for value calls OCI_ElemSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetString(elem: *mut OCI_Elem, value: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set a RAW value to a collection element
 *
 * @param elem   - Element handle
 * @param value  - Raw value
 * @param len    - Size of the raw value
 *
 * @note
 * passing a null pointer for value calls OCI_ElemSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetRaw(elem: *mut OCI_Elem,
                          value: *mut ::std::os::raw::c_void,
                          len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Assign a Date handle to a collection element
 *
 * @param elem   - Element handle
 * @param value  - Date Handle
 *
 * @note
 * passing a null pointer for value calls OCI_ElemSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetDate(elem: *mut OCI_Elem, value: *mut OCI_Date)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Assign a Timestamp handle to a collection element
 *
 * @param elem   - Element handle
 * @param value  - Timestamp Handle
 *
 * @note
 * passing a null pointer for value calls OCI_ElemSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetTimestamp(elem: *mut OCI_Elem,
                                value: *mut OCI_Timestamp)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Assign an Interval handle to a collection element
 *
 * @param elem   - Element handle
 * @param value  - Interval Handle
 *
 * @note
 * passing a null pointer for value calls OCI_ElemSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetInterval(elem: *mut OCI_Elem, value: *mut OCI_Interval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Assign a Collection handle to a collection element
 *
 * @param elem   - Element handle
 * @param value  - Collection Handle
 *
 * @note
 * passing a null pointer for value calls OCI_ElemSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetColl(elem: *mut OCI_Elem, value: *mut OCI_Coll)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Assign an Object handle to a collection element
 *
 * @param elem   - Element handle
 * @param value  - Object Handle
 *
 * @warning
 * This function assigns a copy of the object to the given attribute.
 * Any further modifications of the object passed as the parameter 'value'
 * will not be reflected to object 's attribute set with this call
 *
 * @note
 * passing a null pointer for value calls OCI_ElemSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetObject(elem: *mut OCI_Elem, value: *mut OCI_Object)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Assign a Lob handle to a collection element
 *
 * @param elem   - Element handle
 * @param value  - Lob Handle
 *
 * @note
 * passing a null pointer for value calls OCI_ElemSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetLob(elem: *mut OCI_Elem, value: *mut OCI_Lob)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Assign a File handle to a collection element
 *
 * @param elem   - Element handle
 * @param value  - File Handle
 *
 * @note
 * passing a null pointer for value calls OCI_ElemSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetFile(elem: *mut OCI_Elem, value: *mut OCI_File)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Assign a Ref handle to a collection element
 *
 * @param elem   - Element handle
 * @param value  - Ref Handle
 *
 * @note
 * passing a null pointer for value calls OCI_ElemSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetRef(elem: *mut OCI_Elem, value: *mut OCI_Ref)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Check if the collection element value is null
 *
 * @param elem - Element handle
 *
 * @return
 * TRUE if it's null otherwise FALSE
 *
 */
    pub fn OCI_ElemIsNull(elem: *mut OCI_Elem) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set a collection element value to null
 *
 * @param elem - Element handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ElemSetNull(elem: *mut OCI_Elem) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Retrieve the next available resultset
 *
 * @param stmt - Statement handle
 *
 * @note
 * it is only valid for the following statements:
 * - Statements executing SQL UPDATE/DELETE using a RETURNING INTO clause
 * - Statements implicitly returned from PL/SQL procedure or blocks (new feature in Oracle 12cR1) using
 *   DBMS_SQL.RETURN_RESULT()
 *
 * @note
 * SQL statements with a 'returning' clause can return multiple resultsets.
 * When arrays of program variables are binded to the statement, Oracle will
 * execute the statement for every row (iteration).
 * Each iteration generates a resultset that can be fetched like regular ones.
 *
 * @note
 * Starting withOracle 12cR1, PL/SQ procedure and blocks ca return multiple implicit resultsets
 * Refer to  Oracle documentation for more information.
 *
 * @return
 * A resultset handle on success otherwise NULL
 *
 */
    pub fn OCI_GetNextResultset(stmt: *mut OCI_Statement)
     -> *mut OCI_Resultset;
}
extern "C" {
    /**
* @brief
* Register a register output bind placeholder
*
* @param stmt - Statement handle
* @param name - Output bind name
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_RegisterNumber(stmt: *mut OCI_Statement, name: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register a short output bind placeholder
 *
 * @param stmt - Statement handle
 * @param name - Output bind name
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_RegisterShort(stmt: *mut OCI_Statement, name: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register an unsigned short output bind placeholder
 *
 * @param stmt - Statement handle
 * @param name - Output bind name
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_RegisterUnsignedShort(stmt: *mut OCI_Statement,
                                     name: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register an integer output bind placeholder
 *
 * @param stmt - Statement handle
 * @param name - Output bind name
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_RegisterInt(stmt: *mut OCI_Statement, name: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register an unsigned integer output bind placeholder
 *
 * @param stmt - Statement handle
 * @param name - Output bind name
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_RegisterUnsignedInt(stmt: *mut OCI_Statement,
                                   name: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register a big integer output bind placeholder
 *
 * @param stmt - Statement handle
 * @param name - Output bind name
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_RegisterBigInt(stmt: *mut OCI_Statement, name: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register an unsigned big integer output bind placeholder
 *
 * @param stmt - Statement handle
 * @param name - Output bind name
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_RegisterUnsignedBigInt(stmt: *mut OCI_Statement,
                                      name: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register a string output bind placeholder
 *
 * @param stmt - Statement handle
 * @param name - Output bind name
 * @param len  - Max length of single string (in characters)
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_RegisterString(stmt: *mut OCI_Statement, name: *const otext,
                              len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register an raw output bind placeholder
 *
 * @param stmt - Statement handle
 * @param name - Output bind name
 * @param len  - Max length of the buffer (in bytes)
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_RegisterRaw(stmt: *mut OCI_Statement, name: *const otext,
                           len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register a double output bind placeholder
 *
 * @param stmt - Statement handle
 * @param name - Output bind name
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_RegisterDouble(stmt: *mut OCI_Statement, name: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register a float output bind placeholder
 *
 * @param stmt - Statement handle
 * @param name - Output bind name
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_RegisterFloat(stmt: *mut OCI_Statement, name: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register a date output bind placeholder
 *
 * @param stmt - Statement handle
 * @param name - Output bind name
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_RegisterDate(stmt: *mut OCI_Statement, name: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register a timestamp output bind placeholder
 *
 * @param stmt - Statement handle
 * @param name - Output bind name
 * @param type - Timestamp type
 *
 * @note
 * See OCI_TimestampCreate() for possible values of parameter 'type'
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_RegisterTimestamp(stmt: *mut OCI_Statement, name: *const otext,
                                 type_: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register an interval output bind placeholder
 *
 * @param stmt - Statement handle
 * @param name - Output bind name
 * @param type - Interval type
 *
 * @note
 * See OCI_IntervalCreate() for possible values of parameter 'type'
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_RegisterInterval(stmt: *mut OCI_Statement, name: *const otext,
                                type_: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register an object output bind placeholder
 *
 * @param stmt   - Statement handle
 * @param name   - Output bind name
 * @param typinf - Type info handle
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_RegisterObject(stmt: *mut OCI_Statement, name: *const otext,
                              typinf: *mut OCI_TypeInfo)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register a lob output bind placeholder
 *
 * @param stmt - Statement handle
 * @param name - Output bind name
 * @param type - Lob type
 *
 * @note
 * See OCI_LobCreate() for possible values of parameter 'type'
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_RegisterLob(stmt: *mut OCI_Statement, name: *const otext,
                           type_: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register a file output bind placeholder
 *
 * @param stmt - Statement handle
 * @param name - Output bind name
 * @param type - File type
 *
 * @note
 * See OCI_FileCreate() for possible values of parameter 'type'
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_RegisterFile(stmt: *mut OCI_Statement, name: *const otext,
                            type_: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register a Ref output bind placeholder
 *
 * @param stmt   - Statement handle
 * @param name   - Output bind name
 * @param typinf - Type info handle
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_RegisterRef(stmt: *mut OCI_Statement, name: *const otext,
                           typinf: *mut OCI_TypeInfo)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the type of a SQL statement
 *
 * @param stmt - Statement handle
 *
 * @note
 * Possible values are :
 *
 * - OCI_CST_SELECT  : select statement
 * - OCI_CST_UPDATE  : update statement
 * - OCI_CST_DELETE  : delete statement
 * - OCI_CST_INSERT  : insert statement
 * - OCI_CST_CREATE  : create statement
 * - OCI_CST_DROP    : drop statement
 * - OCI_CST_ALTER   : alter statement
 * - OCI_CST_BEGIN   : begin (pl/sql) statement
 * - OCI_CST_DECLARE : declare (pl/sql) statement
 * - OCI_CST_CALL    : kpu call
 *
 * @return
 * The statement type on success or OCI_UNKOWN on error
 *
 */
    pub fn OCI_GetStatementType(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set the fetch mode of a SQL statement
 *
 * @param stmt - Statement handle
 * @param mode - fetch mode value
 *
 * @warning
 * OCI_SetFetchMode() MUST be called before any OCI_ExecuteXXX() call
 *
 * @note
 * Possible values are :
 *  - OCI_SFM_DEFAULT
 *  - OCI_SFM_SCROLLABLE
 *
 */
    pub fn OCI_SetFetchMode(stmt: *mut OCI_Statement,
                            mode: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the fetch mode of a SQL statement
 *
 * @param stmt - Statement handle
 *
 * @note
 * See OCI_SetFetchMode() for possible values
 * Default value is OCI_SFM_DEFAULT
 *
 */
    pub fn OCI_GetFetchMode(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set the binding mode of a SQL statement
 *
 * @param stmt - Statement handle
 * @param mode - binding mode value
 *
 * @note
 * Possible values are :
 *  - OCI_BIND_BY_POS  : position binding
 *  - OCI_BIND_BY_NAME : name binding
 *
 */
    pub fn OCI_SetBindMode(stmt: *mut OCI_Statement,
                           mode: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the binding mode of a SQL statement
 *
 * @param stmt - Statement handle
 *
 * @note
 * See OCI_SetBindMode() for possible values
 * Default value is OCI_BIND_BY_NAME
 *
 * @note
 * if stmt is NULL, the return value is OCI_UNKNOWN
 *
 */
    pub fn OCI_GetBindMode(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set the bind allocation mode of a SQL statement
 *
 * @param stmt - Statement handle
 * @param mode - bind allocation mode value
 *
 * @warning
 * @note
 * This call has to be made after OCI_Prepare() but before any OCI_BindXXX() calls
 *
 * @note
 * Possible values are :
 *  - OCI_BAM_EXTERNAL : bind variable are allocated by user code
 *  - OCI_BAM_INTERNAL : bind variable are allocated internally
 *
 */
    pub fn OCI_SetBindAllocation(stmt: *mut OCI_Statement,
                                 mode: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the bind allocation mode of a SQL statement
 *
 * @param stmt - Statement handle
 *
 * @note
 * See OCI_SetBindAllocation() for possible values
 * Default value is OCI_BAM_EXTERNAL
 *
 * @note
 * if stmt is NULL, the return value is OCI_UNKNOWN
 *
 */
    pub fn OCI_GetBindAllocation(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set the number of rows fetched per internal server fetch call
 *
 * @param stmt - Statement handle
 * @param size - number of rows to fetch
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SetFetchSize(stmt: *mut OCI_Statement,
                            size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the number of rows fetched per internal server fetch call
 *
 * @param stmt - Statement handle
 *
 * @note
 * Default value is set to constant OCI_FETCH_SIZE
 *
 */
    pub fn OCI_GetFetchSize(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set the number of rows pre-fetched by OCI Client
 *
 * @param stmt - Statement handle
 * @param size - number of rows to pre-fetch
 *
 * @note
 * To turn off pre-fetching, set both attributes (size and memory) to 0.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SetPrefetchSize(stmt: *mut OCI_Statement,
                               size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the number of rows pre-fetched by OCI Client
 *
 * @param stmt - Statement handle
 *
 * @note
 * Default value is set to constant OCI_PREFETCH_SIZE
 *
 */
    pub fn OCI_GetPrefetchSize(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set the amount of memory pre-fetched by OCI Client
 *
 * @param stmt - Statement handle
 * @param size - amount of memory to fetch
 *
 * @note
 * Default value is 0 and the pre-fetch size attribute is used instead.
 * When both attributes are set (pre-fetch size and memory) and pre-fetch memory
 * value can hold more rows than specified by pre-fetch size, OCI uses pre-fetch
 * size instead.
 *
 * @note
 * OCILIB set pre-fetch attribute to OCI_PREFETCH_SIZE when a statement is created.
 * To setup a big value for OCI_SetPrefetchMemory(), you must call
 * OCI_SetPrefetchSize() to 0 to make OCI consider this attribute.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SetPrefetchMemory(stmt: *mut OCI_Statement,
                                 size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the amount of memory used to retrieve rows pre-fetched by OCI Client
 *
 * @param stmt - Statement handle
 *
 * @note
 * Default value is 0
 *
 */
    pub fn OCI_GetPrefetchMemory(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set the LONG data type piece buffer size
 *
 * @param stmt - Statement handle
 * @param size - maximum size for long buffer
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SetLongMaxSize(stmt: *mut OCI_Statement,
                              size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the LONG data type piece buffer size
 *
 * @param stmt - Statement handle
 *
 * @note
 * Default value is set to constant OCI_SIZE_LONG
 *
 */
    pub fn OCI_GetLongMaxSize(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set the long data type handling mode of a SQL statement
 *
 * @param stmt - Statement handle
 * @param mode - long mode value
 *
 * @note
 * Possible values are :
 *
 * - OCI_LONG_EXPLICIT : LONGs are explicitly handled by OCI_Long type
 * - OCI_LONG_IMPLICIT : LONGs are implicitly mapped to string type in the
 *   limits of VARCHAR2 size capacity
 *
 *  LONG RAWs can't be handled with OCI_LONG_IMPLICIT
 */
    pub fn OCI_SetLongMode(stmt: *mut OCI_Statement,
                           mode: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the long data type handling mode of a SQL statement
 *
 * @param stmt - Statement handle
 *
 * @note
 *  See OCI_SetLongMode() for possible values
 *
 */
    pub fn OCI_GetLongMode(stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the connection handle associated with a statement handle
 *
 * @param stmt - Statement handle
 *
 */
    pub fn OCI_StatementGetConnection(stmt: *mut OCI_Statement)
     -> *mut OCI_Connection;
}
extern "C" {
    /**
 * @brief
 * Create a local temporary Lob instance
 *
 * @param con  - Connection handle
 * @param type - Lob type
 *
 * Supported lob types :
 *
 * - OCI_BLOB  : Binary Lob
 * - OCI_CLOB  : Character Lob
 * - OCI_NCLOB ! National Character Lob
 *
 * @return
 * Return the lob handle on success otherwise NULL on failure
 *
 */
    pub fn OCI_LobCreate(con: *mut OCI_Connection,
                         type_: ::std::os::raw::c_uint) -> *mut OCI_Lob;
}
extern "C" {
    /**
 * @brief
 * Free a local temporary lob
 *
 * @param lob - Lob handle
 *
 * @warning
 * Only lobs created with OCI_LobCreate() should be freed by OCI_LobFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_LobFree(lob: *mut OCI_Lob) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create an array of lob object
 *
 * @param con    - Connection handle
 * @param type   - Lob type
 * @param nbelem - number of elements in the array
 *
 * @note
 * see OCI_LobCreate() for more details
 *
 * @return
 * Return the lob handle array on success otherwise NULL on failure
 *
 */
    pub fn OCI_LobArrayCreate(con: *mut OCI_Connection,
                              type_: ::std::os::raw::c_uint,
                              nbelem: ::std::os::raw::c_uint)
     -> *mut *mut OCI_Lob;
}
extern "C" {
    /**
* @brief
* Free an array of lob objects
*
* @param lobs - Array of lob objects
*
* @warning
* Only arrays of lobs created with OCI_LobArrayCreate() should be freed
* by OCI_LobArrayFree()
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_LobArrayFree(lobs: *mut *mut OCI_Lob) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the type of the given Lob object
 *
 * @param lob - Lob handle
 *
 * @note
 * For possible values, see OCI_LobCreate()
 *
 * @return
 * Object type or OCI_UNKNOWN the input handle is NULL
 *
 */
    pub fn OCI_LobGetType(lob: *mut OCI_Lob) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Perform a seek operation on the OCI_lob content buffer
 *
 * @param lob    - Lob handle
 * @param offset - Offset from current position (bytes or characters)
 * @param mode   - Seek mode
 *
 * Parameter 'mode' can be one of the following value :
 *
 * - OCI_SEEK_SET : set the lob current offset to the given absolute offset
 * - OCI_SEEK_END : set the lob current offset to the end of the lob
 * - OCI_SEEK_CUR : move the lob current offset to the number of bytes or
 *                  characters given by parameter 'offset'
 *
 * @note
 * - For CLOB and CLOB, offset in characters
 * - For BLOB and BFILE, offset is in bytes
 *
 * @note
 * Position in the Lob buffer starts at 0.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_LobSeek(lob: *mut OCI_Lob, offset: big_uint,
                       mode: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the current position in the Lob content buffer
 *
 * @param lob - Lob handle
 *
 * @return
 * Lob position (starting with 0) or 0 on failure
 */
    pub fn OCI_LobGetOffset(lob: *mut OCI_Lob) -> big_uint;
}
extern "C" {
    /**
 * @brief
 * [OBSOLETE] Read a portion of a lob into the given buffer
 *
 * @param lob    - Lob handle
 * @param buffer - Pointer to a buffer
 * @param len    - Length of the buffer (in bytes or characters)
 *
 * @note
 * Length is expressed in :
 * - Bytes for BLOBs
 * - Characters for CLOBs/NCLOBS
 *
 * @warning
 * This call is obsolete ! Use OCI_LobRead2() instead.
 *
 * @return
 * Number of bytes/characters read on success otherwise 0 on failure
 *
 */
    pub fn OCI_LobRead(lob: *mut OCI_Lob, buffer: *mut ::std::os::raw::c_void,
                       len: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Read a portion of a lob into the given buffer
 *
 * @param lob        - Lob handle
 * @param buffer     - Pointer to a buffer
 * @param char_count - [in/out] Pointer to maximum number of characters
 * @param byte_count - [in/out] Pointer to maximum number of bytes
 *
 * @note
 * In input,  'char_count' and 'byte_count' are values to read into the buffer
 * In output, 'char_count' and 'byte_count' are values read into the buffer
 *
 * @note
 * For BLOBs, only the parameter 'byte_count' is used
 * For CLOBs, both parameters can be used :
 * In input :
 *  - if 'byte_count' is set to zero, it is computed from 'char_count'
 *  - if 'char_count' is set to zero, it is computed from 'byte_count'
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_LobRead2(lob: *mut OCI_Lob,
                        buffer: *mut ::std::os::raw::c_void,
                        char_count: *mut ::std::os::raw::c_uint,
                        byte_count: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * [OBSOLETE] Write a buffer into a LOB
 *
 * @param lob    - Lob handle
 * @param buffer - Pointer to a buffer
 * @param len    - Length of the buffer (in bytes or characters)
 *
 * @note
 * Length is expressed in :
 * - Bytes for BLOBs
 * - Characters for CLOBs/NCLOBs
 *
 * @warning
 * This call is obsolete ! Use OCI_LobWrite2() instead.
 *
 * @return
 * Number of bytes / characters written on success otherwise 0 on failure
 *
 */
    pub fn OCI_LobWrite(lob: *mut OCI_Lob,
                        buffer: *mut ::std::os::raw::c_void,
                        len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Write a buffer into a LOB
 *
 * @param lob        - Lob handle
 * @param buffer     - Pointer to a buffer
 * @param char_count - [in/out] Pointer to maximum number of characters
 * @param byte_count - [in/out] Pointer to maximum number of bytes
 *
 * @note
 * In input,  'char_count' and 'byte_count' are values to write from the buffer
 * In output, 'char_count' and 'byte_count' are values written from the buffer
 *
 * @note
 * For BLOBs, only the parameter 'byte_count' is used
 * For CLOBs, both parameters can be used :
 * In input :
 *  - if 'byte_count' is set to zero, it is computed from 'char_count'
 *  - if 'char_count' is set to zero, it is computed from 'byte_count'
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_LobWrite2(lob: *mut OCI_Lob,
                         buffer: *mut ::std::os::raw::c_void,
                         char_count: *mut ::std::os::raw::c_uint,
                         byte_count: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Truncate the given lob to a shorter length
 *
 * @param lob  - Lob handle
 * @param size - New length (in bytes or characters)
 *
 * @note
 * Length is expressed in :
 * - Bytes for BLOBs
 * - Characters for CLOBs/NCLOBs
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_LobTruncate(lob: *mut OCI_Lob, size: big_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the actual length of a lob
 *
 * @param lob - Lob handle
 *
 * @note
 * The returned value is in bytes for BLOBS and characters for CLOBS/NCLOBs
 *
 */
    pub fn OCI_LobGetLength(lob: *mut OCI_Lob) -> big_uint;
}
extern "C" {
    /**
 * @brief
 * Returns the chunk size of a LOB
 *
 * @param lob - Lob handle
 *
 * @note
 * This chunk size corresponds to the chunk size used by the LOB data layer
 * when accessing and modifying the LOB value. According to Oracle
 * documentation, performance will be improved if the application issues
 * read or write requests using a multiple of this chunk size
 *
 * @note
 * The returned value is in bytes for BLOBS and characters for CLOBS/NCLOBs
 *
 */
    pub fn OCI_LobGetChunkSize(lob: *mut OCI_Lob) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Erase a portion of the lob at a given position
 *
 * @param lob    - Lob handle
 * @param offset - Absolute position in source lob
 * @param len    - Number of bytes or characters to erase
 *
 * @note
 * Absolute position starts at 0.
 * Erasing means that spaces overwrite the existing LOB value.
 *
 * @return
 * Number of bytes (BLOB) or characters (CLOB/NCLOB) erased on success
 * otherwise 0 on failure
 *
 */
    pub fn OCI_LobErase(lob: *mut OCI_Lob, offset: big_uint, len: big_uint)
     -> big_uint;
}
extern "C" {
    /**
 * @brief
 * Append a buffer at the end of a LOB
 *
 * @param lob    - Lob handle
 * @param buffer - Pointer to a buffer
 * @param len    - Length of the buffer (in bytes or characters)
 *
 * @note
 * Length is expressed in :
 * - Bytes for BLOBs
 * - Characters for CLOBs
 *
 * @return
 * Number of bytes / characters written on success otherwise 0 on failure
 *
 */
    pub fn OCI_LobAppend(lob: *mut OCI_Lob,
                         buffer: *mut ::std::os::raw::c_void,
                         len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Append a buffer at the end of a LOB
 *
 * @param lob        - Lob handle
 * @param buffer     - Pointer to a buffer
 * @param char_count - [in/out] Pointer to maximum number of characters
 * @param byte_count - [in/out] Pointer to maximum number of bytes
 *
 * @note
 * In input,  'char_count' and 'byte_count' are values to write from the buffer
 * In output, 'char_count' and 'byte_count' are values written from the buffer
 *
 * @note
 * For BLOBs, only the parameter 'byte_count' is used
 * For CLOBs, both parameters can be used :
 * In input :
 *  - if 'byte_count' is set to zero, it is computed from 'char_count'
 *  - if 'char_count' is set to zero, it is computed from 'byte_count'
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_LobAppend2(lob: *mut OCI_Lob,
                          buffer: *mut ::std::os::raw::c_void,
                          char_count: *mut ::std::os::raw::c_uint,
                          byte_count: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Append a source LOB at the end of a destination LOB
 *
 * @param lob        - Destination Lob handle
 * @param lob_src    - Source Lob handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_LobAppendLob(lob: *mut OCI_Lob, lob_src: *mut OCI_Lob)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Check if the given lob is a temporary lob
 *
 * @param lob - Lob handle
 *
 * @return
 * TRUE if it's a temporary lob otherwise FALSE
 *
 */
    pub fn OCI_LobIsTemporary(lob: *mut OCI_Lob) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Copy a portion of a source LOB into a destination LOB
 *
 * @param lob        - Destination Lob handle
 * @param lob_src    - Source Lob handle
 * @param offset_dst - Absolute position in destination lob
 * @param offset_src - Absolute position in source lob
 * @param count      - Number of bytes or character to copy
 *
 * @note
 * For character LOB (CLOB/NCLOBS) the parameters count, offset_dst and
 * offset_src are expressed in characters and not in bytes.
 *
 * @note
 * Absolute position starts at 0.
 *
 */
    pub fn OCI_LobCopy(lob: *mut OCI_Lob, lob_src: *mut OCI_Lob,
                       offset_dst: big_uint, offset_src: big_uint,
                       count: big_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Copy a portion of a source FILE into a destination LOB
 *
 * @param lob        - Destination Lob handle
 * @param file       - Source File handle
 * @param offset_dst - Absolute position in destination lob
 * @param offset_src - Absolute position in source file
 * @param count      - Number of bytes to copy
 *
 * @note
 * - For character LOB (CLOB/NCLOB) the parameter offset_src are expressed in
 *   characters and not in bytes.
 * - Offset_src is always in bytes
 *
 * @note
 * Absolute position starts at 0.
 *
 */
    pub fn OCI_LobCopyFromFile(lob: *mut OCI_Lob, file: *mut OCI_File,
                               offset_dst: big_uint, offset_src: big_uint,
                               count: big_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Open explicitly a Lob
 *
 * @param lob  - Lob handle
 * @param mode - open mode
 *
 * Possible values for mode are :
 *
 * - OCI_LOB_READONLY  : read only access
 * - OCI_LOB_READWRITE : read/write access
 *
 * @note
 * - A call to OCI_LobOpen is not necessary to manipulate a Lob.
 * - If a lob hasn't been opened explicitly, triggers are fired and
 *   indexes updated at every read/write/append operation
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_LobOpen(lob: *mut OCI_Lob, mode: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Close explicitly a Lob
 *
 * @param lob - Lob handle
 *
 * @note
 * - A call to OCI_LobClose is not necessary to manipulate a Lob.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_LobClose(lob: *mut OCI_Lob) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Compare two lob handles for equality
 *
 * @param lob  - Lob handle
 * @param lob2 - Lob2 handle
 *
 * @return
 * TRUE is the lobs are not null and equal otherwise FALSE
 *
 */
    pub fn OCI_LobIsEqual(lob: *mut OCI_Lob, lob2: *mut OCI_Lob)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Assign a lob to another one
 *
 * @param lob     - Destination Lob handle
 * @param lob_src - Source Lob handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_LobAssign(lob: *mut OCI_Lob, lob_src: *mut OCI_Lob)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the maximum size that the lob can contain
 *
 * @param lob - Lob handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_LobGetMaxSize(lob: *mut OCI_Lob) -> big_uint;
}
extern "C" {
    /**
 * @brief
 * Flush Lob content to the server
 *
 * @param lob   - Lob handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_LobFlush(lob: *mut OCI_Lob) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Enable / disable buffering mode on the given lob handle
 *
 * @param lob    - Lob handle
 * @param value  - Enable/disable buffering mode
 *
 * @note
 * Oracle "LOB Buffering Subsystem" allows client applications
 * to speedup read/write of small buffers on Lobs Objects.
 * Check Oracle Documentation for more details on "LOB Buffering Subsystem".
 * This reduces the number of network round trips and LOB versions, thereby
 * improving LOB performance significantly.
 *
 * @warning
 * According to Oracle documentation the following operations are not permitted
 * on Lobs when buffering is on : OCI_LobCopy(), OCI_LobAppend, OCI_LobErase(),
 * OCI_LobGetLength(), OCI_LobTruncate()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_LobEnableBuffering(lob: *mut OCI_Lob,
                                  value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Retrieve connection handle from the lob handle
*
* @param lob - lob handle
*
*/
    pub fn OCI_LobGetConnection(lob: *mut OCI_Lob) -> *mut OCI_Connection;
}
extern "C" {
    /**
 * @brief
 * Create a file object instance
 *
 * @param con  - Connection handle
 * @param type - File type
 *
 * Supported file types :
 *
 * - OCI_BFILE : Binary file
 * - OCI_CFILE : Character file
 *
 * @return
 * Return the lob handle on success otherwise NULL on failure
 *
 */
    pub fn OCI_FileCreate(con: *mut OCI_Connection,
                          type_: ::std::os::raw::c_uint) -> *mut OCI_File;
}
extern "C" {
    /**
 * @brief
 * Free a local File object
 *
 * @param file - File handle
 *
 * @warning
 * Only Files created with OCI_FileCreate() should be freed by OCI_FileFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_FileFree(file: *mut OCI_File) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create an array of file object
 *
 * @param con    - Connection handle
 * @param type   - File type
 * @param nbelem - number of elements in the array
 *
 * @note
 * see OCI_FileCreate() for more details
 *
 * @return
 * Return the file handle array on success otherwise NULL on failure
 *
 */
    pub fn OCI_FileArrayCreate(con: *mut OCI_Connection,
                               type_: ::std::os::raw::c_uint,
                               nbelem: ::std::os::raw::c_uint)
     -> *mut *mut OCI_File;
}
extern "C" {
    /**
* @brief
* Free an array of file objects
*
* @param files - Array of file objects
*
* @warning
* Only arrays of lobs created with OCI_FileArrayCreate() should be freed by OCI_FileArrayFree()
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_FileArrayFree(files: *mut *mut OCI_File)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the type of the given File object
 *
 * @param file - File handle
 *
 * @note
 * For possible values, see OCI_FileCreate()
 *
 * @return
 * Object type or OCI_UNKNOWN the input handle is NULL
 *
 */
    pub fn OCI_FileGetType(file: *mut OCI_File) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Perform a seek operation on the OCI_File content buffer
 *
 * @param file    - File handle
 * @param offset  - Offset from current position
 * @param mode    - Seek mode
 *
 * Mode parameter can be one of the following value :
 *
 * - OCI_SEEK_SET : set the file current offset to the given absolute offset
 * - OCI_SEEK_END : set the file current offset to the end of the lob
 * - OCI_SEEK_CUR : move the file current offset to the number of bytes given by
 *                  parameter 'offset'
 *
 * @note
 * Position in the File buffer starts at 0.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_FileSeek(file: *mut OCI_File, offset: big_uint,
                        mode: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the current position in the file
 *
 * @param file - File handle
 *
 * @return
 * File position (starting with 0) or 0 on failure
 */
    pub fn OCI_FileGetOffset(file: *mut OCI_File) -> big_uint;
}
extern "C" {
    /**
 * @brief
 * Read a portion of a file into the given buffer
 *
 * @param file   - File handle
 * @param buffer - Pointer to a buffer
 * @param len    - Length of the buffer in bytes
 *
 * @return
 * Number of bytes read on success otherwise 0 on failure
 *
 */
    pub fn OCI_FileRead(file: *mut OCI_File,
                        buffer: *mut ::std::os::raw::c_void,
                        len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the size in bytes of a file
 *
 * @param file - File handle
 *
 */
    pub fn OCI_FileGetSize(file: *mut OCI_File) -> big_uint;
}
extern "C" {
    /**
 * @brief
 * Check if the given file exists on server
 *
 * @param file - File handle
 *
 * @note
 * For local FILEs object, OCI_LobFileSetName() must be called before to set the filename to check
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_FileExists(file: *mut OCI_File) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the directory and file name of FILE handle
 *
 * @param file  - File handle
 * @param dir   - File directory
 * @param name  - File name
 *in
 * @note
 * - For local FILEs only
 * - Files fetched from resultset can't be assigned a new directory and name
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_FileSetName(file: *mut OCI_File, dir: *const otext,
                           name: *const otext) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the directory of the given file
 *
 * @param file  - File handle
 *
 */
    pub fn OCI_FileGetDirectory(file: *mut OCI_File) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the name of the given file
 *
 * @param file  - File handle
 *
 */
    pub fn OCI_FileGetName(file: *mut OCI_File) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Open a file for reading
 *
 * @param file  - File handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_FileOpen(file: *mut OCI_File) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Check if the specified file is opened within the file handle
 *
 * @param file  - File handle
 *
 * @return
 * TRUE if the file was opened with this handle otherwise FALSE
 *
 */
    pub fn OCI_FileIsOpen(file: *mut OCI_File) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Close a file
 *
 * @param file  - File handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_FileClose(file: *mut OCI_File) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Compare two file handle for equality
 *
 * @param file  - File handle
 * @param file2 - File2 handle
 *
 * @return
 * TRUE is the lobs are not null and equal otherwise FALSE
 *
 */
    pub fn OCI_FileIsEqual(file: *mut OCI_File, file2: *mut OCI_File)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Assign a file to another one
 *
 * @param file     - Destination File handle
 * @param file_src - Source File handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_FileAssign(file: *mut OCI_File, file_src: *mut OCI_File)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Retrieve connection handle from the file handle
*
* @param file - file handle
*
*/
    pub fn OCI_FileGetConnection(file: *mut OCI_File) -> *mut OCI_Connection;
}
extern "C" {
    /**
 * @brief
 * Create a local temporary Long instance
 *
 * @param stmt - Statement handle
 * @param type - Long type
 *
 * Supported lob types :
 *
 * - OCI_BLONG : Binary Long
 * - OCI_CLONG : Character Long
 *
 * @return
 * Return the long handle on success otherwise NULL on failure
 *
 */
    pub fn OCI_LongCreate(stmt: *mut OCI_Statement,
                          type_: ::std::os::raw::c_uint) -> *mut OCI_Long;
}
extern "C" {
    /**
 * @brief
 * Free a local temporary long
 *
 * @param lg - Long handle
 *
 * @warning
 * Only lobs created with OCI_LongCreate() should be freed by OCI_LongFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_LongFree(lg: *mut OCI_Long) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the type of the given Long object
 *
 * @param lg - Long handle
 *
 * @note
 * For possible values, see OCI_LobCreate()
 *
 * @return
 * Object type or OCI_UNKNOWN the input handle is NULL
 *
 */
    pub fn OCI_LongGetType(lg: *mut OCI_Long) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Read a portion of a long into the given buffer [Obsolete]
 *
 * @param lg     - Long handle
 * @param buffer - Pointer to a buffer
 * @param len    - Length of the buffer in bytes / characters
 *
 * @note
 * - From version 2.0.0, this function is obsolete because OCILIB fetches now
 *   all data during OCIFetchNext() call
 * - So, this call reads now the internal OCI_Long object allocated buffer
 * - The internal buffer can be directly accessed with OCI_LongGetBuffer()
 *
 * @note
 * - For OCI_CLONG, parameter 'len' and returned value are expressed in characters
 * - For OCI_BLONG, parameter 'len' and returned value are expressed in bytes
 *
 * @return
 * - Number of bytes/characters read on success
 * - 0 if there is nothing more to read
 * - 0 on failure
 *
 */
    pub fn OCI_LongRead(lg: *mut OCI_Long,
                        buffer: *mut ::std::os::raw::c_void,
                        len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Write a buffer into a Long
 *
 * @param lg     - Long handle
 * @param buffer - the pointer to a buffer
 * @param len    - the length of the buffer in bytes (OCI_BLONG) or
 *                  character (OCI_CLONG)
 *
 * @return
 * Number of bytes (OCI_BLONG) / character (OCI_CLONG) written on success otherwise 0 on failure
 *
 */
    pub fn OCI_LongWrite(lg: *mut OCI_Long,
                         buffer: *mut ::std::os::raw::c_void,
                         len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the buffer size of a long object in bytes (OCI_BLONG) or character (OCI_CLONG)
 *
 * @param lg - Long handle
 *
 */
    pub fn OCI_LongGetSize(lg: *mut OCI_Long) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the internal buffer of an OCI_Long object read from a fetch sequence
 *
 * @param lg - Long handle
 *
 */
    pub fn OCI_LongGetBuffer(lg: *mut OCI_Long)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
* @brief
* Create a local number object
*
* @param con - Connection handle
*
* @note
* Parameter 'con' can be NULL in order to manipulate numbers
* independently from database connections
*
* @return
* Return the number handle on success otherwise NULL on failure
*
*/
    pub fn OCI_NumberCreate(con: *mut OCI_Connection) -> *mut OCI_Number;
}
extern "C" {
    /**
* @brief
* Free a number object
*
* @param number - Number handle
*
* @warning
* Only Numbers created with OCI_NumberCreate() should be freed by OCI_NumberFree()
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_NumberFree(number: *mut OCI_Number) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Create an array of number object
*
* @param con    - Connection handle
* @param nbelem - number of elements in the array
*
* @note
* see OCI_NumberCreate() for more details
*
* @return
* Return the number handle array on success otherwise NULL on failure
*
*/
    pub fn OCI_NumberArrayCreate(con: *mut OCI_Connection,
                                 nbelem: ::std::os::raw::c_uint)
     -> *mut *mut OCI_Number;
}
extern "C" {
    /**
* @brief
* Free an array of number objects
*
* @param numbers - Array of number objects
*
* @warning
* Only arrays of numbers created with OCI_NumberArrayCreate() should be freed by OCI_NumberArrayFree()
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_NumberArrayFree(numbers: *mut *mut OCI_Number)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Assign the value of a number handle to another one
*
* @param number     - Destination number handle
* @param number_src - Source number handle
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_NumberAssign(number: *mut OCI_Number,
                            number_src: *mut OCI_Number)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Convert a number value from the given number handle to a string
*
* @param number - source number handle
* @param fmt    - Number format
* @param size   - Destination string size in characters
* @param str    - Destination date string
*
* @note
* Output string can be one the following 'magic strings':
*   - '~'  for positive infinity
*   - '-~' for negative infinity
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_NumberToText(number: *mut OCI_Number, fmt: *const otext,
                            size: ::std::os::raw::c_int, str: *mut otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Convert a string to a number and store it in the given number handle
*
* @param number - Destination number handle
* @param str    - Source number string
* @param fmt    - Number format
*
* @note
* Input string can be one the following 'magic strings':
*   - '~'  for positive infinity
*   - '-~' for negative infinity
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_NumberFromText(number: *mut OCI_Number, str: *const otext,
                              fmt: *const otext) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Return the number value content
*
* @param number  - number handle
*
* @note
* Returned content is a buffer of 22 bytes corresponding to Oracle C native 
* representation of NUMBER values
* See oracle Documentation of its layout
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_NumberGetContent(number: *mut OCI_Number)
     -> *mut ::std::os::raw::c_uchar;
}
extern "C" {
    /**
* @brief
* Assign the number value content
*
* @param number  - number handle
* @param content - raw number content
*
* @note
* See OCI_NumberSetContent() for more information
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_NumberSetContent(number: *mut OCI_Number,
                                content: *mut ::std::os::raw::c_uchar)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Assign the number value with the value of a native C numeric type
*
* @param number - number handle
* @param type   - native C type to assign
* @param value  - pointer to value to set
*
* @note
* parameter @type can be :
*
* - OCI_NUM_SHORT     : value is a pointer to a signed short
* - OCI_NUM_USHORT    : value is a pointer to an unsigned short
* - OCI_NUM_INT       : value is a pointer to a signed int
* - OCI_NUM_UINT      : value is a pointer to an unsigned short
* - OCI_NUM_BIGINT    : value is a pointer to a signed big_int
* - OCI_NUM_BIGUINT   : value is a pointer to an unsigned big_uint
* - OCI_NUM_FLOAT     : value is a pointer to an float
* - OCI_NUM_DOUBLE    : value is a pointer to a double
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_NumberSetValue(number: *mut OCI_Number,
                              type_: ::std::os::raw::c_uint,
                              value: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Assign the number value to a native C numeric type
*
* @param number - number handle
* @param type   - native C type to assign
* @param value  - pointer to a native C variable 
*
* @note
* See OCI_NumberSetValue() for more information
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_NumberGetValue(number: *mut OCI_Number,
                              type_: ::std::os::raw::c_uint,
                              value: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Add the value of a native C numeric type to the given number
*
* @param number - number handle
* @param type   - native C type of the variable
* @param value  - pointer to a native C variable to add
*
* @note
* See OCI_NumberSetValue() for more information
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_NumberAdd(number: *mut OCI_Number,
                         type_: ::std::os::raw::c_uint,
                         value: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Subtract the value of a native C numeric type to the given number
*
* @param number - number handle
* @param type   - native C type of the variable
* @param value  - pointer to a native C variable to subtract
*
* @note
* See OCI_NumberSetValue() for more information
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_NumberSub(number: *mut OCI_Number,
                         type_: ::std::os::raw::c_uint,
                         value: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Multiply the given number with the value of a native C numeric
*
* @param number - number handle
* @param type   - native C type of the variable
* @param value  - pointer to a native C variable to multiply by
*
* @note
* See OCI_NumberSetValue() for more information
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_NumberMultiply(number: *mut OCI_Number,
                              type_: ::std::os::raw::c_uint,
                              value: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Divide the given number with the value of a native C numeric
*
* @param number - number handle
* @param type   - native C type of the variable
* @param value  - pointer to a native C variable to divide by
*
* @note
* See OCI_NumberSetValue() for more information
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_NumberDivide(number: *mut OCI_Number,
                            type_: ::std::os::raw::c_uint,
                            value: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Compares two number handles
 *
 * @param number1 - number1 handle
 * @param number2 - number2 handle
 *
 * @return
 * - -1 if number1 is smaller than number2,
 * -  0 if they are equal
 * -  1 if number1 is greater than number2.
 *
 */
    pub fn OCI_NumberCompare(number1: *mut OCI_Number,
                             number2: *mut OCI_Number)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create a local date object
 *
 * @param con - Connection handle
 *
 * @note
 * From version 2.5.0, parameter 'con' can be NULL in order to manipulate dates
 * independently from database connections
 *
 * @return
 * Return the date handle on success otherwise NULL on failure
 *
 */
    pub fn OCI_DateCreate(con: *mut OCI_Connection) -> *mut OCI_Date;
}
extern "C" {
    /**
 * @brief
 * Free a date object
 *
 * @param date - Date handle
 *
 * @warning
 * Only dates created with OCI_DateCreate() should be freed by OCI_DateFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateFree(date: *mut OCI_Date) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create an array of date object
 *
 * @param con    - Connection handle
 * @param nbelem - number of elements in the array
 *
 * @note
 * see OCI_DateCreate() for more details
 *
 * @return
 * Return the date handle array on success otherwise NULL on failure
 *
 */
    pub fn OCI_DateArrayCreate(con: *mut OCI_Connection,
                               nbelem: ::std::os::raw::c_uint)
     -> *mut *mut OCI_Date;
}
extern "C" {
    /**
 * @brief
 * Free an array of date objects
 *
 * @param dates - Array of date objects
 *
 * @warning
 * Only arrays of dates created with OCI_DateArrayCreate() should be freed by OCI_DateArrayFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateArrayFree(dates: *mut *mut OCI_Date)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Add or subtract days to a date handle
 *
 * @param date - Date handle
 * @param nb   - Number of days to add/remove
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateAddDays(date: *mut OCI_Date, nb: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Add or subtract months to a date handle
 *
 * @param date - Date handle
 * @param nb   - Number of months to add/remove
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateAddMonths(date: *mut OCI_Date, nb: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Assign the value of a date handle to another one
 *
 * @param date     - Destination Date handle
 * @param date_src - Source Date handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateAssign(date: *mut OCI_Date, date_src: *mut OCI_Date)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Check if the given date is valid
 *
 * @param date - Date handle
 *
 * @return
 * - Zero if date is valid
 * - Any other value means the date is invalid
 *
 */
    pub fn OCI_DateCheck(date: *mut OCI_Date) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Compares two date handles
 *
 * @param date  - Date1 handle
 * @param date2 - Date2 handle
 *
 * @return
 * - -1 if date1 is smaller than date2,
 * -  0 if they are equal
 * -  1 if date1 is greater than date2.
 *
 */
    pub fn OCI_DateCompare(date: *mut OCI_Date, date2: *mut OCI_Date)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the number of days betWeen two dates
 *
 * @param date  - Date1 handle
 * @param date2 - Date2 handle
 *
 * @return
 * Number of days on success otherwise OCI_ERROR on failure
 *
 */
    pub fn OCI_DateDaysBetween(date: *mut OCI_Date, date2: *mut OCI_Date)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Convert a string to a date and store it in the given date handle
 *
 * @param date - Destination Date handle
 * @param str  - Source date string
 * @param fmt  - Date format
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateFromText(date: *mut OCI_Date, str: *const otext,
                            fmt: *const otext) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Convert a Date value from the given date handle to a string
 *
 * @param date - source Date handle
 * @param fmt  - Date format
 * @param size - Destination string size in characters
 * @param str  - Destination date string
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateToText(date: *mut OCI_Date, fmt: *const otext,
                          size: ::std::os::raw::c_int, str: *mut otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Extract the date part from a date handle
 *
 * @param date  - Date handle
 * @param year  - Place holder for year value
 * @param month - Place holder for month value
 * @param day   - Place holder for day value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateGetDate(date: *mut OCI_Date,
                           year: *mut ::std::os::raw::c_int,
                           month: *mut ::std::os::raw::c_int,
                           day: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Extract the time part from a date handle
 *
 * @param date  - Date handle
 * @param hour  - Place holder for hour value
 * @param min   - Place holder for minute value
 * @param sec   - Place holder for second value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateGetTime(date: *mut OCI_Date,
                           hour: *mut ::std::os::raw::c_int,
                           min: *mut ::std::os::raw::c_int,
                           sec: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Extract the date and time parts from a date handle
 *
 * @param date  - Date handle
 * @param year  - Place holder for year value
 * @param month - Place holder for month value
 * @param day   - Place holder for day value
 * @param hour  - Place holder for hour value
 * @param min   - Place holder for minute value
 * @param sec   - Place holder for second value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateGetDateTime(date: *mut OCI_Date,
                               year: *mut ::std::os::raw::c_int,
                               month: *mut ::std::os::raw::c_int,
                               day: *mut ::std::os::raw::c_int,
                               hour: *mut ::std::os::raw::c_int,
                               min: *mut ::std::os::raw::c_int,
                               sec: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the date portion if the given date handle
 *
 * @param date  - Date handle
 * @param year  - Year value
 * @param month - Month value
 * @param day   - Day value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateSetDate(date: *mut OCI_Date, year: ::std::os::raw::c_int,
                           month: ::std::os::raw::c_int,
                           day: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the time portion if the given date handle
 *
 * @param date  - Date handle
 * @param hour  - Hour value
 * @param min   - Minute value
 * @param sec   - Second value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateSetTime(date: *mut OCI_Date, hour: ::std::os::raw::c_int,
                           min: ::std::os::raw::c_int,
                           sec: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the date and time portions if the given date handle
 *
 * @param date  - Date handle
 * @param year  - Year value
 * @param month - Month value
 * @param day   - Day value
 * @param hour  - Hour value
 * @param min   - Minute value
 * @param sec   - Second value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateSetDateTime(date: *mut OCI_Date,
                               year: ::std::os::raw::c_int,
                               month: ::std::os::raw::c_int,
                               day: ::std::os::raw::c_int,
                               hour: ::std::os::raw::c_int,
                               min: ::std::os::raw::c_int,
                               sec: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Place the last day of month (from the given date) into the given date
 *
 * @param date  - Date handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateLastDay(date: *mut OCI_Date) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Gets the date of next day of the week, after a given date
 *
 * @param date  - Date handle
 * @param day   - Day of the week
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateNextDay(date: *mut OCI_Date, day: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the current system date/time into the date handle
 *
 * @param date  - Date handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateSysDate(date: *mut OCI_Date) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Convert a date from one zone to another zone
 *
 * @param date  - Date handle
 * @param zone1 - Source zone
 * @param zone2 - Destination zone
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateZoneToZone(date: *mut OCI_Date, zone1: *const otext,
                              zone2: *const otext) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Affect an OCI_Date handle value to ISO C time data types
 *
 * @param date  - Date handle
 * @param ptm   - Pointer to a structure tm to receive date/time values
 * @param pt    - Pointer to a time_t to hold the date/time in the time_t format
 *
 * @note
 * Both parameters 'ptm' and 'p' are optional but one of them has to be provided.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateToCTime(date: *mut OCI_Date, ptm: *mut tm, pt: *mut time_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Affect ISO C time data types values to an OCI_Date handle
 *
 * @param date  - Date handle
 * @param ptm   - Pointer to a structure tm that hold the date/time value
 * @param t     - Value (time_t) that hold the date/time in the time_t format
 *
 * @note
 * Both parameters 'ptm' and 'p' are optional but one of them has to be provided.
 * If 'ptm' is not null, its value is affected to the OCI_Timestamp handle,
 * otherwise the value of 't' is used.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DateFromCTime(date: *mut OCI_Date, ptm: *mut tm, t: time_t)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create a local Timestamp instance
 *
 * @param con  - Connection handle
 * @param type - Timestamp type
 *
 * @note
 * From version 2.5.0, parameter 'con' can be NULL in order to manipulate
 * timestamps independently from database connections
 *
 * @note
 * Timestamp type can be :
 *
 * - OCI_TIMESTAMP     : timestamp
 * - OCI_TIMESTAMP_TZ  : timestamp with time zone
 * - OCI_TIMESTAMP_LTZ : timestamp with local time zone
 *
 * @return
 * Return the Timestamp handle on success otherwise NULL on failure
 *
 */
    pub fn OCI_TimestampCreate(con: *mut OCI_Connection,
                               type_: ::std::os::raw::c_uint)
     -> *mut OCI_Timestamp;
}
extern "C" {
    /**
 * @brief
 * Free an OCI_Timestamp handle
 *
 * @param tmsp - Timestamp handle
 *
 * @warning
 * Only Timestamp created with OCI_TimestampCreate() should be freed by OCI_IntervalFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampFree(tmsp: *mut OCI_Timestamp)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create an array of timestamp object
 *
 * @param con    - Connection handle
 * @param type   - Timestamp type
 * @param nbelem - number of elements in the array
 *
 * @note
 * see OCI_TimestampCreate() for more details
 *
 * @return
 * Return the timestamp handle array on success otherwise NULL on failure
 *
 */
    pub fn OCI_TimestampArrayCreate(con: *mut OCI_Connection,
                                    type_: ::std::os::raw::c_uint,
                                    nbelem: ::std::os::raw::c_uint)
     -> *mut *mut OCI_Timestamp;
}
extern "C" {
    /**
 * @brief
 * Free an array of timestamp objects
 *
 * @param tmsps - Array of timestamp objects
 *
 * @warning
 * Only arrays of timestamp created with OCI_TimestampArrayCreate()
 * should be freed by OCI_TimestampArrayFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampArrayFree(tmsps: *mut *mut OCI_Timestamp)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the type of the given Timestamp object
 *
 * @param tmsp - Timestamp handle
 *
 * @note
 * For possible values, see OCI_TimestampCreate()
 *
 * @return
 * Object type or OCI_UNKNOWN the input handle is NULL
 *
 */
    pub fn OCI_TimestampGetType(tmsp: *mut OCI_Timestamp)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Assign the value of a timestamp handle to another one
 *
 * @param tmsp     - Destination Timestamp handle
 * @param tmsp_src - Source Timestamp handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampAssign(tmsp: *mut OCI_Timestamp,
                               tmsp_src: *mut OCI_Timestamp)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Check if the given timestamp is valid
 *
 * @param tmsp - Timestamp handle
 *
 * @return
 * - Zero if the timestamp value is valid
 * - Any other value means the timestamp value is invalid
 *
 */
    pub fn OCI_TimestampCheck(tmsp: *mut OCI_Timestamp)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Compares two timestamp handles
 *
 * @param tmsp  - Timestamp1 handle
 * @param tmsp2 - Timestamp2 handle
 *
 * @return
 * - -1 if Timestamp1 is smaller than Timestamp2,
 * -  0 if they are equal
 * -  1 if Timestamp1 is greater than Timestamp2.
 *
 */
    pub fn OCI_TimestampCompare(tmsp: *mut OCI_Timestamp,
                                tmsp2: *mut OCI_Timestamp)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set a timestamp handle value
 *
 * @param tmsp      - Timestamp handle
 * @param year      - Year value
 * @param month     - Month value
 * @param day       - Day value
 * @param hour      - hour value
 * @param min       - minutes value
 * @param sec       - seconds value
 * @param fsec      - fractional part of seconds value
 * @param time_zone - name of a time zone to use [optional]
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampConstruct(tmsp: *mut OCI_Timestamp,
                                  year: ::std::os::raw::c_int,
                                  month: ::std::os::raw::c_int,
                                  day: ::std::os::raw::c_int,
                                  hour: ::std::os::raw::c_int,
                                  min: ::std::os::raw::c_int,
                                  sec: ::std::os::raw::c_int,
                                  fsec: ::std::os::raw::c_int,
                                  time_zone: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Convert one timestamp value from one type to another.
 *
 * @param tmsp     - Timestamp handle to convert
 * @param tmsp_src - Timestamp handle to use for the type conversion
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampConvert(tmsp: *mut OCI_Timestamp,
                                tmsp_src: *mut OCI_Timestamp)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Convert a string to a timestamp and store it in the given timestamp handle
 *
 * @param tmsp - Destination Timestamp handle
 * @param str  - Source date string
 * @param fmt  - Date format
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampFromText(tmsp: *mut OCI_Timestamp, str: *const otext,
                                 fmt: *const otext) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Convert a timestamp value from the given timestamp handle to a string
 *
 * @param tmsp      - source Timestamp handle
 * @param fmt       - Timestamp format
 * @param size      - Destination string size in characters
 * @param str       - Destination date string
 * @param precision - Precision for fractional part of the seconds
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampToText(tmsp: *mut OCI_Timestamp, fmt: *const otext,
                               size: ::std::os::raw::c_int, str: *mut otext,
                               precision: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Extract the date part from a timestamp handle
 *
 * @param tmsp  - Timestamp handle
 * @param year  - Place holder for year value
 * @param month - Place holder for month value
 * @param day   - Place holder for day value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampGetDate(tmsp: *mut OCI_Timestamp,
                                year: *mut ::std::os::raw::c_int,
                                month: *mut ::std::os::raw::c_int,
                                day: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Extract the time portion from a timestamp handle
 *
 * @param tmsp  - Timestamp handle
 * @param hour  - Place holder for hour value
 * @param min   - Place holder for minute value
 * @param sec   - Place holder for second value
 * @param fsec  - Place holder for fractional part of second value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampGetTime(tmsp: *mut OCI_Timestamp,
                                hour: *mut ::std::os::raw::c_int,
                                min: *mut ::std::os::raw::c_int,
                                sec: *mut ::std::os::raw::c_int,
                                fsec: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Extract the date and time parts from a date handle
 *
 * @param tmsp  - Date handle
 * @param year  - Place holder for year value
 * @param month - Place holder for month value
 * @param day   - Place holder for day value
 * @param hour  - Place holder for hour value
 * @param min   - Place holder for minute value
 * @param sec   - Place holder for second value
 * @param fsec  - Place holder for fractional part of seconds value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampGetDateTime(tmsp: *mut OCI_Timestamp,
                                    year: *mut ::std::os::raw::c_int,
                                    month: *mut ::std::os::raw::c_int,
                                    day: *mut ::std::os::raw::c_int,
                                    hour: *mut ::std::os::raw::c_int,
                                    min: *mut ::std::os::raw::c_int,
                                    sec: *mut ::std::os::raw::c_int,
                                    fsec: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the time zone name of a timestamp handle
 *
 * @param tmsp - Timestamp handle
 * @param size - Destination string size in characters
 * @param str  - Destination zone name string
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampGetTimeZoneName(tmsp: *mut OCI_Timestamp,
                                        size: ::std::os::raw::c_int,
                                        str: *mut otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the time zone (hour, minute) portion of a timestamp handle
 *
 * @param tmsp  - Timestamp handle
 * @param hour  - Place holder for hour value
 * @param min   - Place holder for min value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampGetTimeZoneOffset(tmsp: *mut OCI_Timestamp,
                                          hour: *mut ::std::os::raw::c_int,
                                          min: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Add an interval value to a timestamp value of a timestamp handle
 *
 * @param tmsp  - Timestamp handle
 * @param itv   - Interval handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampIntervalAdd(tmsp: *mut OCI_Timestamp,
                                    itv: *mut OCI_Interval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Subtract an interval value from a timestamp value of a timestamp handle
 *
 * @param tmsp  - Timestamp handle
 * @param itv   - Interval handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampIntervalSub(tmsp: *mut OCI_Timestamp,
                                    itv: *mut OCI_Interval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Store the difference of two timestamp handles into an interval handle
 *
 * @param tmsp  - Timestamp handle (subtrahend)
 * @param tmsp2 - Timestamp2 handle (minuend)
 * @param itv   - Interval handle
 *
 * @note
 * The function acts like tmsp - tmsp2 = itv
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampSubtract(tmsp: *mut OCI_Timestamp,
                                 tmsp2: *mut OCI_Timestamp,
                                 itv: *mut OCI_Interval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Stores the system current date and time as a timestamp value with time zone
 * into the timestamp handle.
 *
 * @param tmsp  - Timestamp handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampSysTimestamp(tmsp: *mut OCI_Timestamp)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Affect an OCI_Timestamp handle value to ISO C time data types
 *
 * @param tmsp  - Timestamp handle
 * @param ptm   - Pointer to a structure tm to receive date/time values
 * @param pt    - Pointer to a time_t to hold the date/time in the time_t format
 *
 * @note
 * Both parameters 'ptm' and 'p' are optional but one of them has to be provided.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampToCTime(tmsp: *mut OCI_Timestamp, ptm: *mut tm,
                                pt: *mut time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Affect ISO C time data types values to an OCI_Timestamp handle
 *
 * @param tmsp  - Timestamp handle
 * @param ptm   - Pointer to a structure tm that hold the date/time value
 * @param t     - Value (time_t) that hold the date/time in the time_t format
 *
 * @note
 * Both parameters 'ptm' and 'p' are optional but one of them has to be provided.
 * If 'ptm' is not null, its value is affected to the OCI_Timestamp handle,
 * otherwise the value of 't' is used.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TimestampFromCTime(tmsp: *mut OCI_Timestamp, ptm: *mut tm,
                                  t: time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create a local interval object
 *
 * @param con  - Connection handle
 * @param type - Type of Interval
 *
 * @note
 * From version 2.5.0, parameter 'con' can be NULL in order to manipulate
 * intervals independently from database connections
 *
 * @note
 * Interval type can be :
 * - OCI_INTERVAL_YM : year / month interval
 * - OCI_INTERVAL_DS : date/ time interval
 *
 * @return
 * Return the Interval handle on success otherwise NULL on failure
 *
 */
    pub fn OCI_IntervalCreate(con: *mut OCI_Connection,
                              type_: ::std::os::raw::c_uint)
     -> *mut OCI_Interval;
}
extern "C" {
    /**
 * @brief
 * Free an OCI_Interval handle
 *
 * @param itv - Interval handle
 *
 * @warning
 * Only Intervals created with OCI_IntervalCreate() should be freed by
 * OCI_IntervalFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_IntervalFree(itv: *mut OCI_Interval) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create an array of Interval object
 *
 * @param con    - Connection handle
 * @param type   - Type of Interval
 * @param nbelem - number of elements in the array
 *
 * @note
 * see OCI_IntervalCreate() for more details
 *
 * @return
 * Return the Interval handle array on success otherwise NULL on failure
 *
 */
    pub fn OCI_IntervalArrayCreate(con: *mut OCI_Connection,
                                   type_: ::std::os::raw::c_uint,
                                   nbelem: ::std::os::raw::c_uint)
     -> *mut *mut OCI_Interval;
}
extern "C" {
    /**
 * @brief
 * Free an array of Interval objects
 *
 * @param itvs - Array of Interval objects
 *
 * @warning
 * Only arrays of Interval created with OCI_IntervalArrayCreate() should be freed by
 * OCI_IntervalArrayFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_IntervalArrayFree(itvs: *mut *mut OCI_Interval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the type of the given Interval object
 *
 * @param itv - Interval handle
 *
 * @note
 * For possible values, see OCI_IntervalCreate()
 *
 * @return
 * Object type or OCI_UNKNOWN the input handle is NULL
 *
 */
    pub fn OCI_IntervalGetType(itv: *mut OCI_Interval)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Assign the value of a interval handle to another one
 *
 * @param itv     - Destination interval handle
 * @param itv_src - Source interval handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_IntervalAssign(itv: *mut OCI_Interval,
                              itv_src: *mut OCI_Interval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Check if the given interval is valid
 *
 * @param itv - Interval handle
 *
 * @return
 * - Zero if the interval value is valid
 * - Any other value means the interval value is invalid
 *
 */
    pub fn OCI_IntervalCheck(itv: *mut OCI_Interval) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Compares two interval handles
 *
 * @param itv  - Interval1 handle
 * @param itv2 - Interval2 handle
 *
 * @return
 * - -1 if interval1 is smaller than interval2,
 * -  0 if they are equal
 * -  1 if interval1 is greater than interval2.
 *
 */
    pub fn OCI_IntervalCompare(itv: *mut OCI_Interval,
                               itv2: *mut OCI_Interval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Convert a string to an interval and store it in the given interval handle
 *
 * @param itv  - Destination interval handle
 * @param str  - Source date string
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_IntervalFromText(itv: *mut OCI_Interval, str: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Convert an interval value from the given interval handle to a string
 *
 * @param itv           - source Interval handle
 * @param leading_prec  - Precision of the leading part
 * @param fraction_prec - Precision of the fractional part
 * @param size          - Destination string size in characters
 * @param str           - Destination date string
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_IntervalToText(itv: *mut OCI_Interval,
                              leading_prec: ::std::os::raw::c_int,
                              fraction_prec: ::std::os::raw::c_int,
                              size: ::std::os::raw::c_int, str: *mut otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Correct an interval handle value with the given time zone
 *
 * @param itv - Interval handle
 * @param str - Time zone name
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_IntervalFromTimeZone(itv: *mut OCI_Interval, str: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the day / time portion of an interval handle
 *
 * @param itv  - Interval handle
 * @param day  - Place holder for day value
 * @param hour - Place holder for hours value
 * @param min  - Place holder for minutes value
 * @param sec  - Place holder for seconds value
 * @param fsec - Place holder for fractional part of seconds value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_IntervalGetDaySecond(itv: *mut OCI_Interval,
                                    day: *mut ::std::os::raw::c_int,
                                    hour: *mut ::std::os::raw::c_int,
                                    min: *mut ::std::os::raw::c_int,
                                    sec: *mut ::std::os::raw::c_int,
                                    fsec: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the year / month portion of an interval handle
 *
 * @param itv   - Interval handle
 * @param year  - Place holder for year value
 * @param month - Place holder for month value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_IntervalGetYearMonth(itv: *mut OCI_Interval,
                                    year: *mut ::std::os::raw::c_int,
                                    month: *mut ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the day / time portion if the given interval handle
 *
 * @param itv   - Interval handle
 * @param day   - day value
 * @param hour  - Hour value
 * @param min   - Minute value
 * @param sec   - Second value
 * @param fsec  - Fractional part of the seconds
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_IntervalSetDaySecond(itv: *mut OCI_Interval,
                                    day: ::std::os::raw::c_int,
                                    hour: ::std::os::raw::c_int,
                                    min: ::std::os::raw::c_int,
                                    sec: ::std::os::raw::c_int,
                                    fsec: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the year / month portion if the given Interval handle
 *
 * @param itv    - Interval handle
 * @param year   - Year value
 * @param month  - Month value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_IntervalSetYearMonth(itv: *mut OCI_Interval,
                                    year: ::std::os::raw::c_int,
                                    month: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Adds an interval handle value to another
 *
 * @param itv   - Interval handle from witch to add
 * @param itv2  - Interval handle to add
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_IntervalAdd(itv: *mut OCI_Interval, itv2: *mut OCI_Interval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Subtract an interval handle value from another
 *
 * @param itv   - Interval handle from witch to remove
 * @param itv2  - Interval handle to remove
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_IntervalSubtract(itv: *mut OCI_Interval,
                                itv2: *mut OCI_Interval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create a local object instance
 *
 * @param con    - Connection handle
 * @param typinf - Object type (type info handle)
 *
 * @return
 * Return the object handle on success otherwise NULL on failure
 *
 */
    pub fn OCI_ObjectCreate(con: *mut OCI_Connection,
                            typinf: *mut OCI_TypeInfo) -> *mut OCI_Object;
}
extern "C" {
    /**
 * @brief
 * Free a local object
 *
 * @param obj - Object handle
 *
 * @warning
 * Only object created with OCI_ObjectCreate() should be freed
 * by OCI_ObjectFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectFree(obj: *mut OCI_Object) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create an array of Object objects
 *
 * @param con    - Connection handle
 * @param typinf - Object type (type info handle)
 * @param nbelem - number of elements in the array
 *
 * @note
 * see OCI_ObjectCreate() for more details
 *
 * @return
 * Return the Object handle array on success otherwise NULL on failure
 *
 */
    pub fn OCI_ObjectArrayCreate(con: *mut OCI_Connection,
                                 typinf: *mut OCI_TypeInfo,
                                 nbelem: ::std::os::raw::c_uint)
     -> *mut *mut OCI_Object;
}
extern "C" {
    /**
 * @brief
 * Free an array of Object objects
 *
 * @param objs - Array of Object objects
 *
 * @warning
 * Only arrays of Object created with OCI_ObjectArrayCreate()
 * should be freed by OCI_ObjectArrayFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectArrayFree(objs: *mut *mut OCI_Object)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Assign an object to another one
 *
 * @param obj     - Destination Object handle
 * @param obj_src - Source Object handle
 *
 * @note
 * Oracle proceeds to a deep copy of the object content
 *
 * @note
 * The two object handles must have the same type otherwise an exception is thrown
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectAssign(obj: *mut OCI_Object, obj_src: *mut OCI_Object)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the type of an object instance
 *
 * @param obj - Object handle
 *
 * @note
 * Possibles values are :
 *
 * - OCI_OBJ_PERSISTENT: persistent object from the DB
 * - OCI_OBJ_TRANSIENT : local temporary object
 * - OCI_OBJ_VALUE     : embedded object
 *
 * @return
 * Instance type or OCI_UNKNOWN the input handle is NULL
 *
 */
    pub fn OCI_ObjectGetType(obj: *mut OCI_Object) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Retrieve an Oracle Ref handle from an object and assign it to the given
 * OCILIB OCI_Ref handle
 *
 * @param obj - Object handle
 * @param ref - Ref handle
 *
 * @note
 * The type information of the object and the ref must be the same, otherwise
 * an exception is thrown
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectGetSelfRef(obj: *mut OCI_Object, ref_: *mut OCI_Ref)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the type info object associated to the object
 *
 * @param obj - Object handle
 *
 */
    pub fn OCI_ObjectGetTypeInfo(obj: *mut OCI_Object) -> *mut OCI_TypeInfo;
}
extern "C" {
    /**
 * @brief
 * Return the boolean value of the given object attribute (ONLY for PL/SQL records)
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetBoolean() returns a valid value only for PL/SQL boolean based attributes
 *
 * @warning
 * - ONLY supported by Oracle 12c and above !
 *
 * @return
 * Attribute value or 0 on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetBoolean(obj: *mut OCI_Object, attr: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Return the number value of the given object attribute
*
* @param obj  - Object handle
* @param attr - Attribute name
*
* @note
* If the attribute is found in the object descriptor attributes list, then a
* data type check is performed for integrity.
* OCI_ObjectGetNumber() returns a valid value only for number based attributes
*
* @return
* Attribute value or NULL on failure or wrong attribute type
*
*/
    pub fn OCI_ObjectGetNumber(obj: *mut OCI_Object, attr: *const otext)
     -> *mut OCI_Number;
}
extern "C" {
    /**
 * @brief
 * Return the short value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetShort() returns a valid value only for integer and number based attributes
 *
 * @return
 * Attribute value or 0 on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetShort(obj: *mut OCI_Object, attr: *const otext)
     -> ::std::os::raw::c_short;
}
extern "C" {
    /**
 * @brief
 * Return the unsigned short value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetUnsignedShort() returns a valid value only for integer and number based attributes
 *
 * @return
 * Attribute value or 0 on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetUnsignedShort(obj: *mut OCI_Object,
                                      attr: *const otext)
     -> ::std::os::raw::c_ushort;
}
extern "C" {
    /**
 * @brief
 * Return the integer value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetInt() returns a valid value only for integer and number based attributes
 *
 * @return
 * Attribute value or 0 on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetInt(obj: *mut OCI_Object, attr: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the unsigned integer value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetUnsignedInt() returns a valid value only for integer and number based attributes
 *
 * @return
 * Attribute value or 0 on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetUnsignedInt(obj: *mut OCI_Object, attr: *const otext)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the big integer value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetBigInt() returns a valid value only for integer and number based attributes
 *
 * @return
 * Attribute value or 0 on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetBigInt(obj: *mut OCI_Object, attr: *const otext)
     -> big_int;
}
extern "C" {
    /**
 * @brief
 * Return the unsigned big integer value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetUnsignedBigInt() returns a valid value only for integer and number based attributes
 *
 * @return
 * Attribute value or 0 on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetUnsignedBigInt(obj: *mut OCI_Object,
                                       attr: *const otext) -> big_uint;
}
extern "C" {
    /**
 * @brief
 * Return the double value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetDouble() returns a valid value only for integer and number based attributes
 *
 * @return
 * Attribute value or 0.0 on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetDouble(obj: *mut OCI_Object, attr: *const otext)
     -> f64;
}
extern "C" {
    /**
 * @brief
 * Return the float value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetFloat() returns a valid value only for integer and number based attributes
 *
 * @return
 * Attribute value or 0.0 on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetFloat(obj: *mut OCI_Object, attr: *const otext)
     -> f32;
}
extern "C" {
    /**
 * @brief
 * Return the string value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * The method can return a string value for any attributes types.
 * It performs implicit string conversions using the same
 * mechanisms than OCI_GetString(). See its documentation for more details.
 *
 * @return
 * Attribute value or NULL on failure
 *
 */
    pub fn OCI_ObjectGetString(obj: *mut OCI_Object, attr: *const otext)
     -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the raw attribute value of the given object attribute into the
 * given buffer
 *
 * @param obj   - Object handle
 * @param attr  - Attribute name
 * @param value - Destination buffer
 * @param len   - Max size to write into buffer

 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetRaw() copies data into the buffer only for raw based attributes
 *
 * @return
 * Number of bytes written to the buffer or 0 on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetRaw(obj: *mut OCI_Object, attr: *const otext,
                            value: *mut ::std::os::raw::c_void,
                            len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Return the raw attribute value size of the given object attribute into the
* given buffer
*
* @param obj   - Object handle
* @param attr  - Attribute name
*
* @note
* If the attribute is found in the object descriptor attributes list, then a
* data type check is performed for integrity.
*
* @return
* size in bytes of the RAW value or 0 on failure or wrong attribute type
*
*/
    pub fn OCI_ObjectGetRawSize(obj: *mut OCI_Object, attr: *const otext)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the date value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetDate() returns a valid value only for date based attributes
 *
 * @return
 * Attribute value or NULL on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetDate(obj: *mut OCI_Object, attr: *const otext)
     -> *mut OCI_Date;
}
extern "C" {
    /**
 * @brief
 * Return the timestamp value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetTimestamp() returns a valid value only for timestamps based attributes
 *
 * @return
 * Attribute value or NULL on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetTimestamp(obj: *mut OCI_Object, attr: *const otext)
     -> *mut OCI_Timestamp;
}
extern "C" {
    /**
 * @brief
 * Return the interval value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetInterval() returns a valid value only for intervals based attributes
 *
 * @return
 * Attribute value or NULL on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetInterval(obj: *mut OCI_Object, attr: *const otext)
     -> *mut OCI_Interval;
}
extern "C" {
    /**
 * @brief
 * Return the collection value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetColl() returns a valid value only for intervals based attributes
 *
 * @return
 * Attribute value or NULL on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetColl(obj: *mut OCI_Object, attr: *const otext)
     -> *mut OCI_Coll;
}
extern "C" {
    /**
 * @brief
 * Return the Ref value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetRef() returns a valid value only for Refs based attributes
 *
 * @return
 * Attribute value or NULL on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetRef(obj: *mut OCI_Object, attr: *const otext)
     -> *mut OCI_Ref;
}
extern "C" {
    /**
 * @brief
 * Return the object value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetObject() returns a valid value only for object based attributes
 *
 * @return
 * Attribute value or NULL on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetObject(obj: *mut OCI_Object, attr: *const otext)
     -> *mut OCI_Object;
}
extern "C" {
    /**
 * @brief
 * Return the lob value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetLob() returns a valid value only for lobs based attributes
 *
 * @return
 * Attribute value or NULL on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetLob(obj: *mut OCI_Object, attr: *const otext)
     -> *mut OCI_Lob;
}
extern "C" {
    /**
 * @brief
 * Return the file value of the given object attribute
 *
 * @param obj  - Object handle
 * @param attr - Attribute name
 *
 * @note
 * If the attribute is found in the object descriptor attributes list, then a
 * data type check is performed for integrity.
 * OCI_ObjectGetFile() returns a valid value only for files based attributes
 *
 * @return
 * Attribute value or NULL on failure or wrong attribute type
 *
 */
    pub fn OCI_ObjectGetFile(obj: *mut OCI_Object, attr: *const otext)
     -> *mut OCI_File;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type boolean (ONLY for PL/SQL records)
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - boolean value
 *
 * @warning
 * - ONLY supported by Oracle 12c and above !
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetBoolean(obj: *mut OCI_Object, attr: *const otext,
                                value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Set an object attribute of type number
*
* @param obj    - Object handle
* @param attr   - Attribute name
* @param value  - number value
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_ObjectSetNumber(obj: *mut OCI_Object, attr: *const otext,
                               value: *mut OCI_Number)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type short
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - Short value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetShort(obj: *mut OCI_Object, attr: *const otext,
                              value: ::std::os::raw::c_short)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type unsigned short
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - Unsigned short value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetUnsignedShort(obj: *mut OCI_Object,
                                      attr: *const otext,
                                      value: ::std::os::raw::c_ushort)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type int
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - Int value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetInt(obj: *mut OCI_Object, attr: *const otext,
                            value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type unsigned int
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - Unsigned int value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetUnsignedInt(obj: *mut OCI_Object, attr: *const otext,
                                    value: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type big int
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - Big int value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetBigInt(obj: *mut OCI_Object, attr: *const otext,
                               value: big_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type unsigned big int
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - Unsigned big int value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetUnsignedBigInt(obj: *mut OCI_Object,
                                       attr: *const otext, value: big_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type double
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - Double value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetDouble(obj: *mut OCI_Object, attr: *const otext,
                               value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type float
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - Float value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetFloat(obj: *mut OCI_Object, attr: *const otext,
                              value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type string
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - String value
 *
 * @note
 * passing a null pointer for value calls OCI_ObjectSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetString(obj: *mut OCI_Object, attr: *const otext,
                               value: *const otext) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type RAW
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - Raw value
 * @param len    - Size of the raw value
 *
 * @note
 * passing a null pointer for value calls OCI_ObjectSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetRaw(obj: *mut OCI_Object, attr: *const otext,
                            value: *mut ::std::os::raw::c_void,
                            len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type Date
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - Date Handle
 *
 * @note
 * passing a null pointer for value calls OCI_ObjectSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetDate(obj: *mut OCI_Object, attr: *const otext,
                             value: *mut OCI_Date) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type Timestamp
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - Timestamp Handle
 *
 * @note
 * passing a null pointer for value calls OCI_ObjectSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetTimestamp(obj: *mut OCI_Object, attr: *const otext,
                                  value: *mut OCI_Timestamp)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type Interval
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - Interval Handle
 *
 * @note
 * passing a null pointer for value calls OCI_ObjectSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetInterval(obj: *mut OCI_Object, attr: *const otext,
                                 value: *mut OCI_Interval)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type Collection
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - Collection Handle
 *
 * @note
 * passing a null pointer for value calls OCI_ObjectSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetColl(obj: *mut OCI_Object, attr: *const otext,
                             value: *mut OCI_Coll) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type Object
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - Object Handle
 *
 * @warning
 * This function assigns a copy of the object to the given attribute.
 * Any further modifications of the object passed as the parameter 'value'
 * will not be reflected to object 's attribute set with this call
 *
 * @note
 * passing a null pointer for value calls OCI_ObjectSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetObject(obj: *mut OCI_Object, attr: *const otext,
                               value: *mut OCI_Object)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type Lob
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - Lob Handle
 *
 * @note
 * passing a null pointer for value calls OCI_ObjectSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetLob(obj: *mut OCI_Object, attr: *const otext,
                            value: *mut OCI_Lob) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type File
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - File Handle
 *
 * @note
 * passing a null pointer for value calls OCI_ObjectSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetFile(obj: *mut OCI_Object, attr: *const otext,
                             value: *mut OCI_File) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute of type Ref
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 * @param value  - Ref Handle
 *
 * @note
 * passing a null pointer for value calls OCI_ObjectSetNull()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetRef(obj: *mut OCI_Object, attr: *const otext,
                            value: *mut OCI_Ref) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Check if an object attribute is null
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 *
 * @return
 * FALSE if the attribute is not null otherwise TRUE
 *
 */
    pub fn OCI_ObjectIsNull(obj: *mut OCI_Object, attr: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set an object attribute to null
 *
 * @param obj    - Object handle
 * @param attr   - Attribute name
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectSetNull(obj: *mut OCI_Object, attr: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Retrieve the underlying C (OTT/OCI style) structure of an OCI_Object handle
 *
 * @param obj       - Object handle
 * @param pp_struct - Address of a pointer that retrieve the C structure of data
 * @param pp_ind    - Address of a pointer that retrieve the C structure of indicators
 *
 * @note
 * See Oracle OCI programming guide for more details about OTT structures.
 * The members of these structures are OCI data types like OCINumber, OCIString
 * that requires mixing OCILIB code and raw OCI code.
 * OCI Object API headers have to be included to handle this data types using OCI object functions
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectGetStruct(obj: *mut OCI_Object,
                               pp_struct: *mut *mut ::std::os::raw::c_void,
                               pp_ind: *mut *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Convert an object handle value to a string
 *
 * @param obj  - Object handle
 * @param size - Destination string length pointer in characters
 * @param str  - Destination string
 *
 * @note
 * In order to compute the needed string length, call the method with a NULL string
 * Then call the method again with a valid buffer
 *
 * @note
 * The resulting string is similar to the SQL*PLUS output for UDTs (user types and objects)
 * For RAWs and BLOBs attributes, their binary values are converted to hexadecimal strings
 *
 * @warning
 * This convenient method shall not be used when performance matters. It is usually called twice (buffer length
 * computation) and must also care about quotes within strings.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ObjectToText(obj: *mut OCI_Object,
                            size: *mut ::std::os::raw::c_uint,
                            str: *mut otext) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create a local Ref instance
 *
 * @param con    - Connection handle
 * @param typinf - Ref type
 *
 * @return
 * Return the Ref handle on success otherwise NULL on failure
 *
 */
    pub fn OCI_RefCreate(con: *mut OCI_Connection, typinf: *mut OCI_TypeInfo)
     -> *mut OCI_Ref;
}
extern "C" {
    /**
 * @brief
 * Free a local Ref
 *
 * @param ref - Ref handle
 *
 * @warning
 * Only Refs created with OCI_RefCreate() should be freed
 * by OCI_RefFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_RefFree(ref_: *mut OCI_Ref) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create an array of Ref object
 *
 * @param con    - Connection handle
 * @param typinf - Object type (type info handle)
 * @param nbelem - number of elements in the array
 *
 * @note
 * see OCI_RefCreate() for more details
 *
 * @return
 * Return the Ref handle array on success otherwise NULL on failure
 *
 */
    pub fn OCI_RefArrayCreate(con: *mut OCI_Connection,
                              typinf: *mut OCI_TypeInfo,
                              nbelem: ::std::os::raw::c_uint)
     -> *mut *mut OCI_Ref;
}
extern "C" {
    /**
 * @brief
 * Free an array of Ref objects
 *
 * @param refs - Array of Ref objects
 *
 * @warning
 * Only arrays of Ref created with OCI_RefArrayCreate()
 * should be freed by OCI_RefArrayFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_RefArrayFree(refs: *mut *mut OCI_Ref) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Assign a Ref to another one
 *
 * @param ref     - Destination Ref handle
 * @param ref_src - Source Ref handle
 *
 * @note
 * The two Ref handles must have the same type otherwise an exception is thrown
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_RefAssign(ref_: *mut OCI_Ref, ref_src: *mut OCI_Ref)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the type info object associated to the Ref
 *
 * @param ref - Ref handle
 *
 */
    pub fn OCI_RefGetTypeInfo(ref_: *mut OCI_Ref) -> *mut OCI_TypeInfo;
}
extern "C" {
    /**
 * @brief
 * Returns the object pointed by the Ref handle.
 *
 * @param ref   - Ref handle
 *
 * @return
 * The object handle is the ref is not null otherwise NULL
 *
 */
    pub fn OCI_RefGetObject(ref_: *mut OCI_Ref) -> *mut OCI_Object;
}
extern "C" {
    /**
 * @brief
 * Check if the Ref points to an object or not.
 *
 * @param ref   - Ref handle
 *
 * @return
 * TRUE if it does not point to a valid object otherwise FALSE
 *
 */
    pub fn OCI_RefIsNull(ref_: *mut OCI_Ref) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Nullify the given Ref handle
 *
 * @param ref   - Ref handle
 *
 * @note
 * this call clears the reference to object pointed by the Ref handle.
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_RefSetNull(ref_: *mut OCI_Ref) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Returns the size of the hex representation of the given Ref handle
 *
 * @param ref  - Ref handle
 *
 * @note
 * the returned size is the number of character needed to store the
 * hex representation of the Ref that can be retrieved with OCI_RefToText()
 *
 */
    pub fn OCI_RefGetHexSize(ref_: *mut OCI_Ref) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Converts a Ref handle value to a hexadecimal string.
 *
 * @param ref   - Ref handle
 * @param size - Destination string size in characters
 * @param str  - Destination string
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_RefToText(ref_: *mut OCI_Ref, size: ::std::os::raw::c_uint,
                         str: *mut otext) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Perform an immediate abort of any currently Oracle OCI call
 *
 * @param con - connection handle
 *
 * @note
 * The current call will abort and generate an error
 *
 * @return
 * Returns FALSE if connection handle is NULL otherwise TRUE
 */
    pub fn OCI_Break(con: *mut OCI_Connection) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Retrieve the available type info information
 *
 * @param con  - Connection handle
 * @param name - Table/view name to query for
 * @param type - Type of object
 *
 * @note
 * Possible values for parameter type are :
 *
 * - OCI_UNKNOWN
 * - OCI_TIF_TABLE
 * - OCI_TIF_VIEW
 * - OCI_TIF_TYPE
 *
 * @return
 * - Type info handle on success
 = - NULL if the object does not exist
 * - NULL on failure
 *
 */
    pub fn OCI_TypeInfoGet(con: *mut OCI_Connection, name: *const otext,
                           type_: ::std::os::raw::c_uint)
     -> *mut OCI_TypeInfo;
}
extern "C" {
    /**
 * @brief
 * Return the type of the type info object
 *
 * @param typinf - Type info handle
 *
 * @note
 * Possible values for parameter type are :
 *
 * - OCI_UNKNOWM
 * - OCI_TIF_TABLE
 * - OCI_TIF_VIEW
 * - OCI_TIF_TYPE
 *
 * @return
 * Object type or OCI_UNKNOWN the input handle is NULL
 *
 */
    pub fn OCI_TypeInfoGetType(typinf: *mut OCI_TypeInfo)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Retrieve connection handle from the type info handle
 *
 * @param typinf - Type info handle
 *
 */
    pub fn OCI_TypeInfoGetConnection(typinf: *mut OCI_TypeInfo)
     -> *mut OCI_Connection;
}
extern "C" {
    /**
 * @brief
 * Free a type info object
 *
 * @param typinf  - Type info handle
 *
 * @note
 * this call is optional.
 * OCI_TypeInfo object are internally tracked and
 * automatically freed when their related connection is freed
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_TypeInfoFree(typinf: *mut OCI_TypeInfo)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the number of columns of a table/view/object
 *
 * @param typinf - Type info handle
 *
 */
    pub fn OCI_TypeInfoGetColumnCount(typinf: *mut OCI_TypeInfo)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the column object handle at the given index in the table
 *
 * @param typinf - Type info handle
 * @param index  - Column position
 *
 * @return
 * - Column handle on success
 * - NULL if index is out of bounds or on error
 *
 */
    pub fn OCI_TypeInfoGetColumn(typinf: *mut OCI_TypeInfo,
                                 index: ::std::os::raw::c_uint)
     -> *mut OCI_Column;
}
extern "C" {
    /**
 * @brief
 * Return the name described by the type info object
 *
 * @param typinf - Type info handle
 *
 */
    pub fn OCI_TypeInfoGetName(typinf: *mut OCI_TypeInfo) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Perform 3 calls (prepare+execute+fetch) in 1 call
 *
 * @param con  - Connection handle
 * @param sql  - SQL statement
 * @param ...  - List of program variables address to store the result of fetch operation
 *
 * @note
 * Every output parameter MUST be preceded by an integer parameter that indicates the type
 * of the placeholder in order to handle correctly the given pointer.
 *
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_Immediate(con: *mut OCI_Connection, sql: *const otext, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Performs 4 call (prepare+bind+execute+fetch) in 1 call
 *
 * @param con  - Connection handle
 * @param sql  - SQL statement
 * @param ...  - List of program values to format the SQL followed by the
 *               output variables addresses for the fetch operation
 *
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ImmediateFmt(con: *mut OCI_Connection, sql: *const otext, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Prepare a formatted SQL statement or PL/SQL block.
 *
 * @param stmt - Statement handle
 * @param sql  - SQL statement
 * @param ...  - List of program values to format the SQL
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_PrepareFmt(stmt: *mut OCI_Statement, sql: *const otext, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Execute a formatted SQL statement or PL/SQL block.
 *
 * @param stmt - Statement handle
 * @param sql  - SQL statement
 * @param ...  - List of program values to format the SQL
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 * @warning
 * If a SQL warning occurs:
 * - the function returns TRUE
 * - the SQL warning triggers the global error handler with an OCI_Error having its OCI_ErrorGetType()
 *   attribute set to OCI_ERR_WARNING
 * - If OCILIB is initialized with the OCI_ENV_CONTEXT mode, OCI_GetLastError() will return the OCI_Error
 *   object corresponding to the warning
 *
 */
    pub fn OCI_ExecuteStmtFmt(stmt: *mut OCI_Statement,
                              sql: *const otext, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Parse a formatted SQL statement or PL/SQL block.
 *
 * @param stmt - Statement handle
 * @param sql  - SQL statement
 * @param ...  - List of program values to format the SQL
 *
 * @note
 * This call sends the SQL or PL/SQL command to the server for parsing only.
 * The command is not executed.
 * This call is only useful to check is a command is valid or not.
 *
 * @note
 * This call prepares the statement (internal call to OCI_Prepare()) and ask
 * the Oracle server to parse its SQL or PL/SQL command.
 * OCI_Execute() can be call after OCI_ParseFmt() in order to execute the
 * statement, which means that the server will re-parse again the command.
 *
 * @warning
 * Do not use OCI_ParseFmt() unless you're only interested in the parsing result
 * because the statement will be parsed again when executed and thus leading to
 * unnecessary server round-trips and less performance
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ParseFmt(stmt: *mut OCI_Statement, sql: *const otext, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Describe the select list of a formatted SQL select statement.
 *
 * @param stmt - Statement handle
 * @param sql  - SQL statement
 * @param ...  - List of program values to format the SQL
 *
 * @note
 * This call sends the SELECT SQL order to the server for retrieving the
 * description of the select order only.
 * The command is not executed.
 * This call is only useful to retrieve information on the associated resultset
 * Call OCI_GetResultet() after OCI_Describe() to access to SELECT list
 * information
 *
 * @note
 * This call prepares the statement (internal call to OCI_Prepare()) and ask
 * the Oracle server to describe the output SELECT list.
 * OCI_Execute() can be call after OCI_Desbribe() in order to execute the
 * statement, which means that the server will parse, and describe again the SQL
 * order.
 *
 * @warning
 * Do not use OCI_Desbribe() unless you're only interested in the resultset
 * information because the statement will be parsed again when executed and thus
 * leading to unnecessary server round-trips and less performance
 *
 * @return
 * TRUE on success otherwise FALSE
 */
    pub fn OCI_DescribeFmt(stmt: *mut OCI_Statement, sql: *const otext, ...)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create a hash table
 *
 * @param size     - size of the hash table
 * @param type     - type of the hash table
 *
 * @note
 * Parameter can be one of the following values :
 *
 * - OCI_HASH_STRING  : string values
 * - OCI_HASH_INTEGER : integer values
 * - OCI_HASH_POINTER : pointer values
 *
 * @return
 * Hash handle on success or NULL on failure
 *
 */
    pub fn OCI_HashCreate(size: ::std::os::raw::c_uint,
                          type_: ::std::os::raw::c_uint)
     -> *mut OCI_HashTable;
}
extern "C" {
    /**
 * @brief
 * Destroy a hash table
 *
 * @param table - Table handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_HashFree(table: *mut OCI_HashTable) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the size of the hash table
 *
 * @param table  - Table handle
 *
 */
    pub fn OCI_HashGetSize(table: *mut OCI_HashTable)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the type of the hash table
 *
 * @param table  - Table handle
 *
 * @note
 * the return value can be one of the following values :
 *
 * - OCI_HASH_STRING  : string values
 * - OCI_HASH_INTEGER : integer values
 * - OCI_HASH_POINTER : pointer values
 *
 * @return
 * Hash table data type or OCI_UNKNOWN the input handle is NULL
 *
 */
    pub fn OCI_HashGetType(table: *mut OCI_HashTable)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Add a pair string key / string value to the hash table
 *
 * @param table  - Table handle
 * @param key    - String key
 * @param value  - string value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_HashAddString(table: *mut OCI_HashTable, key: *const otext,
                             value: *const otext) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the string value associated to the given key
 *
 * @param table  - Table handle
 * @param key    - String key
 *
 * @return
 * Stored string associated with the key otherwise NULL
 *
 */
    pub fn OCI_HashGetString(table: *mut OCI_HashTable, key: *const otext)
     -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Adds a pair string key / integer value to the hash table
 *
 * @param table  - Table handle
 * @param key    - String key
 * @param value  - Integer value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_HashAddInt(table: *mut OCI_HashTable, key: *const otext,
                          value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the integer value associated to the given key
 *
 * @param table  - Table handle
 * @param key    - String key
 *
 * @return
 * Stored integer associated with the key otherwise 0
 *
 */
    pub fn OCI_HashGetInt(table: *mut OCI_HashTable, key: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Adds a pair string key / pointer value to the hash table
 *
 * @param table  - Table handle
 * @param key    - String key
 * @param value  - Pointer value
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_HashAddPointer(table: *mut OCI_HashTable, key: *const otext,
                              value: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return a pointer associated with the given key
 *
 * @param table  - Table handle
 * @param key    - String key
 *
 * @return
 * Stored pointer associated with the key otherwise NULL
 *
 */
    pub fn OCI_HashGetPointer(table: *mut OCI_HashTable, key: *const otext)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Lookup for an entry matching the key in the table
 *
 * @param table  - Table handle
 * @param key    - String key
 * @param create - Do create the entry if not exists
 *
 * @return
 * Entry handle if key found/added otherwise NULL
 *
 */
    pub fn OCI_HashLookup(table: *mut OCI_HashTable, key: *const otext,
                          create: ::std::os::raw::c_int)
     -> *mut OCI_HashEntry;
}
extern "C" {
    /**
 * @brief
 * Return the first hash slot that matches the key
 *
 * @param table - Table handle
 * @param key   - String key
 *
 * @return
 * Slot handle if key found otherwise NULL
 *
 */
    pub fn OCI_HashGetValue(table: *mut OCI_HashTable, key: *const otext)
     -> *mut OCI_HashValue;
}
extern "C" {
    /**
 * @brief
 * Return the entry slot of the hash table internal list at the given position
 *
 * @param table - Table handle
 * @param index - index
 *
 * @warning
 * Index start at at
 *
 * @return
 * Slot handle otherwise NULL
 *
 */
    pub fn OCI_HashGetEntry(table: *mut OCI_HashTable,
                            index: ::std::os::raw::c_uint)
     -> *mut OCI_HashEntry;
}
extern "C" {
    /**
 * @brief
 * Create a Mutex object
 *
 * @return
 * Mutex handle on success or NULL on failure
 *
 */
    pub fn OCI_MutexCreate() -> *mut OCI_Mutex;
}
extern "C" {
    /**
 * @brief
 * Destroy a mutex object
 *
 * @param mutex - Mutex handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_MutexFree(mutex: *mut OCI_Mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Acquire a mutex lock
 *
 * @param mutex - Mutex handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_MutexAcquire(mutex: *mut OCI_Mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Release a mutex lock
 *
 * @param mutex - Mutex handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_MutexRelease(mutex: *mut OCI_Mutex) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create a Thread object
 *
 * @return
 * Thread handle on success or NULL on failure
 *
 */
    pub fn OCI_ThreadCreate() -> *mut OCI_Thread;
}
extern "C" {
    /**
 * @brief
 * Destroy a thread object
 *
 * @param thread - Thread handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ThreadFree(thread: *mut OCI_Thread) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Execute the given routine within the given thread object
 *
 * @param thread - Thread handle
 * @param proc   - routine to execute
 * @param arg    - parameter to pass to the routine
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ThreadRun(thread: *mut OCI_Thread, proc_: POCI_THREAD,
                         arg: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Join the given thread
 *
 * @param thread - Thread handle
 *
 * @note
 * This function waits for the given thread to finish
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ThreadJoin(thread: *mut OCI_Thread) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create a thread key object
 *
 * @param name     - Thread key name
 * @param destfunc - Thread key value destructor function
 *
 * @note
 * Parameter proc is optional. It's called when the thread terminates to allow
 * the program to deal with the thread specific value of the key
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ThreadKeyCreate(name: *const otext,
                               destfunc: POCI_THREADKEYDEST)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set a thread key value
 *
 * @param name  - Thread key name
 * @param value - user value to set
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_ThreadKeySetValue(name: *const otext,
                                 value: *mut ::std::os::raw::c_void)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get a thread key value
 *
 * @param name - Thread key name
 *
 * @return
 * Thread key value on success otherwise FALSE
 *
 */
    pub fn OCI_ThreadKeyGetValue(name: *const otext)
     -> *mut ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Create a direct path object
 *
 * @param typinf    - Table type info handle
 * @param partition - Partition name
 * @param nb_cols   - Number of columns to load
 * @param nb_rows   - Maximum of rows to handle per load operation
 *
 * @note
 * Retrieve the table type info handle with OCI_TypeInfoGet().
 * The partition name is not mandatory
 *
 * @note
 * Parameter 'nb_rows' is ignored for Oracle 8i. Prior to Oracle 9i, it's the
 * OCI client that decides of the number of rows to process per convert/load calls.
 * From Oracle 9i, OCI allows application to specify this value. Note that, the
 * OCI client might not accept the input value. After OCI_DirPathPrepare() has
 * been successfully called, OCI_DirPathGetMaxRows() returns the final number
 * of rows used for the given direct path operation.
 *
 * @return
 * Return the direct path handle on success otherwise NULL on failure
 *
 */
    pub fn OCI_DirPathCreate(typinf: *mut OCI_TypeInfo,
                             partition: *const otext,
                             nb_cols: ::std::os::raw::c_uint,
                             nb_rows: ::std::os::raw::c_uint)
     -> *mut OCI_DirPath;
}
extern "C" {
    /**
 * @brief
 * Free an OCI_DirPath handle
 *
 * @param dp - Direct path Handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DirPathFree(dp: *mut OCI_DirPath) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Describe a column to load into the given table
 *
 * @param dp      - Direct path Handle
 * @param index   - Column index
 * @param name    - Column name
 * @param maxsize - Maximum input value size for a column entry
 * @param format  - Date or numeric format to use
 *
 * @note
 * An error is thrown if :
 * - If the column specified by the 'name' parameter is not found in the table
 *   referenced by the type info handle passed to OCI_DirPathCreate()
 * - the index is out of bounds (= 0 or >= number of columns)
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DirPathSetColumn(dp: *mut OCI_DirPath,
                                index: ::std::os::raw::c_uint,
                                name: *const otext,
                                maxsize: ::std::os::raw::c_uint,
                                format: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Prepares the OCI direct path load interface before any rows can be converted
 * or loaded
 *
 * @param dp - Direct path Handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DirPathPrepare(dp: *mut OCI_DirPath) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the value of the given row/column array entry
 *
 * @param dp        - Direct path Handle
 * @param row       - Row index
 * @param index     - Column index
 * @param value     - Value to set
 * @param size      - Size of the input value
 * @param complete  - Is the entry content fully provided ?
 *
 * @note
 * Rows and columns indexes start at 1.
 *
 * @note
 * The 'size' parameter is expressed in number of :
 * - bytes for binary columns
 * - characters for other columns
 *
 * @note
 * Direct path support piece loading for LONGs and LOBs columns. When filling
 * these columns, it's possible to provide input buffer piece by piece. In order
 * to do so :
 * - set the 'complete' parameter to FALSE
 * - set the 'size' parameter to the piece size
 * - Repeat calls to OCI_DirPathSetEntry() until the data is totally provided
 * - The last call that set the last piece or an entry must specify the value
 *   TRUE for the 'complete' parameter
 *
 * @warning
 * Current Direct Path OCILIB implementation DOES NOT support setting entry
 * content piece by piece as mentioned above. It was planned in the original design
 * but not supported yet. So, always set the complete parameter to TRUE.
 * Setting entries content piece by piece may be supported in future releases
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DirPathSetEntry(dp: *mut OCI_DirPath,
                               row: ::std::os::raw::c_uint,
                               index: ::std::os::raw::c_uint,
                               value: *mut ::std::os::raw::c_void,
                               size: ::std::os::raw::c_uint,
                               complete: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Convert provided user data to the direct path stream format
 *
 * @param dp - Direct path Handle
 *
 * @return
 * Possible return values :
 * - OCI_DPR_COMPLETE : load has been successful
 * - OCI_DPR_ERROR    : an error happened while loading data
 * - OCI_DPR_FULL     : the internal stream is full
 * - OCI_DPR_PARTIAL  : a column hasn't been fully filled yet
 * - OCI_DPR_EMPTY    : no data was found to convert
 *
 * @note
 * - When using conversion mode OCI_DCM_DEFAULT, OCI_DirPathConvert() stops when
 *   any error is encountered and returns OCI_DPR_ERROR
 * - When using conversion mode OCI_DCM_FORCE, OCI_DirPathConvert() does not stop
 *   on errors. Instead it discards any erred rows and returns OCI_DPR_COMPLETE once
 *   all rows are processed.
 *
 * @note
 * List of faulted rows and columns can be retrieved using OCI_DirPathGetErrorRow() and
 * OCI_DirPathGetErrorColumn()
 *
 * @note
 * OCI_DirPathGetAffectedRows() returns the number of rows converted in the last call.
 *
 */
    pub fn OCI_DirPathConvert(dp: *mut OCI_DirPath) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Loads the data converted to direct path stream format
 *
 * @param dp - Direct path Handle
 *
 * @return
 * Possible return values :
 * - OCI_DPR_COMPLETE : conversion has been successful
 * - OCI_DPR_ERROR    : an error happened while converting data
 * - OCI_DPR_FULL     : the internal stream is full
 * - OCI_DPR_PARTIAL  : a column hasn't been fully filled yet
 * - OCI_DPR_EMPTY    : no data was found to load
 *
 * @note
 * List of faulted rows can be retrieved using OCI_DirPathGetErrorRow()
 *
 * @note
 * OCI_DirPathGetAffectedRows() returns the number of rows successfully loaded in the last call.
 *
 */
    pub fn OCI_DirPathLoad(dp: *mut OCI_DirPath) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Reset internal arrays and streams to prepare another load
 *
 * @param dp - Direct path Handle
 *
 * @note
 * Once some data have been converted or loaded, OCI_DirPathReset() resets
 * internal OCI structures in order to prepare another load operation
 * (set entries, convert and load)
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DirPathReset(dp: *mut OCI_DirPath) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Terminate a direct path operation and commit changes into the database
 *
 * @param dp - Direct path Handle
 *
 * @warning
 * The direct path handle cannot be used anymore after this call for any more
 * loading operations and must be freed with OCI_DirPathFree().
 *
 * @note
 * Some properties functions of the direct path handle, such as
 * OCI_DirPathGetRowCount() can be called on a terminated direct path handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DirPathFinish(dp: *mut OCI_DirPath) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Terminate a direct path operation without committing changes
 *
 * @param dp - Direct path Handle
 *
 * @note
 * Any pending loaded data are canceled.
 * Any load completion operations, such as index maintenance operations, are not performed.
 *
 * @warning
 * The direct path handle cannot be used anymore after this call for any more
 * loading operations and must be freed with OCI_DirPathFree().
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DirPathAbort(dp: *mut OCI_DirPath) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Execute a data save-point (server side)
 *
 * @param dp - Direct path Handle
 *
 * @note
 * Executing a data save-point is not allowed for LOBs
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DirPathSave(dp: *mut OCI_DirPath) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Flushes a partially loaded row from server
 *
 * @param dp - Direct path Handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DirPathFlushRow(dp: *mut OCI_DirPath) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the current number of rows to convert and load
 *
 * @param dp      - Direct path Handle
 * @param nb_rows - Number of row to process
 *
 * @warning
 * An OCILIB error will be thrown if the value exceeds the maximum number of
 * rows in the internals arrays
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DirPathSetCurrentRows(dp: *mut OCI_DirPath,
                                     nb_rows: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the current number of rows used in the OCILIB internal
 * arrays of rows
 *
 * @param dp - Direct path Handle
 *
 * @return
 * Internal current array size on SUCCESS otherwise 0
 *
 */
    pub fn OCI_DirPathGetCurrentRows(dp: *mut OCI_DirPath)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the maximum number of rows allocated in the OCI and OCILIB
 * internal arrays of rows
 *
 * @param dp - Direct path Handle
 *
 * @return
 * Internal maximum array size on SUCCESS otherwise 0
 *
 */
    pub fn OCI_DirPathGetMaxRows(dp: *mut OCI_DirPath)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set the default date format string for input conversion
 *
 * @param dp     - Direct path Handle
 * @param format - date format
 *
 * @note
 * For string to date conversion, Oracle uses :
 * - Column date format
 * - Default date format (modified by this call)
 * - Default global support environment setting
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DirPathSetDateFormat(dp: *mut OCI_DirPath,
                                    format: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the parallel loading mode
 *
 * @param dp    - Direct path Handle
 * @param value - enable/disable parallel mode
 *
 * @note
 * Default value is FALSE.
 *
 * @note
 * Setting the value to TRUE allows multiple load sessions to load the same
 * segment concurrently
 *
 * @par Parallel loading mode (From Oracle documentation)
 *
 * A direct load operation requires that the object being loaded is locked to
 * prevent DML on the object.
 * Note that queries are lock-free and are allowed while the object is being loaded.
 * - For a table load, if the option is set to:
 *   - FALSE, then the table DML X-Lock is acquired.
 *   - TRUE, then the table DML S-Lock is acquired.
 * - For a partition load, if the option is set to:
 *   - FALSE, then the table DML SX-Lock and partition DML X-Lock is acquired.
 *   - TRUE, then the table DML SS-Lock and partition DML S-Lock is acquired.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DirPathSetParallel(dp: *mut OCI_DirPath,
                                  value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the logging mode for the loading operation
 *
 * @param dp    - Direct path Handle
 * @param value - enable/disable logging
 *
 * @par Logging mode (from Oracle Documentation)
 *
 * The NOLOG attribute of each segment determines whether image redo or
 * invalidation redo is generated:
 * - FALSE : Use the attribute of the segment being loaded.
 * - TRUE  : No logging. Overrides DDL statement, if necessary.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DirPathSetNoLog(dp: *mut OCI_DirPath,
                               value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set number of elements in the date cache
 *
 * @param dp   - Direct path Handle
 * @param size - Buffer size
 *
 * @note
 * Default value is 0.
 *
 * @note
 * Setting the value to 0 disables the cache
 *
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DirPathSetCacheSize(dp: *mut OCI_DirPath,
                                   size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the size of the internal stream transfer buffer
 *
 * @param dp   - Direct path Handle
 * @param size - Buffer size
 *
 * @note
 * Default value is 64KB.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DirPathSetBufferSize(dp: *mut OCI_DirPath,
                                    size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the direct path conversion mode
 *
 * @param dp   - Direct path Handle
 * @param mode - Conversion mode
 *
 * @note
 * Possible values for parameter 'mode' :
 *   - OCI_DCM_DEFAULT : conversion fails on error
 *   - OCI_DCM_FORCE   : conversion does not fail on error
 *
 * @note
 * See OCI_DirPathConvert() for conversion mode details
 *
 * @note
 * Default value is OCI_DCM_DEFAULT
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DirPathSetConvertMode(dp: *mut OCI_DirPath,
                                     mode: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the number of rows successfully loaded into the database so far
 *
 * @param dp - Direct path Handle
 *
 * @note
 * Insertions are committed with OCI_DirPathFinish()
 *
 */
    pub fn OCI_DirPathGetRowCount(dp: *mut OCI_DirPath)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * return the number of rows successfully processed during in the last
 * conversion or loading call
 *
 * @param dp - Direct path Handle
 *
 * @note
 * This function called after :
 *
 * - OCI_DirPathConvert(), returns the number of converted rows
 * - OCI_DirPathload(), returns the number of loaded rows
 *
 */
    pub fn OCI_DirPathGetAffectedRows(dp: *mut OCI_DirPath)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the index of a column which caused an error during data conversion
 *
 * @param dp - Direct path Handle
 *
 * @warning
 * Direct path column indexes start at 1.
 *
 * @note
 * Errors may happen while data is converted to direct path stream format
 * using OCI_DirPathConvert().
 * When using conversion mode OCI_DCM_DEFAULT, OCI_DirPathConvert() returns
 * OCI_DPR_ERROR on error. OCI_DirPathGetErrorColumn() returns the column index
 * that caused the error
 * When using conversion mode OCI_DCM_FORCE, OCI_DirPathConvert() returns
 * OCI_DPR_COMPLETE even on errors. In order to retrieve the list of all column
 * indexes that have erred, the application can call OCI_DirPathGetErrorColumn()
 * repeatedly until it returns 0.
 *
 * @note
 * The internal value is reset to 0 when calling OCI_DirPathConvert()
 *
 * @return
 * 0 is no error occurs otherwise the index of the given column which caused an
 * error
 *
 */
    pub fn OCI_DirPathGetErrorColumn(dp: *mut OCI_DirPath)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the index of a row which caused an error during data conversion
 *
 * @param dp - Direct path Handle
 *
 * @warning
 * Direct path row indexes start at 1.
 *
 * @note
 * Errors may happen :
 * - while data is converted to direct path stream format using OCI_DirPathConvert()
 * - while data is loaded to database using OCI_DirPathLoad()
 *
 * @note
 * When using conversion mode OCI_DCM_DEFAULT, OCI_DirPathConvert() returns
 * OCI_DPR_ERROR on error. OCI_DirPathGetErrorRow() returns the row index that
 * caused the error.
 * When using conversion mode OCI_DCM_FORCE, OCI_DirPathConvert() returns
 * OCI_DPR_COMPLETE even on errors. In order to retrieve the list of all row
 * indexes that have erred, the application can call OCI_DirPathGetErrorRow()
 * repeatedly until it returns 0.
 *
 * @note
 * After a call to OCI_DirPathLoad(), in order to retrieve the list of all faulted rows
 * indexes, the application can call OCI_DirPathGetErrorRow() repeatedly until it returns 0.
 *
 * @note
 * The internal value is reset to 0 when calling OCI_DirPathConvert(),
 * OCI_DirPathReset() or OCI_DirPathLoad()
 *
 * @return
 * 0 is no error occurs otherwise the index of the given row which caused an
 * error
 *
 */
    pub fn OCI_DirPathGetErrorRow(dp: *mut OCI_DirPath)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Create a message object based on the given payload type
 *
 * @param typinf - Type info handle
 *
 * @note
 * OCILIB supports 2 type of message payload :
 * - Oracle types (UDT)
 * - RAW data
 *
 * @note
 * Oracle Type AnyData is not supported in the current version of OCILIB
 *
 * @note
 * the parameter 'typinf' indicates the type of payload :
 * - For object payload, retrieve the object type information handle with
 *   OCI_TypeInfoGet() using the object type name
 * - For RAW payload, you MUST pass the object type information retrieved with
 *   OCI_TypeInfoGet() using "SYS.RAW" as object type name
 *
 * @warning
 * Newly created Message handles have NULL payloads.
 * For Message handling Objects payloads, OCI_MsgGetObject() returns NULL until an object handle is
 * assigned to the message.
 *
 * @note
 * When a local OCI_Msg handle is enqueued, it keeps its attributes. If it's enqueued again, another
 * identical message is posted into the queue.
 * To reset a message and empty all its properties, call OCI_MsgReset()
 * Note that OCI_MsgReset() clears the message payload.
 *
 * @return
 * Return the message handle on success otherwise NULL on failure
 *
 */
    pub fn OCI_MsgCreate(typinf: *mut OCI_TypeInfo) -> *mut OCI_Msg;
}
extern "C" {
    /**
 * @brief
 * Free a message object
 *
 * @param msg - Message handle
 *
 * @warning
 * Only message handles created with OCI_MsgCreate() should be freed by OCI_MsgFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_MsgFree(msg: *mut OCI_Msg) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Reset all attributes of a message object
 *
 * @param msg - Message handle
 *
 * @note
 * This function calls OCI_MsgSetxxx() with default or NULL attributes
 *
 * @warning
 * OCI_MsgReset() clears the message payload and set it to NULL
 * For messages handling objects payloads, OCI_MsgSetObject() must be called again to assign a
 * payload.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_MsgReset(msg: *mut OCI_Msg) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the object payload of the given message
 *
 * @param msg - Message handle
 *
 * @return
 * Return the object handle on success otherwise NULL on failure or if payload is NULL
 *
 */
    pub fn OCI_MsgGetObject(msg: *mut OCI_Msg) -> *mut OCI_Object;
}
extern "C" {
    /**
 * @brief
 * Set the object payload of the given message
 *
 * @param msg - Message handle
 * @param obj - Object handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_MsgSetObject(msg: *mut OCI_Msg, obj: *mut OCI_Object)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the RAW payload of the given message
 *
 * @param msg  - Message handle
 * @param raw  - Input buffer
 * @param size - Input buffer maximum size
 *
 * @note
 * On output, parameter 'size' holds the number of bytes copied into the given buffer
 *
 * @return
 * TRUE on success otherwise FALSE on failure or if payload is object based.
 *
 */
    pub fn OCI_MsgGetRaw(msg: *mut OCI_Msg, raw: *mut ::std::os::raw::c_void,
                         size: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the RAW payload of the given message
 *
 * @param msg  - Message handle
 * @param raw  - Raw data
 * @param size - Raw data size
 *
 * @return
 * TRUE on success otherwise FALSE on failure or if payload is object based.
 *
 */
    pub fn OCI_MsgSetRaw(msg: *mut OCI_Msg,
                         raw: *const ::std::os::raw::c_void,
                         size: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the number of attempts that have been made to dequeue the message
 *
 * @param msg - Message handle
 *
 */
    pub fn OCI_MsgGetAttemptCount(msg: *mut OCI_Msg) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the number of seconds that a message is delayed for dequeuing
 *
 * @param msg - Message handle
 *
 * @note
 * see OCI_MsgSetEnqueueDelay() for more details
 *
 */
    pub fn OCI_MsgGetEnqueueDelay(msg: *mut OCI_Msg) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * set the number of seconds to delay the enqueued message
 *
 * @param msg   - Message handle
 * @param value - Delay in seconds
 *
 * @note
 * The delay represents the number of seconds after which a message is available for dequeuing.
 * When the message is enqueued, its state is set to OCI_AMS_WAITING.
 * When the delay expires, its state is set to OCI_AMS_READY.
 *
 * @note
 * If parameter 'value' is set to zero (default value), the message will be immediately available
 * for dequeuing
 *
 * @warning
 * Dequeuing by Message ID overrides the delay specification.
 *
 * @warning
 * Delaying processing requires the queue monitor to be started.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_MsgSetEnqueueDelay(msg: *mut OCI_Msg,
                                  value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * return the time the message was enqueued
 *
 * @param msg - Message handle
 *
 * @note
 * Only use this function for message dequeued from queues
 *
 */
    pub fn OCI_MsgGetEnqueueTime(msg: *mut OCI_Msg) -> *mut OCI_Date;
}
extern "C" {
    /**
 * @brief
 * Return the duration that the message is available for dequeuing
 *
 * @param msg - Message handle
 *
 * @note
 * see OCI_MsgSetExpiration() for more details
 *
 */
    pub fn OCI_MsgGetExpiration(msg: *mut OCI_Msg) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * set the duration that the message is available for dequeuing
 *
 * @param msg   - Message handle
 * @param value - duration in seconds
 *
 * @note
 * This parameter is an offset from the delay (see OCI_MsgSetEnqueueDelay())
 * While waiting for expiration, the message state is set to OCI_AMS_READY.
 * If the message is not dequeued before it expires, it will be moved to the exception queue
 * with the state OCI_AMS_EXPIRED.
 *
 * @note
 * If parameter 'value' is set to -1 (default value), the message will not expire
 *
 * @warning
 * Expiration processing requires the queue monitor to be started.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_MsgSetExpiration(msg: *mut OCI_Msg,
                                value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the state of the message at the time of the dequeue
 *
 * @param msg - Message handle
 *
 * @return
 *  - OCI_UNKNOWN       :  the function has failed to get the message state
 *  - OCI_AMS_READY     :  the message is ready to be processed
 *  - OCI_AMS_WAITING   :  the message delay has not yet completed
 *  - OCI_AMS_PROCESSED :  the message has been processed
 *  - OCI_AMS_EXPIRED   :  the message has moved to exception queue
 *
 */
    pub fn OCI_MsgGetState(msg: *mut OCI_Msg) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the priority of the message
 *
 * @param msg - Message handle
 *
 * @note
 * see OCI_MsgSetPriority() for more details
 *
 */
    pub fn OCI_MsgGetPriority(msg: *mut OCI_Msg) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the priority of the message
 *
 * @param msg   - Message handle
 * @param value - Message priority
 *
 * @note
 *   - The priority can be any number, including negative numbers.
 *   - A smaller number indicates higher priority.
 *   - Default value is zero.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_MsgSetPriority(msg: *mut OCI_Msg, value: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the ID of the message
 *
 * @param msg - Message handle
 * @param id  - Input buffer
 * @param len - Input buffer maximum size
 *
 * @note
 * The message ID is :
 *  - generated when the message is enqueued in the queue
 *  - retrieved when the message is dequeued from the queue
 *
 * @note
 * On output, parameter 'len' holds the number of bytes copied into the given buffer
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_MsgGetID(msg: *mut OCI_Msg, id: *mut ::std::os::raw::c_void,
                        len: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the original ID of the message in the last queue that generated this message
 *
 * @param msg - Message handle
 * @param id  - Input buffer
 * @param len - Input buffer maximum size
 *
 * @warning
 * When a message is propagated from/to different queues, this ID is the one generated for the
 * message in the previous queue.
 *
 * @note
 * On output, parameter 'len' holds the number of bytes copied into the given buffer
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_MsgGetOriginalID(msg: *mut OCI_Msg,
                                id: *mut ::std::os::raw::c_void,
                                len: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the original ID of the message in the last queue that generated this message
 *
 * @param msg  - Message handle
 * @param id   - Message ID
 * @param len  - Message ID size
 *
 * @warning
 * When a message is propagated from/to different queues, this ID is the one generated for the
 * message in the previous queue.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_MsgSetOriginalID(msg: *mut OCI_Msg,
                                id: *const ::std::os::raw::c_void,
                                len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the original sender of a message
 *
 * @param msg    - Message handle
 *
 * @return
 * Sender Handle (OCI_Agent *) on success (if set at enqueue time) otherwise NULL
 *
 */
    pub fn OCI_MsgGetSender(msg: *mut OCI_Msg) -> *mut OCI_Agent;
}
extern "C" {
    /**
 * @brief
 * Set the original sender of a message
 *
 * @param msg    - Message handle
 * @param sender - Message sender
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_MsgSetSender(msg: *mut OCI_Msg, sender: *mut OCI_Agent)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the recipient list of a message to enqueue
 *
 * @param msg       - Message handle
 * @param consumers - Recipients list (array of agent handles)
 * @param count     - Number of recipients
 *
 * @warning
 * This function should only be used for queues which allow multiple consumers.
 * The default recipients are the queue subscribers.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_MsgSetConsumers(msg: *mut OCI_Msg,
                               consumers: *mut *mut OCI_Agent,
                               count: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the correlation identifier of the message
 *
 * @param msg - Message handle
 *
 * @note
 * see OCI_MsgSetCorrelation() for more details
 *
 */
    pub fn OCI_MsgGetCorrelation(msg: *mut OCI_Msg) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * set the correlation identifier of the message
 *
 * @param msg         - Message handle
 * @param correlation - Message correlation text
 *
 * @note
 * see OCI_DequeueSetCorrelation()  for more details
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_MsgSetCorrelation(msg: *mut OCI_Msg, correlation: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the Exception queue name of the message
 *
 * @param msg - Message handle
 *
 * @warning
 * When calling this function on a message retrieved with OCI_DequeueGet(), the returned value is
 * NULL if the default exception queue associated with the current queue is used (e.g. no user
 * defined specified at enqueue time for the message)
 *
 * @note
 * see OCI_MsgSetExceptionQueue() for more details
 *
 */
    pub fn OCI_MsgGetExceptionQueue(msg: *mut OCI_Msg) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Set the name of the queue to which the message is moved to if it cannot be
 * processed successfully
 *
 * @param msg   - Message handle
 * @param queue - Exception queue name
 *
 * @warning
 * From Oracle Documentation :
 *
 * "Messages are moved into exception queues in two cases :
 *  - If the number of unsuccessful dequeue attempts has exceeded the attribute 'max_retries' of
 *    given queue
 *  - if the message has expired.
 *
 * All messages in the exception queue are in the EXPIRED state.
 *
 * The default is the exception queue associated with the queue table.
 *
 * If the exception queue specified does not exist at the time of the move the message will be
 * moved to the default exception queue associated with the queue table and a warning will be
 * logged in the alert file.
 *
 * This attribute must refer to a valid queue name."
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_MsgSetExceptionQueue(msg: *mut OCI_Msg, queue: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create a Enqueue object for the given queue
 *
 * @param typinf - Type info handle
 * @param name   - Queue name
 *
 * @note
 * OCILIB supports 2 type of message payload :
 * - Oracle types (UDT)
 * - RAW data
 *
 * @note
 * Oracle Type AnyData is not supported in the current version of OCILIB
 *
 * @note
 * the parameter 'typinf' indicates the type of payload to enqueue to the given queue :
 * - For object payload, retrieve the object type information handle with
 *   OCI_TypeInfoGet() using the object type name
 * - For RAW payload, you MUST pass the object type information retrieved with
 *   OCI_TypeInfoGet() using "SYS.RAW" as object type name
 *
 * @return
 * Return the Enqueue handle on success otherwise NULL on failure
 *
 */
    pub fn OCI_EnqueueCreate(typinf: *mut OCI_TypeInfo, name: *const otext)
     -> *mut OCI_Enqueue;
}
extern "C" {
    /**
 * @brief
 * Free a Enqueue object
 *
 * @param enqueue - Enqueue handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_EnqueueFree(enqueue: *mut OCI_Enqueue)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Enqueue a message on the queue associated to the Enqueue object
 *
 * @param enqueue - Enqueue handle
 * @param msg     - Message handle to enqueue
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_EnqueuePut(enqueue: *mut OCI_Enqueue, msg: *mut OCI_Msg)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
* @brief
* Set the enqueuing sequence of messages to put in the queue
*
* @param enqueue  - Enqueue handle
* @param sequence - enqueuing sequence
*
* @note
* Possible values for parameter 'sequence' :
*   - OCI_ASD_BEFORE : enqueue message before another message
*   - OCI_ASD_TOP    : enqueue message before all messages
*
* @note
* Default value is OCI_ASD_TOP
*
* @note
* if the parameter 'sequence' is set to OCI_ASD_BEFORE, the application must
* call OCI_EnqueueSetRelativeMsgID() before enqueuing the next message in the queue.
*
* @note
* In order to stop enqueuing message using a sequence deviation, call
* OCI_EnqueueSetSequenceDeviation() with the value OCI_ASD_TOP
*
* @return
* TRUE on success otherwise FALSE
*
*/
    pub fn OCI_EnqueueSetSequenceDeviation(enqueue: *mut OCI_Enqueue,
                                           sequence: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the sequence deviation of messages to enqueue to the queue
 *
 * @param enqueue - Enqueue handle
 *
 * @note
 * see OCI_EnqueueSetSequenceDeviation() for more details
 *
 */
    pub fn OCI_EnqueueGetSequenceDeviation(enqueue: *mut OCI_Enqueue)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set whether the new message is enqueued as part of the current transaction
 *
 * @param enqueue    - Enqueue handle
 * @param visibility - Enqueuing visibility
 *
 * @note
 * Possible values for parameter 'visibility' :
 *   - OCI_AMV_IMMEDIATE : enqueue is an independent transaction
 *   - OCI_AMV_ON_COMMIT : enqueue is part of current transaction
 *
 * @note
 * Default value is OCI_AMV_ON_COMMIT
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_EnqueueSetVisibility(enqueue: *mut OCI_Enqueue,
                                    visibility: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the enqueuing/locking behavior
 *
 * @param enqueue - Enqueue handle
 *
 * @note
 * see OCI_EnqueueSetVisibility() for more details
 *
 */
    pub fn OCI_EnqueueGetVisibility(enqueue: *mut OCI_Enqueue)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set a message identifier to use for enqueuing messages using a sequence deviation
 *
 * @param enqueue - Enqueue handle
 * @param id      - message identifier
 * @param len     - pointer to message identifier length
 *
 * @note
 * This call is only valid if OCI_EnqueueSetSequenceDeviation() has been called
 * with the value  OCI_ASD_BEFORE
 *
 * @warning
 * if the function cannot assign the message id, the content of the parameter 'len' is set to zero.
 *
 * @note
 * see OCI_EnqueueSetSequenceDeviation() for more details
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_EnqueueSetRelativeMsgID(enqueue: *mut OCI_Enqueue,
                                       id: *const ::std::os::raw::c_void,
                                       len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the current associated message identifier used for enqueuing messages
 * using a sequence deviation
 *
 * @param enqueue - Enqueue handle
 * @param id      - buffer to receive the message identifier
 * @param len     - pointer to buffer max length
 *
 * @warning
 * When the function returns, parameter 'len' hold the number of bytes assigned to parameter 'id'
 *
 * @note
 * see OCI_EnqueueGetRelativeMsgID() for more details
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_EnqueueGetRelativeMsgID(enqueue: *mut OCI_Enqueue,
                                       id: *mut ::std::os::raw::c_void,
                                       len: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create a Dequeue object for the given queue
 *
 * @param typinf - Type info handle
 * @param name   - Queue name
 *
 * @note
 * OCILIB supports 2 type of message payload :
 * - Oracle types (UDT)
 * - RAW data
 *
 * @note
 * Oracle Type AnyData is not supported in the current version of OCILIB
 *
 * @note
 * the parameter 'typinf' indicates the type of payload to dequeue from the given queue :
 * - For object payload, retrieve the object type information handle with
 *   OCI_TypeInfoGet() using the object type name
 * - For RAW payload, you MUST pass the object type information retrieved with
 *   OCI_TypeInfoGet() using "SYS.RAW" as object type name
 *
 * @return
 * Return the Dequeue handle on success otherwise NULL on failure
 *
 */
    pub fn OCI_DequeueCreate(typinf: *mut OCI_TypeInfo, name: *const otext)
     -> *mut OCI_Dequeue;
}
extern "C" {
    /**
 * @brief
 * Free a Dequeue object
 *
 * @param dequeue - Dequeue handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DequeueFree(dequeue: *mut OCI_Dequeue)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Dequeue messages from the given queue
 *
 * @param dequeue - Dequeue handle
 *
 * @warning
 * The returned message is handled by the dequeue object.
 * Do not release it with OCI_MsgFree()
 *
 * @warning
 * When dequeuing from a multiple consumer queue, you need
 * to set the navigation mode to OCI_ADN_FIRST_MSG using
 * OCI_DequeueSetNavigation()
 *
 * @return
 * Message handle on success otherwise NULL on failure or on timeout
 *
 */
    pub fn OCI_DequeueGet(dequeue: *mut OCI_Dequeue) -> *mut OCI_Msg;
}
extern "C" {
    /**
 * @brief
 * Subscribe for asynchronous messages notifications
 *
 * @param dequeue  - Dequeue handle
 * @param port     - Port to use for notifications
 * @param timeout  - notification timeout
 * @param callback - User handler callback fired when messages are ready to be dequeued
 *
 * @note
 * OCI_ENV_EVENTS flag must be passed to OCI_Initialize() to be able to use
 * asynchronous messages notifications
 *
 * @note
 * Requires Oracle Client 10gR2 or above
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DequeueSubscribe(dequeue: *mut OCI_Dequeue,
                                port: ::std::os::raw::c_uint,
                                timeout: ::std::os::raw::c_uint,
                                callback: POCI_NOTIFY_AQ)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Unsubscribe for asynchronous messages notifications
 *
 * @param dequeue - Dequeue handle
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DequeueUnsubscribe(dequeue: *mut OCI_Dequeue)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the current consumer name to retrieve message for.
 *
 * @param dequeue  - Dequeue handle
 * @param consumer - consumer name
 *
 * @warning
 * If a queue is not set up for multiple consumers, OCI_DequeueSetConsumer()
 * should not be called or called with parameter 'consumer' set to NULL
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DequeueSetConsumer(dequeue: *mut OCI_Dequeue,
                                  consumer: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the current consumer name associated with the dequeuing process.
 *
 * @param dequeue - Dequeue handle
 *
 * @note
 * see OCI_DequeueSetConsumer() for more details
 *
 */
    pub fn OCI_DequeueGetConsumer(dequeue: *mut OCI_Dequeue) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * set the correlation identifier of the message to be dequeued
 *
 * @param dequeue - Dequeue handle
 * @param pattern - correlation identifier
 *
 * @note
 * Special pattern matching characters, such as "%" or "_" can be used.
 * If more than one message satisfies the pattern, the order of dequeuing is undetermined.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DequeueSetCorrelation(dequeue: *mut OCI_Dequeue,
                                     pattern: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the correlation identifier of the message to be dequeued
 *
 * @param dequeue - Dequeue handle
 *
 * @note
 * see OCI_DequeueSetCorrelation() for more details
 *
 */
    pub fn OCI_DequeueGetCorrelation(dequeue: *mut OCI_Dequeue)
     -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Set the message identifier of the message to be dequeued
 *
 * @param dequeue - Dequeue handle
 * @param id      - message identifier
 * @param len     - size of the message identifier
 *
 * @warning
 * if the function cannot assign the message id, the content of the parameter 'len' is set to zero.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DequeueSetRelativeMsgID(dequeue: *mut OCI_Dequeue,
                                       id: *const ::std::os::raw::c_void,
                                       len: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the message identifier of the message to be dequeued
 *
 * @param dequeue - Dequeue handle
 * @param id      - message identifier
 * @param len     - size of the message identifier
 *
 * @warning
 * When the function returns, parameter 'len' hold the number of bytes assigned to parameter 'id'
 *
 * @note
 * see OCI_DequeueSetRelativeMsgID() for more details
 *
 */
    pub fn OCI_DequeueGetRelativeMsgID(dequeue: *mut OCI_Dequeue,
                                       id: *mut ::std::os::raw::c_void,
                                       len: *mut ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set whether the new message is dequeued as part of the current transaction
 *
 * @param dequeue    - Dequeue handle
 * @param visibility - dequeuing mode
 *
 * @warning
 * The visibility parameter is ignored when using the OCI_ADM_BROWSE dequeuing
 * mode (see OCI_DequeueSetMode())
 *
 * @note
 * Possible values for parameter 'mode' :
 *   - OCI_AMV_IMMEDIATE : dequeue is an independent transaction
 *   - OCI_AMV_ON_COMMIT : dequeue is part of current transaction
 *
 * @note
 * Default value is OCI_AMV_ON_COMMIT
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DequeueSetVisibility(dequeue: *mut OCI_Dequeue,
                                    visibility: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the dequeuing/locking behavior
 *
 * @param dequeue - Dequeue handle
 *
 * @note
 * see OCI_DequeueSetVisibility() for more details
 *
 */
    pub fn OCI_DequeueGetVisibility(dequeue: *mut OCI_Dequeue)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set the dequeuing/locking behavior
 *
 * @param dequeue - Dequeue handle
 * @param mode    - dequeuing mode
 *
 * @note
 * Possible values for parameter 'mode' :
 *   - OCI_ADM_BROWSE        : read message without acquiring a lock
 *   - OCI_ADM_LOCKED        : read and obtain write lock on message
 *   - OCI_ADM_REMOVE        : read the message and delete it
 *   - OCI_ADM_REMOVE_NODATA : confirm receipt of the message, but do not
 *                             deliver the actual message content
 *
 * @note
 * Default value is OCI_ADM_REMOVE
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DequeueSetMode(dequeue: *mut OCI_Dequeue,
                              mode: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the dequeuing/locking behavior
 *
 * @param dequeue - Dequeue handle
 *
 * @note
 * see OCI_DequeueSetMode() for more details
 *
 */
    pub fn OCI_DequeueGetMode(dequeue: *mut OCI_Dequeue)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Set the position of messages to be retrieved.
 *
 * @param dequeue  - Dequeue handle
 * @param position - navigation position
 *
 * @note
 * The dequeuing uses the following sequence :
 *   - find messages using the navigation position
 *   - apply search criteria (message correlation)
 *   - get message
 *
 * @note
 * Possible values for parameter 'position' :
 *   - OCI_ADN_FIRST_MSG        : retrieves the first message which is available
 *   - OCI_ADN_NEXT_MSG         : retrieves the next message which is available
 *   - OCI_ADN_NEXT_TRANSACTION : skips the remainder of the current transaction
 *                                group (if any) and retrieves the first message
 *                                of the next transaction group.
 *
 * @note
 * Default value is OCI_ADN_NEXT_MSG
 *
 * @warning
 * OCI_ADN_NEXT_TRANSACTION can only be used if message grouping is enabled for the given queue.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DequeueSetNavigation(dequeue: *mut OCI_Dequeue,
                                    position: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the navigation position of messages to retrieve from the queue
 *
 * @param dequeue - Dequeue handle
 *
 * @note
 * see OCI_DequeueSetNavigation() for more details
 *
 */
    pub fn OCI_DequeueGetNavigation(dequeue: *mut OCI_Dequeue)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * set the time that OCIDequeueGet() waits for messages if no messages are
 * currently available
 *
 * @param dequeue - Dequeue handle
 * @param timeout - timeout in seconds
 *
 *@note
 * - Any positive values in seconds are valid.
 * - The value 0  is accepted and means OCIDequeueGet() does not wait for
 *   messages and returns immediately if no messages are available
 * - The value -1 is accepted and means OCIDequeueGet() waits for ever (until
 *   a message is available in the queue)
 *
 * @note
 * Default value is -1 (wait for ever)
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DequeueSetWaitTime(dequeue: *mut OCI_Dequeue,
                                  timeout: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the time that OCIDequeueGet() waits for messages if no messages are currently available
 *
 * @param dequeue - Dequeue handle
 *
 * @note
 * see OCI_DequeueSetWaitTime() for more details
 *
 */
    pub fn OCI_DequeueGetWaitTime(dequeue: *mut OCI_Dequeue)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the Agent list to listen to message for
 *
 * @param dequeue   - Dequeue handle
 * @param consumers - Agent handle array
 * @param count     - Number of agents the array
 *
 * @return
 * return TRUE on success otherwise FALSE
 */
    pub fn OCI_DequeueSetAgentList(dequeue: *mut OCI_Dequeue,
                                   consumers: *mut *mut OCI_Agent,
                                   count: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Listen for messages that match any recipient of the associated Agent list
 *
 * @param dequeue - Dequeue handle
 * @param timeout - Timeout in second
 *
 * @note
 * If an Agent handle is returned, messages are available for this agent.
 * In order to retrieve its messages :
 * - call OCI_DequeueSetConsumer() with the name of agent using OCI_AgentGetName()
 * - call OCI_DequeueGet() to dequeue it's pending messages
 *
 * @warning
 * The return value is valid only until:
 * - OCIDequeueListen() is called again
 * - OCI_DequeueFree(� is called to free the Dequeue object
 * So Do not store the handle value across calls to OCIDequeueListen()
 *
 * @return
 * An Agent handle for who messages are available on success otherwise NULL
 */
    pub fn OCI_DequeueListen(dequeue: *mut OCI_Dequeue,
                             timeout: ::std::os::raw::c_int)
     -> *mut OCI_Agent;
}
extern "C" {
    /**
 * @brief
 * Create an AQ agent object
 *
 * @param con     - Connection handle
 * @param name    - Agent name
 * @param address - Agent address
 *
 * @note
 * An AQ agent object is :
 * - used as recipient information when enqueuing a message
 * - used as sender information when dequeuing a message
 * - used for listening message only from identified senders
 *
 * @note
 * the AQ agent address can be any Oracle identifier, up to 128 bytes.
 * the AQ agent name    can be any Oracle identifier, up to 30  bytes.
 *
 * @return
 * AQ agent handle on success otherwise NULL
 *
 */
    pub fn OCI_AgentCreate(con: *mut OCI_Connection, name: *const otext,
                           address: *const otext) -> *mut OCI_Agent;
}
extern "C" {
    /**
 * @brief
 * Free an AQ agent object
 *
 * @param agent - AQ agent handle
 *
 * @warning
 * Only AQ agent handle created with OCI_AgentCreate() should be freed by OCI_AgentFree()
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_AgentFree(agent: *mut OCI_Agent) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Set the given AQ agent name
 *
 * @param agent - AQ agent handle
 * @param name  - AQ agent name
 *
 * @note
 * the AQ agent name is used to identified an message send or recipient when enqueuing/dequeuing
 * a message
 *
 * @note
 * the AQ agent name can be any Oracle identifier, up to 30 bytes.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_AgentSetName(agent: *mut OCI_Agent, name: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the given AQ agent name
 *
 * @param agent - AQ agent handle
 *
 * @return
 * AQ agent name on success otherwise NULL on failure
 *
 */
    pub fn OCI_AgentGetName(agent: *mut OCI_Agent) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Set the given AQ agent address
 *
 * @param agent   - AQ agent handle
 * @param address - AQ agent address
 *
 * @note
 * the parameter 'address' must be of the form : [schema.]queue_name[\@dblink]
 *
 * @note
 * the AQ agent address can be any Oracle identifier, up to 128 bytes.
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_AgentSetAddress(agent: *mut OCI_Agent, address: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Get the given AQ agent address
 *
 * @param agent - AQ agent handle
 *
 * @note
 * See OCI_AgentSetAddress()
 *
 * @return
 * AQ agent address on success otherwise NULL on failure
 *
 */
    pub fn OCI_AgentGetAddress(agent: *mut OCI_Agent) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Create a queue
 *
 * @param con                   - Connection handle
 * @param queue_name            - Queue name
 * @param queue_table           - Queue table name
 * @param queue_type            - Queue type
 * @param max_retries           - Maximum number of attempts to dequeue a message
 * @param retry_delay           - Number of seconds between attempts to dequeue a message
 * @param retention_time        - number of seconds a message is retained in the queue table after
 *                                being dequeued from the queue
 * @param dependency_tracking   - Parameter reserved for future use by Oracle (MUST be set to FALSE)
 * @param comment               - Description of the queue
 *
 * @note
 * Parameter 'queue_name' can specify the schema where to create to queue ([schema.]queue_name)
 * Queue names cannot be longer than 24 characters (Oracle limit for user queues)
 *
 * @note
 * Possible values for parameter 'queue_type' :
 *  - OCI_AQT_NORMAL            : Normal queue
 *  - OCI_AQT_EXCEPTION         : Exception queue
 *  - OCI_AQT_NON_PERSISTENT    : Non persistent queue
 *
 * To set default values, pass :
 *  - queue_type     : OCI_AQT_NORMAL
 *  - max_retries    : 0
 *  - retry_delay    : 0
 *  - retention_time : 0
 *  - comment        : NULL
 *
 * @note
 * this call wraps the PL/SQL procedure DBMS_AQADM.CREATE_QUEUE().
 * Refer to Oracle Streams - Advanced Queuing User's Guide for more details
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_QueueCreate(con: *mut OCI_Connection, queue_name: *const otext,
                           queue_table: *const otext,
                           queue_type: ::std::os::raw::c_uint,
                           max_retries: ::std::os::raw::c_uint,
                           retry_delay: ::std::os::raw::c_uint,
                           retention_time: ::std::os::raw::c_uint,
                           dependency_tracking: ::std::os::raw::c_int,
                           comment: *const otext) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Alter the given queue
 *
 * @param con                   - Connection handle
 * @param queue_name            - Queue name
 * @param max_retries           - Maximum number of attempts to dequeue a message
 * @param retry_delay           - Number of seconds between attempts to dequeue a message
 * @param retention_time        - number of seconds a message is retained in the queue table after
 *                                being dequeued from the queue
 * @param comment               - Description of the queue
 *
 * @note
 * See OCI_QueueCreate() for more details
 *
 * @warning
 * This function updates all attributes handled in the parameter list !
 *
 * @note
 * this call wraps the PL/SQL procedure DBMS_AQADM.ALTER_QUEUE().
 * Refer to Oracle Streams - Advanced Queuing User's Guide for more details
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_QueueAlter(con: *mut OCI_Connection, queue_name: *const otext,
                          max_retries: ::std::os::raw::c_uint,
                          retry_delay: ::std::os::raw::c_uint,
                          retention_time: ::std::os::raw::c_uint,
                          comment: *const otext) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Drop the given queue
 *
 * @param con        - Connection handle
 * @param queue_name - Queue name
 *
 * @warning
 * A queue can be dropped only if it has been stopped before.
 *
 * @note
 * this call wraps the PL/SQL procedure DBMS_AQADM.DROP_QUEUE().
 * Refer to Oracle Streams - Advanced Queuing User's Guide for more details
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_QueueDrop(con: *mut OCI_Connection, queue_name: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Start the given queue
 *
 * @param con        - Connection handle
 * @param queue_name - Queue name
 * @param enqueue    - Enable enqueue
 * @param dequeue    - Enable dequeue
 *
 * @warning
 * For exception queues, only enqueuing is allowed
 *
 * @note
 * this call wraps the PL/SQL procedure DBMS_AQADM.START_QUEUE().
 * Refer to Oracle Streams - Advanced Queuing User's Guide for more details
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_QueueStart(con: *mut OCI_Connection, queue_name: *const otext,
                          enqueue: ::std::os::raw::c_int,
                          dequeue: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Stop enqueuing or dequeuing or both on the given queue
 *
 * @param con        - Connection handle
 * @param queue_name - Queue name
 * @param enqueue    - Disable enqueue
 * @param dequeue    - Disable dequeue
 * @param wait       - Wait for current pending enqueues/dequeues
 *
 * @warning
 * A queue cannot be stopped if there are pending transactions against the queue.
 *
 * @note
 * this call wraps the PL/SQL procedure DBMS_AQADM.STOP_QUEUE().
 * Refer to Oracle Streams - Advanced Queuing User's Guide for more details
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_QueueStop(con: *mut OCI_Connection, queue_name: *const otext,
                         enqueue: ::std::os::raw::c_int,
                         dequeue: ::std::os::raw::c_int,
                         wait: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Create a queue table for messages of the given type
 *
 * @param con                   - Connection handle
 * @param queue_table           - Queue table name
 * @param queue_payload_type    - Message type name
 * @param storage_clause        - Additional clauses for the table storage
 * @param sort_list             - Additional columns name to use for sorting
 * @param multiple_consumers    - Enable multiple consumers for each messages
 * @param message_grouping      - Specifies if messages are grouped within a transaction
 * @param comment               - Description of the queue table
 * @param primary_instance      - primary owner (instance) of the queue table
 * @param secondary_instance    - Owner of the queue table if the primary instance is not available
 * @param compatible            - lowest database version with which the queue table is compatible
 *
 * @note
 * Parameter 'queue_table' can specify the schema where to create to queue table ([schema.]queue_table)
 * Queue table names cannot be longer than 24 characters (Oracle limit for user queue tables)
 *
 * @note
 * Possible values for parameter 'queue_payload_type' :
 * - For Oracle types (UDT) : use the type name ([schema.].type_name)
 * - For RAW data           : use "SYS.RAW" or "RAW"
 *
 * @note
 * Possible values for parameter 'message_grouping' :
 *  - OCI_AGM_NONE            : each message is treated individually
 *  - OCI_AGM_TRANSACTIONNAL  : all messages enqueued in one transaction are considered part of
 *                              the same group and can be dequeued as a group of related messages.
 *
 * @note
 * Possible values for parameter 'compatible' :
 * - "8.0", "8.1", "10.0"
 *
 * To set default values, pass :
 *  - storage_clause    : NULL
 *  - sort_list         : NULL
 *  - message_grouping  : OCI_AGM_NONE
 *  - comment           : NULL
 *  - primary_instance  : 0
 *  - primary_instance  : 0
 *  - compatible        : NULL
 *
 * @note
 * this call wraps the PL/SQL procedure DBMS_AQADM.CREATE_QUEUE_TABLE().
 * Refer to Oracle Streams - Advanced Queuing User's Guide for more details
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_QueueTableCreate(con: *mut OCI_Connection,
                                queue_table: *const otext,
                                queue_payload_type: *const otext,
                                storage_clause: *const otext,
                                sort_list: *const otext,
                                multiple_consumers: ::std::os::raw::c_int,
                                message_grouping: ::std::os::raw::c_uint,
                                comment: *const otext,
                                primary_instance: ::std::os::raw::c_uint,
                                secondary_instance: ::std::os::raw::c_uint,
                                compatible: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Alter the given queue table
 *
 * @param con                   - Connection handle
 * @param queue_table           - Queue table name
 * @param comment               - Description of the queue table
 * @param primary_instance      - primary owner (instance) of the queue table
 * @param secondary_instance    - Owner of the queue table if the primary instance is not available
 *
 * @note
 * See OCI_QueueTableCreate() from more details
 *
 * @note
 * this call wraps the PL/SQL procedure DBMS_AQADM.ALTER_QUEUE_TABLE().
 * Refer to Oracle Streams - Advanced Queuing User's Guide for more details
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_QueueTableAlter(con: *mut OCI_Connection,
                               queue_table: *const otext,
                               comment: *const otext,
                               primary_instance: ::std::os::raw::c_uint,
                               secondary_instance: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Drop the given queue table
 *
 * @param con         - Connection handle
 * @param queue_table - Queue table name
 * @param force       - Force the deletion of objects related to the queue table
 *
 * @note
 * Possible values for 'force' :
 *  - TRUE  : all queues using the queue table and their associated propagation schedules are
 *            dropped automatically
 *  - FALSE : All the queues using the given queue table must be stopped and dropped before the
 *            queue table can be dropped.
 *
 * @note
 * this call wraps the PL/SQL procedure DBMS_AQADM.DROP_QUEUE_TABLE().
 * Refer to Oracle Streams - Advanced Queuing User's Guide for more details
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_QueueTableDrop(con: *mut OCI_Connection,
                              queue_table: *const otext,
                              force: ::std::os::raw::c_int)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Purge messages from the given queue table
 *
 * @param con             - Connection handle
 * @param queue_table     - Queue table name
 * @param purge_condition - Optional SQL based conditions (see notes)
 * @param block           - Lock all queues using the queue table while doing the purge
 * @param delivery_mode   - Type of message to purge
 *
 * @note
 * Possible values for parameter 'delivery_mode' :
 *  - OCI_APM_BUFFERED      : purge only buffered   messages
 *  - OCI_APM_PERSISTENT    : purge only persistent messages
 *  - OCI_APM_ALL           : purge all messages
 *
 * @note
 * For more information about the SQL purge conditions, refer to
 *  Oracle Streams - Advanced Queuing User's Guide for more details
 *
 * @warning
 * This feature is only available from ORacle 10gR2.
 * This function does nothing and returns TRUE is the server version is < Oracle 10gR2
 *
 * @note
 * this call wraps the PL/SQL procedure DBMS_AQADM.PURGE_QUEUE_TABLE().
 * Refer to Oracle Streams - Advanced Queuing User's Guide for more details
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_QueueTablePurge(con: *mut OCI_Connection,
                               queue_table: *const otext,
                               purge_condition: *const otext,
                               block: ::std::os::raw::c_int,
                               delivery_mode: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Migrate a queue table from one version to another
 *
 * @param con             - Connection handle
 * @param queue_table     - Queue table name
 * @param compatible      - Database version with witch the queue table has to migrate
 *
 * @note
 * Possible values for parameter 'compatible' :
 * - "8.0", "8.1", "10.0"
 *
 * @note
 * this call wraps the PL/SQL procedure DBMS_AQADM.MIGRATE_QUEUE_TABLE().
 * Refer to Oracle Streams - Advanced Queuing User's Guide for more details
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_QueueTableMigrate(con: *mut OCI_Connection,
                                 queue_table: *const otext,
                                 compatible: *const otext)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Register a notification against the given database
 *
 * @param con      - Connection handle
 * @param name     - Notification name
 * @param type     - Subscription type
 * @param handler  - User handler callback
 * @param port     - Port to use for notifications
 * @param timeout  - notification timeout
 *
 * @note
 * Parameter 'type' can be one of the following values :
 *
 * - OCI_CNT_OBJECTS   : request for changes at objects (e.g. tables) level (DDL / DML)
 * - OCI_CNT_ROWS      : request for changes at rows level (DML)
 * - OCI_CNT_DATABASES : request for changes at database level (startup, shutdown)
 * - OCI_CNT_ALL       : request for all changes
 *
 * @note
 * OCI_ENV_EVENTS flag must be passed to OCI_Initialize() to be able to use
 * subscriptions
 *
 * @note
 * Requires Oracle Client 10gR2 or above
 *
 * @note
 * Subscription handles are automatically managed by the library
 *
 * @return
 * Subscription handle on success or NULL on failure
 *
 */
    pub fn OCI_SubscriptionRegister(con: *mut OCI_Connection,
                                    name: *const otext,
                                    type_: ::std::os::raw::c_uint,
                                    handler: POCI_NOTIFY,
                                    port: ::std::os::raw::c_uint,
                                    timeout: ::std::os::raw::c_uint)
     -> *mut OCI_Subscription;
}
extern "C" {
    /**
 * @brief
 * Unregister a previously registered notification
 *
 * @param sub - Subscription handle
 *
 * @note
 * OCI_Cleanup() will automatically unregister any registered subscriptions
 *
 * @note
 * If the database connection passed to OCI_SubscriptionRegister()
 * has been closed by the time that the application calls
 * OCI_SubscriptionUnregister, the library internally reconnects
 * to the given database, performs the unregistration and then disconnects
 *
 * @note
 * OCI_ENV_EVENTS flag must be passed to OCI_Initialize() to be able to use
 * subscriptions
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SubscriptionUnregister(sub: *mut OCI_Subscription)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Add a statement to the notification to monitor
 *
 * @param sub  - Subscription handle
 * @param stmt - Statement handle
 *
 * @note
 * The given statement must be prepared but not executed before being passed to this function.
 * OCI_SubscriptionAddStatement() executes the statement and register it for notifications
 *
 * @note
 * OCI_ENV_EVENTS flag must be passed to OCI_Initialize() to be able to use
 * subscriptions
 *
 * @note
 * The given statement must hold a 'SELECT' SQL statement
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_SubscriptionAddStatement(sub: *mut OCI_Subscription,
                                        stmt: *mut OCI_Statement)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the name of the given registered subscription
 *
 * @param sub - Subscription handle
 *
 * @note
 * OCI_ENV_EVENTS flag must be passed to OCI_Initialize() to be able to use
 * subscriptions
 *
 */
    pub fn OCI_SubscriptionGetName(sub: *mut OCI_Subscription)
     -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the port used by the notification
 *
 * @param sub - Subscription handle
 *
 * @note
 * OCI_ENV_EVENTS flag must be passed to OCI_Initialize() to be able to use
 * subscriptions
 *
 */
    pub fn OCI_SubscriptionGetPort(sub: *mut OCI_Subscription)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the timeout of the given registered subscription
 *
 * @param sub - Subscription handle
 *
 * @note
 * OCI_ENV_EVENTS flag must be passed to OCI_Initialize() to be able to use
 * subscriptions
 *
 */
    pub fn OCI_SubscriptionGetTimeout(sub: *mut OCI_Subscription)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the connection handle associated with a subscription handle
 *
 * @param sub - Subscription handle
 *
 * @note
 * It may return a NULL handle if the connection used in OCI_SubscriptionRegister has been closed.
 *
 */
    pub fn OCI_SubscriptionGetConnection(sub: *mut OCI_Subscription)
     -> *mut OCI_Connection;
}
extern "C" {
    /**
 * @brief
 * Return the type of event reported by a notification
 *
 * @param event - Event handle
 *
 * @note
 * The returned value can be one of the following values :
 *
 * - OCI_ENT_STARTUP        : a database has been started up
 * - OCI_ENT_SHUTDOWN       : a database has been shut down
 * - OCI_ENT_SHUTDOWN_ANY   : a database has been shut down (RAC)
 * - OCI_ENT_DROP_DATABASE  : a database has been dropped
 * - OCI_ENT_DEREGISTER     : the notification is timed out
 * - OCI_ENT_OBJECT_CHANGED : a database object has been modified
 *
 * @note
 * OCI_EventGetDatabase() returns the affected database
 *
 * @note
 * OCI_ENV_EVENTS flag must be passed to OCI_Initialize() to be able to use
 * subscriptions
 *
 * @note
 * OCI_EventGetObject() returns the affected object
 * ('schema_name'.'object_name')
 *
 */
    pub fn OCI_EventGetType(event: *mut OCI_Event) -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the type of operation reported by a notification
 *
 * @param event - Event handle
 *
 * @note
 * This call is only valid when OCI_EventGetType() reports the
 * event type OCI_ENT_OBJECT_CHANGED
 *
 * @note
 * The returned value can be one of the following values :
 *
 * - OCI_ONT_INSERT  : an insert has been performed
 * - OCI_ONT_UPDATE  : an update has been performed
 * - OCI_ONT_DELETE  : a  delete has been performed
 * - OCI_ONT_ALTER   : an alter  has been performed
 * - OCI_ONT_DROP    : a  drop   has been performed
 * - OCI_ONT_GENERIC : generic undefined action
 *
 * @note
 * OCI_EventGetDatabase() returns the affected database
 *
 * @note
 * OCI_EventGetObject() returns the affected object ('schema_name'.'object_name')
 *
 * @note
 * OCI_ENV_EVENTS flag must be passed to OCI_Initialize() to be able to use
 * subscriptions
 *
 * @note
 * if OCI_CNT_ROWS is passed to OCI_SubscriptionRegister(),
 * the rowid of the altered row can be retrieved with OCI_EventGetRowid()
 *
 */
    pub fn OCI_EventGetOperation(event: *mut OCI_Event)
     -> ::std::os::raw::c_uint;
}
extern "C" {
    /**
 * @brief
 * Return the name of the database that generated the event
 *
 * @param event - Event handle
 *
 * @note
 * OCI_ENV_EVENTS flag must be passed to OCI_Initialize() to be able to use
 * subscriptions
 *
 */
    pub fn OCI_EventGetDatabase(event: *mut OCI_Event) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the name of the object that generated the event
 *
 * @param event - Event handle
 *
 * @note
 * OCI_ENV_EVENTS flag must be passed to OCI_Initialize() to be able to use
 * subscriptions
 *
 */
    pub fn OCI_EventGetObject(event: *mut OCI_Event) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the rowid of the altered database object row
 *
 * @param event - Event handle
 *
 * @note
 * OCI_ENV_EVENTS flag must be passed to OCI_Initialize() to be able to use
 * subscriptions
 *
 */
    pub fn OCI_EventGetRowid(event: *mut OCI_Event) -> *const otext;
}
extern "C" {
    /**
 * @brief
 * Return the subscription handle that generated this event
 *
 * @param event - Event handle
 *
 * @note
 * OCI_ENV_EVENTS flag must be passed to OCI_Initialize() to be able to use
 * subscriptions
 *
 */
    pub fn OCI_EventGetSubscription(event: *mut OCI_Event)
     -> *mut OCI_Subscription;
}
extern "C" {
    /**
 * @brief
 * Start a database instance
 *
 * @param db         - Oracle Service Name
 * @param user       - Oracle User name
 * @param pwd        - Oracle User password
 * @param sess_mode  - Session mode
 * @param start_mode - Start mode
 * @param start_flag - Start flags
 * @param spfile     - Client-side spfile to start up the database (optional)
 *
 * Possible values for parameter sess_mode :
 * - OCI_SESSION_SYSDBA
 * - OCI_SESSION_SYSOPER
 *
 * @note
 * External credentials are supported by supplying a null value for the 'user' and 'pwd' parameters
 * If the param 'db' is NULL then a connection to the default local DB is done
 *
 * Possible (combined) values for parameter start_mode :
 * - OCI_DB_SPM_START : start the instance
 * - OCI_DB_SPM_MOUNT : mount the instance
 * - OCI_DB_SPM_OPEN  : open the instance
 * - OCI_DB_SPM_FULL  : start, mount and open the instance
 *
 * Possible (combined) values for parameter start_flag :
 * - OCI_DB_SPF_DEFAULT  : default startup
 * - OCI_DB_SPF_FORCE    : shuts down a running instance (if needed) using
 *                         ABORT command and starts a new instance
 * - OCI_DB_SPF_RESTRICT : allows database access only to users with both
 *                         CREATE SESSION and RESTRICTED SESSION privileges
 *
 * @note
 * If the client side spfile is not provided, the database is started with its server-side spfile
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DatabaseStartup(db: *const otext, user: *const otext,
                               pwd: *const otext,
                               sess_mode: ::std::os::raw::c_uint,
                               start_mode: ::std::os::raw::c_uint,
                               start_flag: ::std::os::raw::c_uint,
                               spfile: *const otext) -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Shutdown a database instance
 *
 * @param db         - Oracle Service Name
 * @param user       - Oracle User name
 * @param pwd        - Oracle User password
 * @param sess_mode  - Session mode
 * @param shut_mode  - Shutdown mode
 * @param shut_flag  - Shutdown flag
 *
 *
 * @warning
 * Possible values for parameter sess_mode :
 * - OCI_SESSION_SYSDBA
 * - OCI_SESSION_SYSOPER
 *
 * @note
 * External credentials are supported by supplying a null value for the 'user' and 'pwd' parameters
 * If the param 'db' is NULL then a connection to the default local DB is done
 *
 * Possible (combined) values for parameter shut_mode :
 * - OCI_DB_SDM_SHUTDOWN : shutdown the instance
 * - OCI_DB_SDM_CLOSE    : close the instance
 * - OCI_DB_SDM_DISMOUNT : dismount the instance
 * - OCI_DB_SDM_FULL     : shutdown, close and dismount the instance
 *
 * Possible (exclusive) value for parameter shut_flag (from Oracle documentation) :
 * - OCI_DB_SDF_DEFAULT     :
 *   - Further connects are prohibited.
 *   - Waits for users to disconnect from the database
 * - OCI_DB_SDF_TRANS       :
 *   - Further connects are prohibited
 *   - No new transactions are allowed.
 *   - Waits for active transactions to complete
 * - OCI_DB_SDF_TRANS_LOCAL :
 *   - Further connects are prohibited
 *   - No new transactions are allowed.
 *   - Waits only for local transactions to complete
 * - OCI_DB_SDF_IMMEDIATE   :
 *   - Does not wait for current calls to complete or users to disconnect from the database.
 *   - All uncommitted transactions are terminated and rolled back
 * - OCI_DB_SDF_ABORT       :
 *   - Does not wait for current calls to complete or users to disconnect from the database.
 *   - All uncommitted transactions are terminated and are not rolled back.
 *   - This is the fastest possible way to shut down the database, but the next
 *     database startup may require instance recovery.
 *   - Therefore, this option should be used only in unusual circumstances
 *
 * @return
 * TRUE on success otherwise FALSE
 *
 */
    pub fn OCI_DatabaseShutdown(db: *const otext, user: *const otext,
                                pwd: *const otext,
                                sess_mode: ::std::os::raw::c_uint,
                                shut_mode: ::std::os::raw::c_uint,
                                shut_flag: ::std::os::raw::c_uint)
     -> ::std::os::raw::c_int;
}
extern "C" {
    /**
 * @brief
 * Return the OCI Environment Handle (OCIEnv *) of OCILIB library
 *
 * @return
 * OCI Environment handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetEnvironment() -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return the OCI Context Handle (OCISvcCtx *) of an OCILIB OCI_Connection object
 *
 * @param con - Connection handle
 *
 * @return
 * OCI Context handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetContext(con: *mut OCI_Connection)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return the OCI Server Handle (OCIServer *) of an OCILIB OCI_Connection object
 *
 * @param con - Connection handle
 *
 * @return
 * OCI Server handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetServer(con: *mut OCI_Connection)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return the OCI Error Handle (OCIError *) of an OCILIB OCI_Connection object
 *
 * @param con - Connection handle
 *
 * @return
 * OCI Error handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetError(con: *mut OCI_Connection)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return the OCI Session Handle (OCISession *) of an OCILIB OCI_Connection object
 *
 * @param con - Connection handle
 *
 * @return
 * OCI Session handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetSession(con: *mut OCI_Connection)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return the OCI Transaction Handle (OCITrans *) of an OCILIB OCI_Transaction object
 *
 * @param trans - Transaction handle
 *
 * @return
 * OCI Transaction handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetTransaction(trans: *mut OCI_Transaction)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return the OCI Statement Handle (OCIStmt *) of an OCILIB OCI_Statement object
 *
 * @param stmt - Statement handle
 *
 * @return
 * OCI Statement handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetStatement(stmt: *mut OCI_Statement)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return the OCI LobLocator Handle (OCILobLocator *) of an OCILIB OCI_Lob object
 *
 * @param lob - Lob handle
 *
 * @return
 * OCI LobLocator handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetLob(lob: *mut OCI_Lob)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return the OCI LobLocator Handle (OCILobLocator *) of an OCILIB OCI_File object
 *
 * @param file - File handle
 *
 * @return
 * OCI LobLocator handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetFile(file: *mut OCI_File)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return the OCI Date Handle (OCIDate *) of an OCILIB OCI_Date object
 *
 * @param date - Date handle
 *
 * @return
 * OCI Date handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetDate(date: *mut OCI_Date)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return the OCI Date time Handle (OCIDatetime *) of an OCILIB OCI_Timestamp  object
 *
 * @param tmsp - Timestamp handle
 *
 * @return
 * OCI Date time handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetTimestamp(tmsp: *mut OCI_Timestamp)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return OCI Interval Handle (OCIInterval *) of an OCILIB OCI_Interval object
 *
 * @param itv - Interval handle
 *
 * @return
 * OCI Interval handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetInterval(itv: *mut OCI_Interval)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return OCI Object Handle (void *) of an OCILIB OCI_Object object
 *
 * @param obj - Object handle
 *
 * @return
 * OCI Object handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetObject(obj: *mut OCI_Object)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return OCI Collection Handle (OCIColl *) of an OCILIB OCI_Coll object
 *
 * @param coll - Collection handle
 *
 * @return
 * OCI Collection handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetColl(coll: *mut OCI_Coll)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return OCI Ref Handle (OCIRef *) of an OCILIB OCI_Ref object
 *
 * @param ref - Ref handle
 *
 * @return
 * OCI Ref handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetRef(ref_: *mut OCI_Ref)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return OCI Mutex handle (OCIThreadMutex *) of an OCILIB OCI_Mutex object
 *
 * @param mutex - Mutex handle
 *
 * @return
 * OCI Mutex handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetMutex(mutex: *mut OCI_Mutex)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return OCI Thread ID (OCIThreadId *) of an OCILIB OCI_Thread object
 *
 * @param thread - Thread handle
 *
 * @return
 * OCI Thread ID otherwise NULL
 *
 */
    pub fn OCI_HandleGetThreadID(thread: *mut OCI_Thread)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return OCI Thread handle (OCIThreadHandle *) of an OCILIB OCI_Thread object
 *
 * @param thread - Thread handle
 *
 * @return
 * OCI Thread handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetThread(thread: *mut OCI_Thread)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return OCI DirectPath Context handle (OCIDirPathCtx *) of an OCILIB OCI_DirPath object
 *
 * @param dp - DirectPath handle
 *
 * @return
 * OCI DirectPath Context handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetDirPathCtx(dp: *mut OCI_DirPath)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return OCI DirectPath Column array handle (OCIDirPathColArray *) of an OCILIB OCI_DirPath object
 *
 * @param dp - DirectPath handle
 *
 * @return
 * OCI DirectPath Column array handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetDirPathColArray(dp: *mut OCI_DirPath)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return OCI DirectPath Stream handle (OCIDirPathStream *) of an OCILIB OCI_DirPath object
 *
 * @param dp - DirectPath handle
 *
 * @return
 * OCI DirectPath Stream handle otherwise NULL
 *
 */
    pub fn OCI_HandleGetDirPathStream(dp: *mut OCI_DirPath)
     -> *const ::std::os::raw::c_void;
}
extern "C" {
    /**
 * @brief
 * Return OCI Subscription handle (OCISubscription *) of an OCILIB OCI_Subscription object
 *
 * @param sub - Subscription handle
 *
 * @return
 * OCI Subscription otherwise NULL
 *
 */
    pub fn OCI_HandleGetSubscription(sub: *mut OCI_Subscription)
     -> *const ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
